{
    "docs": [
        {
            "location": "/", 
            "text": "MATRIX Ecosystem Overview\n\n\nObjective: Hardware shouldn't be hard\n\n\nThe MATRIX Ecosystem was created to make powerful hardware projects very approachable for software developers. The pillars of MATRIX, computer vision, hardware interfaces, distributed internet communication, and data-driven end-user clients, are all programming disciplines which require years for an individual to master, or for a team to build a solution around.\n\n\nMATRIX adds powerful capabilities to your Raspberry Pi, depending on your background and the kind of application you want to write, you may prefer to integrate with different layers. The documentation is organized according to these layers:\n\n\n\n\nMATRIX OS Docs\n\n\nMATRIX CORE Docs\n\n\nMATRIX HAL Docs\n\n\n\n\n\n\nMATRIX Open System\n\n\nTop-level application and connection layer integrating with MATRIX hardware via \nMATRIX CORE\n.\n\n\nRead more about MATRIX OS\n\n\nMATRIX CORE\n\n\nAbstraction layer for HAL. Hosts a ZeroMQ + Protobuf communication layer which makes device information accessible via high-level interfaces. Supports 40+ different languages, C++, Python, Ruby, PHP, Java, etc. \n\n\nRead more about MATRIX CORE\n\n\nMATRIX HAL\n\n\nC++ drivers for sensors and available components. Tooling for accessing the FPGA and microcontrollers on the MATRIX device.\n\n\nRead more about MATRIX HAL\n\n\nWhat do you need to get started?\n\n\n\n\nRaspberry Pi\n\n\nMATRIX Creator\n\n\n\n\nSupport\n\n\n\n\nPost questions or comments on \ncommunity.matrix.one\n\n\nPost package issues on github under \nmatrix-io\n\n\nSubmit documentation issues or improvements at \nmatrix-io/matrix-documentation", 
            "title": "Overview"
        }, 
        {
            "location": "/#matrix-ecosystem-overview", 
            "text": "", 
            "title": "MATRIX Ecosystem Overview"
        }, 
        {
            "location": "/#objective-hardware-shouldnt-be-hard", 
            "text": "The MATRIX Ecosystem was created to make powerful hardware projects very approachable for software developers. The pillars of MATRIX, computer vision, hardware interfaces, distributed internet communication, and data-driven end-user clients, are all programming disciplines which require years for an individual to master, or for a team to build a solution around.  MATRIX adds powerful capabilities to your Raspberry Pi, depending on your background and the kind of application you want to write, you may prefer to integrate with different layers. The documentation is organized according to these layers:   MATRIX OS Docs  MATRIX CORE Docs  MATRIX HAL Docs", 
            "title": "Objective: Hardware shouldn't be hard"
        }, 
        {
            "location": "/#matrix-open-system", 
            "text": "Top-level application and connection layer integrating with MATRIX hardware via  MATRIX CORE .  Read more about MATRIX OS", 
            "title": "MATRIX Open System"
        }, 
        {
            "location": "/#matrix-core", 
            "text": "Abstraction layer for HAL. Hosts a ZeroMQ + Protobuf communication layer which makes device information accessible via high-level interfaces. Supports 40+ different languages, C++, Python, Ruby, PHP, Java, etc.   Read more about MATRIX CORE", 
            "title": "MATRIX CORE"
        }, 
        {
            "location": "/#matrix-hal", 
            "text": "C++ drivers for sensors and available components. Tooling for accessing the FPGA and microcontrollers on the MATRIX device.  Read more about MATRIX HAL", 
            "title": "MATRIX HAL"
        }, 
        {
            "location": "/#what-do-you-need-to-get-started", 
            "text": "Raspberry Pi  MATRIX Creator", 
            "title": "What do you need to get started?"
        }, 
        {
            "location": "/#support", 
            "text": "Post questions or comments on  community.matrix.one  Post package issues on github under  matrix-io  Submit documentation issues or improvements at  matrix-io/matrix-documentation", 
            "title": "Support"
        }, 
        {
            "location": "/setup/", 
            "text": "Device Setup\n\n\nCongratulations on your purchase of a MATRIX device, we hope this is the beginning of an exciting adventure of making and discovery.\n\n\nConnecting your Device to a Pi\n\n\n\n\nYour MATRIX device is made to fit atop a Raspberry Pi.\n\n\n\n\n\n\nIf you're using a Camera, be sure to connect it now.\n\n\n\n\nAlign the MATRIX device pin slots to the GPIO pins on the Pi.\n\n\n\n\nPress together firmly.\n\n\n\n\n\n\nThe center of the Pi should roughly align with the center of the MATRIX device.\n\n\n\n\nInsert SD Card\n\n\nMake sure you have a copy of Raspbian on that Micro SD Card of yours, and ensure that it's seated well in the SD Card slot.\n\n\n\n\nPower On\n\n\nConnect at least 2.5A of power to your Raspberry Pi.\n\n\nContinue\n\n\nWhere to go next with your MATRIX is entirely dependent on your level of comfort.\n\n\n\n\nMATRIX OS\n - A fully managed platform for your devices, data and behaviors, with the primary language being Javascript.\n\n\nMATRIX CORE\n - Centralized software protocol to enable communication with the hardware, with 40+ languages supported.\n\n\nMATRIX HAL\n - C++ drivers for sensors and available components. Tooling for accessing the FPGA and microcontrollers on the MATRIX device.", 
            "title": "Device Setup"
        }, 
        {
            "location": "/setup/#device-setup", 
            "text": "Congratulations on your purchase of a MATRIX device, we hope this is the beginning of an exciting adventure of making and discovery.", 
            "title": "Device Setup"
        }, 
        {
            "location": "/setup/#connecting-your-device-to-a-pi", 
            "text": "", 
            "title": "Connecting your Device to a Pi"
        }, 
        {
            "location": "/setup/#your-matrix-device-is-made-to-fit-atop-a-raspberry-pi", 
            "text": "If you're using a Camera, be sure to connect it now.", 
            "title": "Your MATRIX device is made to fit atop a Raspberry Pi."
        }, 
        {
            "location": "/setup/#align-the-matrix-device-pin-slots-to-the-gpio-pins-on-the-pi", 
            "text": "", 
            "title": "Align the MATRIX device pin slots to the GPIO pins on the Pi."
        }, 
        {
            "location": "/setup/#press-together-firmly", 
            "text": "", 
            "title": "Press together firmly."
        }, 
        {
            "location": "/setup/#the-center-of-the-pi-should-roughly-align-with-the-center-of-the-matrix-device", 
            "text": "", 
            "title": "The center of the Pi should roughly align with the center of the MATRIX device."
        }, 
        {
            "location": "/setup/#insert-sd-card", 
            "text": "Make sure you have a copy of Raspbian on that Micro SD Card of yours, and ensure that it's seated well in the SD Card slot.", 
            "title": "Insert SD Card"
        }, 
        {
            "location": "/setup/#power-on", 
            "text": "Connect at least 2.5A of power to your Raspberry Pi.", 
            "title": "Power On"
        }, 
        {
            "location": "/setup/#continue", 
            "text": "Where to go next with your MATRIX is entirely dependent on your level of comfort.   MATRIX OS  - A fully managed platform for your devices, data and behaviors, with the primary language being Javascript.  MATRIX CORE  - Centralized software protocol to enable communication with the hardware, with 40+ languages supported.  MATRIX HAL  - C++ drivers for sensors and available components. Tooling for accessing the FPGA and microcontrollers on the MATRIX device.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-os/", 
            "text": "MATRIX Open System\n\n\nMATRIX Open System (MOS) manages Javascript-based applications on MATRIX devices. \n\n\nRead more about \nMATRIX Applications\n\n\nUsing MATRIX Open System\n\n\n\n\nMATRIX devices must be linked with your account to use MOS. If your MATRIX device starts with a pulsing blue light, MOS is installed and ready for \nBluetooth Pairing\n. Otherwise, you can start from scratch with \nManual Installation \n Registration\n.\n\n\n\n\nMOS devices and applications can be managed and observed via the \nMATRIX Dashboard\n, or via mobile apps on Android and iOS. \n\n\nTo learn more about applications, tooling and the dashboard, start at \nOverview\n\n\nDeveloping MATRIX Applications\n\n\n\n\nTo develop on MOS, you should have some familiarity with JavaScript and how to do command line operations. See \nPrerequisites\n for more details. \n\n\n\n\nFirst, install the \nCommand Line Tool\n and register your device, either via CLI or mobile app. After your device is registered, the best place to start with developing MOS applications is \nHello World\n. This will get you familiar with the MOS application-device workflow. \n\n\nContinue\n\n\nAfter the CLI is installed, visit \nNext Steps\n to get started with \nexamples\n, or dive into the \nreference\n.\n\n\nWhen you're done, you can \npublish", 
            "title": "MATRIX OS"
        }, 
        {
            "location": "/matrix-os/#matrix-open-system", 
            "text": "MATRIX Open System (MOS) manages Javascript-based applications on MATRIX devices.   Read more about  MATRIX Applications", 
            "title": "MATRIX Open System"
        }, 
        {
            "location": "/matrix-os/#using-matrix-open-system", 
            "text": "MATRIX devices must be linked with your account to use MOS. If your MATRIX device starts with a pulsing blue light, MOS is installed and ready for  Bluetooth Pairing . Otherwise, you can start from scratch with  Manual Installation   Registration .   MOS devices and applications can be managed and observed via the  MATRIX Dashboard , or via mobile apps on Android and iOS.   To learn more about applications, tooling and the dashboard, start at  Overview", 
            "title": "Using MATRIX Open System"
        }, 
        {
            "location": "/matrix-os/#developing-matrix-applications", 
            "text": "To develop on MOS, you should have some familiarity with JavaScript and how to do command line operations. See  Prerequisites  for more details.    First, install the  Command Line Tool  and register your device, either via CLI or mobile app. After your device is registered, the best place to start with developing MOS applications is  Hello World . This will get you familiar with the MOS application-device workflow.", 
            "title": "Developing MATRIX Applications"
        }, 
        {
            "location": "/matrix-os/#continue", 
            "text": "After the CLI is installed, visit  Next Steps  to get started with  examples , or dive into the  reference .  When you're done, you can  publish", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-os/getting-started/prerequisites/", 
            "text": "Prerequisites\n\n\nHardware\n\n\n\n\nMobile Application\n Installed\n\n\nRaspberry Pi with MATRIX Creator\n\n\nRaspberry Pi Camera\n\n\nSD Card with \nMATRIX Open System\n installed.\n\n\n\n\nSoftware\n\n\n\n\nCommand Line - ( Terminal on OSX / Ubuntu or Prompt/PuTTy on Windows )\n\n\nBasic Knowledge of Terminal/Prompty/PuTTy.\n\n\nBasic Knowledge of JavaScript. Familiarity with events and callbacks is helpful.\n\n\nHost computer running Linux, Win, or OS X for \nCommand Line Interface\n, with \nNodeJS, Node Package Manager (npm)\n installed.\n\n\n\n\nContinue\n\n\nOnce you have all the prerequsites listed above, you can continue to \nNext Steps\n or create your first MATRIX \nHello World\n application.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/matrix-os/getting-started/prerequisites/#prerequisites", 
            "text": "", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/matrix-os/getting-started/prerequisites/#hardware", 
            "text": "Mobile Application  Installed  Raspberry Pi with MATRIX Creator  Raspberry Pi Camera  SD Card with  MATRIX Open System  installed.", 
            "title": "Hardware"
        }, 
        {
            "location": "/matrix-os/getting-started/prerequisites/#software", 
            "text": "Command Line - ( Terminal on OSX / Ubuntu or Prompt/PuTTy on Windows )  Basic Knowledge of Terminal/Prompty/PuTTy.  Basic Knowledge of JavaScript. Familiarity with events and callbacks is helpful.  Host computer running Linux, Win, or OS X for  Command Line Interface , with  NodeJS, Node Package Manager (npm)  installed.", 
            "title": "Software"
        }, 
        {
            "location": "/matrix-os/getting-started/prerequisites/#continue", 
            "text": "Once you have all the prerequsites listed above, you can continue to  Next Steps  or create your first MATRIX  Hello World  application.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/", 
            "text": "Installation \n Registration\n\n\n\n\nMATRIX Open System is currently targeted to run on Raspbian. \n\n\n\n\nYour MATRIX device may or may not have \nMATRIX Open System\n preinstalled on it. These instructions are included if you need to build your own MOS image.\n\n\nSet up your Personal Computer\n\n\n\n\nYou need \nNodeJS, and the Node Package Manager (npm)\n installed. See \npre-requisites\n for more details.\n\n\n\n\nThese next instructions can be executed your personal computer or Raspberry Pi. We would recommend installing the \nCommand Line Interface\n (CLI) on your local computer, not the Raspberry Pi.\n\n\n\n\nInstall the CLI via npm \nnpm install -g matrix-cli\n\n\nmatrix login\n if you have a MATRIX Labs account, otherwise \nmatrix register\n to sign up\n\n\nLog into your account using \nmatrix login\n\n\nOnce registered an account, run \nmatrix register device\n\n\nEnter a \ndevice name\n and (optional) \ndevice description\n\n\nAfter a few moments you will be provided with a \nMATRIX_DEVICE_ID\n and \nMATRIX_DEVICE_SECRET\n\n\n\n\nLogin Credentials\n\n\n# example variables generated via registration,\n# yours will be different for each device you create.\n\nexport MATRIX_DEVICE_ID=dc7a1a71be2d\nexport MATRIX_DEVICE_SECRET=08629018e9d77h15i5n0t4r3alz0f06cd4f7e5544272b\n\n\n\n\nNote:\n Save these for \ndevice-registration\n.\n\n\nSet up your Raspberry Pi\n\n\n\n\nYour Pi needs a \nclean Raspbian install\n.\n\n\n\n\nAccess a command prompt on your Pi. \n\n\nMOS Installation\n\n\nThis command will install the \nMATRIX Open System\n and required sub-components. Expect the device to reboot when finished.\n\n\ncurl https://raw.githubusercontent.com/matrix-io/matrix-creator-quickstart/master/install.sh | sh\n\n\n\n\nNote:\n \nWatch Getting Started, Registration and Installation\n of MATRIX OS and MATRIX CLI on Youtube.\n\n\nDevice Registration\n\n\n\n\nInside your home folder (\n~\n), create a file named \n.envrc\n. Type \ntouch .envrc\n to create the file. \n\n\nCopy and paste the id \n secret exports exactly as shown in the section \nLogin Credentials\n above.\n\n\nRun \nsource ~/.envrc\n to make the variables available to the shell, which will then be used when starting MOS.\n\n\nGo to \nmatrix-os\n folder with \ncd ~/matrix-os\n and run \nnode index.js\n to start the OS.\n\n\n\n\nCheck if everything works\n\n\n\n\nOn your Personal Computer, If you didn't do it earlier, in PuTTy, Terminal, or Command Prompt, type \nmatrix use {deviceId}\n or \nmatrix use {deviceName}\n\n\nTry \nmatrix ping\n, the device should flash a few seconds later.\n\n\nNow you can issue commands and \ndeploy applications\n to your MATRIX OS from the \nMATRIX CLI\n.\n\n\n\n\nContinue\n\n\n\n\nSee \nHello World\n example\n\n\nSee \nManual Setup", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#installation-registration", 
            "text": "MATRIX Open System is currently targeted to run on Raspbian.    Your MATRIX device may or may not have  MATRIX Open System  preinstalled on it. These instructions are included if you need to build your own MOS image.", 
            "title": "Installation &amp; Registration"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#set-up-your-personal-computer", 
            "text": "You need  NodeJS, and the Node Package Manager (npm)  installed. See  pre-requisites  for more details.   These next instructions can be executed your personal computer or Raspberry Pi. We would recommend installing the  Command Line Interface  (CLI) on your local computer, not the Raspberry Pi.   Install the CLI via npm  npm install -g matrix-cli  matrix login  if you have a MATRIX Labs account, otherwise  matrix register  to sign up  Log into your account using  matrix login  Once registered an account, run  matrix register device  Enter a  device name  and (optional)  device description  After a few moments you will be provided with a  MATRIX_DEVICE_ID  and  MATRIX_DEVICE_SECRET", 
            "title": "Set up your Personal Computer"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#login-credentials", 
            "text": "# example variables generated via registration,\n# yours will be different for each device you create.\n\nexport MATRIX_DEVICE_ID=dc7a1a71be2d\nexport MATRIX_DEVICE_SECRET=08629018e9d77h15i5n0t4r3alz0f06cd4f7e5544272b  Note:  Save these for  device-registration .", 
            "title": "Login Credentials"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#set-up-your-raspberry-pi", 
            "text": "Your Pi needs a  clean Raspbian install .   Access a command prompt on your Pi.", 
            "title": "Set up your Raspberry Pi"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#mos-installation", 
            "text": "This command will install the  MATRIX Open System  and required sub-components. Expect the device to reboot when finished.  curl https://raw.githubusercontent.com/matrix-io/matrix-creator-quickstart/master/install.sh | sh  Note:   Watch Getting Started, Registration and Installation  of MATRIX OS and MATRIX CLI on Youtube.", 
            "title": "MOS Installation"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#device-registration", 
            "text": "Inside your home folder ( ~ ), create a file named  .envrc . Type  touch .envrc  to create the file.   Copy and paste the id   secret exports exactly as shown in the section  Login Credentials  above.  Run  source ~/.envrc  to make the variables available to the shell, which will then be used when starting MOS.  Go to  matrix-os  folder with  cd ~/matrix-os  and run  node index.js  to start the OS.", 
            "title": "Device Registration"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#check-if-everything-works", 
            "text": "On your Personal Computer, If you didn't do it earlier, in PuTTy, Terminal, or Command Prompt, type  matrix use {deviceId}  or  matrix use {deviceName}  Try  matrix ping , the device should flash a few seconds later.  Now you can issue commands and  deploy applications  to your MATRIX OS from the  MATRIX CLI .", 
            "title": "Check if everything works"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#continue", 
            "text": "See  Hello World  example  See  Manual Setup", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-os/getting-started/mobile-applications/", 
            "text": "Mobile Applications\n\n\nAccess and manage your MATRIX devices with the mobile apps\n\n\n\n\n\n\nApple Store\n\n\n\n\n\n\n\n\nPlay Store", 
            "title": "Mobile Apps"
        }, 
        {
            "location": "/matrix-os/getting-started/mobile-applications/#mobile-applications", 
            "text": "Access and manage your MATRIX devices with the mobile apps    Apple Store     Play Store", 
            "title": "Mobile Applications"
        }, 
        {
            "location": "/matrix-os/getting-started/pairing/", 
            "text": "Initial Pairing\n\n\n\n\nThe easiest way to start using MATRIX OS is to pair it using Bluetooth on your mobile phone.\n\n\n\n\nDownload the MATRIX application\n\n\nTurn on your MATRIX+Pi (lights should pulse blue after a minute if MOS is running properly)\n\n\nAdd a new device ( lights will flash green )\n\n\nAdd Name, description and Wifi information (if desired)\n\n\n\n\nContinue\n\n\nSee \nHello World!\n to install an application.", 
            "title": "Pairing"
        }, 
        {
            "location": "/matrix-os/getting-started/pairing/#initial-pairing", 
            "text": "The easiest way to start using MATRIX OS is to pair it using Bluetooth on your mobile phone.   Download the MATRIX application  Turn on your MATRIX+Pi (lights should pulse blue after a minute if MOS is running properly)  Add a new device ( lights will flash green )  Add Name, description and Wifi information (if desired)", 
            "title": "Initial Pairing"
        }, 
        {
            "location": "/matrix-os/getting-started/pairing/#continue", 
            "text": "See  Hello World!  to install an application.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-os/getting-started/hello-world/", 
            "text": "Application: Hello World\n\n\nYou will need\n\n\n\n\nA Registered \n Configured MATRIX Device\n\n\nInstalled Mobile Application OR \nCommand Line Tool\n\n\n\n\nAfter you have successfully configured your MATRIX OS installation on a MATRIX device, you can install applications.\n\n\nApplication Installation\n\n\nUsing the mobile application, or using the Command Line Tool, install \nsensorTest\n\n\n# after selecting device with `matrix use`\n\n matrix install sensorTest\n\n\n\n\nPermission will be asked before install commences, to continue, allow access for the application to all sensors.\n\n\nRunning an Application\n\n\nUsing the mobile application, flick the switch next to an application name to start. Or if using the Command Line Tool:\n\n\n matrix start sensorTest\n\n\n\n\nSuccess\n\n\nYou should see lights animating on the Everloop, one for every active sensor.\n\n\n\n\nContinue\n\n\nNow that you have installed and run an application, \nNext Steps\n will be able to guide your next MATRIX adventure.", 
            "title": "Hello World"
        }, 
        {
            "location": "/matrix-os/getting-started/hello-world/#application-hello-world", 
            "text": "", 
            "title": "Application: Hello World"
        }, 
        {
            "location": "/matrix-os/getting-started/hello-world/#you-will-need", 
            "text": "A Registered   Configured MATRIX Device  Installed Mobile Application OR  Command Line Tool   After you have successfully configured your MATRIX OS installation on a MATRIX device, you can install applications.", 
            "title": "You will need"
        }, 
        {
            "location": "/matrix-os/getting-started/hello-world/#application-installation", 
            "text": "Using the mobile application, or using the Command Line Tool, install  sensorTest  # after selecting device with `matrix use`  matrix install sensorTest  Permission will be asked before install commences, to continue, allow access for the application to all sensors.", 
            "title": "Application Installation"
        }, 
        {
            "location": "/matrix-os/getting-started/hello-world/#running-an-application", 
            "text": "Using the mobile application, flick the switch next to an application name to start. Or if using the Command Line Tool:   matrix start sensorTest", 
            "title": "Running an Application"
        }, 
        {
            "location": "/matrix-os/getting-started/hello-world/#success", 
            "text": "You should see lights animating on the Everloop, one for every active sensor.", 
            "title": "Success"
        }, 
        {
            "location": "/matrix-os/getting-started/hello-world/#continue", 
            "text": "Now that you have installed and run an application,  Next Steps  will be able to guide your next MATRIX adventure.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-os/getting-started/next-steps/", 
            "text": "Next Steps\n\n\nLearn more about MATRIX OS system fundamentals. \n\n\n\n\nOverview\n - High level concepts. Covers application lifecycle, the CLI, configuration, dashboards, and data.\n\n\nReference\n - Implementation details for the MATRIX OS SDK.\n\n\n\n\nExamples\n\n\n\n\nCreate An App\n\n\nBasic Dashboard\n\n\nSensor Test\n\n\nIFTTT Integration\n\n\n\n\nShare your creation\n\n\nShow us know what you've made and we'll share it to our channels! \n\n\n\n\nMATRIX Community\n\n\nTutorials/Projects Pages\n\n\nVideos\n\n\nMATRIX Twitter", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-os/getting-started/next-steps/#next-steps", 
            "text": "Learn more about MATRIX OS system fundamentals.    Overview  - High level concepts. Covers application lifecycle, the CLI, configuration, dashboards, and data.  Reference  - Implementation details for the MATRIX OS SDK.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-os/getting-started/next-steps/#examples", 
            "text": "Create An App  Basic Dashboard  Sensor Test  IFTTT Integration", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-os/getting-started/next-steps/#share-your-creation", 
            "text": "Show us know what you've made and we'll share it to our channels!    MATRIX Community  Tutorials/Projects Pages  Videos  MATRIX Twitter", 
            "title": "Share your creation"
        }, 
        {
            "location": "/matrix-os/overview/", 
            "text": "Overview\n\n\nMATRIX Open System (MOS) is open source software for hosting IoT applications. MATRIX Open System runs on node.js, and initially, applications will be written in JavaScript, however, as we finish writing SDKs, other languages will be supported. Python is first up.\n\n\nApplications\n\n\nFundamentally, MATRIX OS applications logically connect hardware with machine learning abstractions. In this way, you can connect the output from a computer vision system to drive real-world behavior in the form of hardware signaling. You can also use third party API's and integrations, such as IFTTT to further customize your application, for yourself, or for end-users.\n\n\nRead more at \nOverview \n Applications\n\n\nDashboard\n\n\nMOS applications optionally include a dashboard for exploring data.\n\n\nRead more at \nOverview \n Dashboard\n\n\nConfiguration\n\n\nIn order to make MOS applications flexible, powerful, and discoverable, each application has an associated file, \nconfig.yaml\n which sets the meta information needed for an application to execute safely and consistently.\n\n\nRead more at \nOverview \n Configuration\n\n\nCommand Line Interface\n\n\nAlong with mobile applications and the dashboard, the Command Line Interface (CLI) enables you to manage your MATRIX device and associated applications. If you want to develop MATRIX OS applications, you need to use the CLI to manage different aspects of the development lifecycle. \n\n\nRead more at \nOverview \n Command Line Interface\n\n\nSending Data\n\n\nMATRIX devices will only externally store data if it is explicitly sent via an application. If you want to use MATRIX Dashboard components to work with your data, it will need to be exported using the \nsend\n command.\n\n\nRead more at \nOverview \n Sending Data\n\n\nApplication Publishing\n\n\nYou can freely publish MATRIX applications to the MATRIX App store. \n\n\nRead more at \nOverview \n Publishing\n\n\nManual Setup\n\n\nIf you want to install MOS from scratch, start here.\n\n\nRead more at \nManual Setup", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-os/overview/#overview", 
            "text": "MATRIX Open System (MOS) is open source software for hosting IoT applications. MATRIX Open System runs on node.js, and initially, applications will be written in JavaScript, however, as we finish writing SDKs, other languages will be supported. Python is first up.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-os/overview/#applications", 
            "text": "Fundamentally, MATRIX OS applications logically connect hardware with machine learning abstractions. In this way, you can connect the output from a computer vision system to drive real-world behavior in the form of hardware signaling. You can also use third party API's and integrations, such as IFTTT to further customize your application, for yourself, or for end-users.  Read more at  Overview   Applications", 
            "title": "Applications"
        }, 
        {
            "location": "/matrix-os/overview/#dashboard", 
            "text": "MOS applications optionally include a dashboard for exploring data.  Read more at  Overview   Dashboard", 
            "title": "Dashboard"
        }, 
        {
            "location": "/matrix-os/overview/#configuration", 
            "text": "In order to make MOS applications flexible, powerful, and discoverable, each application has an associated file,  config.yaml  which sets the meta information needed for an application to execute safely and consistently.  Read more at  Overview   Configuration", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/overview/#command-line-interface", 
            "text": "Along with mobile applications and the dashboard, the Command Line Interface (CLI) enables you to manage your MATRIX device and associated applications. If you want to develop MATRIX OS applications, you need to use the CLI to manage different aspects of the development lifecycle.   Read more at  Overview   Command Line Interface", 
            "title": "Command Line Interface"
        }, 
        {
            "location": "/matrix-os/overview/#sending-data", 
            "text": "MATRIX devices will only externally store data if it is explicitly sent via an application. If you want to use MATRIX Dashboard components to work with your data, it will need to be exported using the  send  command.  Read more at  Overview   Sending Data", 
            "title": "Sending Data"
        }, 
        {
            "location": "/matrix-os/overview/#application-publishing", 
            "text": "You can freely publish MATRIX applications to the MATRIX App store.   Read more at  Overview   Publishing", 
            "title": "Application Publishing"
        }, 
        {
            "location": "/matrix-os/overview/#manual-setup", 
            "text": "If you want to install MOS from scratch, start here.  Read more at  Manual Setup", 
            "title": "Manual Setup"
        }, 
        {
            "location": "/matrix-os/overview/applications/", 
            "text": "Applications\n\n\nMOS applications act as a logical glue between hardware components, machine learning libraries and the internet. For example, you could train faces of a group of people, match it up with Twitter profiles, and have the MATRIX device read the last tweet by a recognized face. You could have your device watch for your face, and then after confirming with an NFC tag, it could unlock your front door. A wide world of possible interactions exists via MATRIX OS applications.\n\n\nReference\n\n\nMore detailed information about programming MOS applications can be found in \nCreate An App\n and \nReference\n.\n\n\nData Flow\n\n\nSensors push to applications which push to libraries which push back to the application, which pushes to the internet, other devices and dashboards. This one-way data flow is well matched with the listener/emitter event model of JavaScript and Node. We run a function, which is asynchronous, it sends a request to a sensor, library or web call, and waits for responses. Unlike traditional request / response style APIs, these are intended to be called once and handle many responses, sometimes in parallel.\n\n\nThis example initializes the temperature sensor, and then handles the response.\n\n\n# callback style\nmatrix.sensor('temperature', data =\n {\n  // data = { value: 74.123123 }\n});\n\n# promise style\nmatrix.sensor('temperature').then(data =\n {\n  // data = { value: 74.123123 }\n});\n\n\n\n\nLearn more about \ncallbacks\n or \npromises\n. MOS does not make true \nPromise\n objects, just borrows the \nthen\n syntax.\n\n\nAfter data is managed inside the application, it can be sent to the cloud for exporting, webhooks, analysis and to explore in the dashboard.\n\n\nLearn more about \nsending data\n\n\nDashboards\n\n\nEvery MOS application can display data and can be controlled by users on a highly customizable dashboard.  \n\n\nLearn more about \ndashboards\n\n\nConfiguration driven\n\n\nMOS applications use configuration files, \nconfig.yaml\n, to provide easy end-user adaptation, as well as extensive dashboard adaptability. Simple applications don't need any JavaScript and can be configuration only. Configuration is end-user accessible, and can provide unique information for individual instances of MOS applications across devices via \nsettings\n.\n\n\nLearn more about \nconfiguration\n\n\nDevelopment\n\n\nMOS applications are currently written in JavaScript. Python support is planned for the near future. You will need the \nCommand Line Interface\n installed to create, deploy and \npublish\n MOS applications.\n\n\nStart learning about MOS development with \nCreate An App\n and \nBasic Dashboards\n.\n\n\nMore details are available at the \nReference\n \n\n\nDevelopment Workflow\n\n\n\n\nmatrix create \napp-name\n\n\nCode and configure your app. \nMOS SDK Reference\n\n\nmatrix use \ndevice-id\n\n\nmatrix deploy \napp-name\n\n\nmatrix start \napp-name\n\n\nWatch the app output with \nmatrix log\n\n\nWhen finished, publish to \nMATRIX App Store\n with \nmatrix publish \napp-name", 
            "title": "Applications"
        }, 
        {
            "location": "/matrix-os/overview/applications/#applications", 
            "text": "MOS applications act as a logical glue between hardware components, machine learning libraries and the internet. For example, you could train faces of a group of people, match it up with Twitter profiles, and have the MATRIX device read the last tweet by a recognized face. You could have your device watch for your face, and then after confirming with an NFC tag, it could unlock your front door. A wide world of possible interactions exists via MATRIX OS applications.", 
            "title": "Applications"
        }, 
        {
            "location": "/matrix-os/overview/applications/#reference", 
            "text": "More detailed information about programming MOS applications can be found in  Create An App  and  Reference .", 
            "title": "Reference"
        }, 
        {
            "location": "/matrix-os/overview/applications/#data-flow", 
            "text": "Sensors push to applications which push to libraries which push back to the application, which pushes to the internet, other devices and dashboards. This one-way data flow is well matched with the listener/emitter event model of JavaScript and Node. We run a function, which is asynchronous, it sends a request to a sensor, library or web call, and waits for responses. Unlike traditional request / response style APIs, these are intended to be called once and handle many responses, sometimes in parallel.  This example initializes the temperature sensor, and then handles the response.  # callback style\nmatrix.sensor('temperature', data =  {\n  // data = { value: 74.123123 }\n});\n\n# promise style\nmatrix.sensor('temperature').then(data =  {\n  // data = { value: 74.123123 }\n});  Learn more about  callbacks  or  promises . MOS does not make true  Promise  objects, just borrows the  then  syntax.  After data is managed inside the application, it can be sent to the cloud for exporting, webhooks, analysis and to explore in the dashboard.  Learn more about  sending data", 
            "title": "Data Flow"
        }, 
        {
            "location": "/matrix-os/overview/applications/#dashboards", 
            "text": "Every MOS application can display data and can be controlled by users on a highly customizable dashboard.    Learn more about  dashboards", 
            "title": "Dashboards"
        }, 
        {
            "location": "/matrix-os/overview/applications/#configuration-driven", 
            "text": "MOS applications use configuration files,  config.yaml , to provide easy end-user adaptation, as well as extensive dashboard adaptability. Simple applications don't need any JavaScript and can be configuration only. Configuration is end-user accessible, and can provide unique information for individual instances of MOS applications across devices via  settings .  Learn more about  configuration", 
            "title": "Configuration driven"
        }, 
        {
            "location": "/matrix-os/overview/applications/#development", 
            "text": "MOS applications are currently written in JavaScript. Python support is planned for the near future. You will need the  Command Line Interface  installed to create, deploy and  publish  MOS applications.  Start learning about MOS development with  Create An App  and  Basic Dashboards .  More details are available at the  Reference", 
            "title": "Development"
        }, 
        {
            "location": "/matrix-os/overview/applications/#development-workflow", 
            "text": "matrix create  app-name  Code and configure your app.  MOS SDK Reference  matrix use  device-id  matrix deploy  app-name  matrix start  app-name  Watch the app output with  matrix log  When finished, publish to  MATRIX App Store  with  matrix publish  app-name", 
            "title": "Development Workflow"
        }, 
        {
            "location": "/matrix-os/overview/dashboard/", 
            "text": "Dashboard\n\n\nLogin to your \nMATRIX Dashboard\n.\n\n\nOne dashboard per application\n\n\nDashboards consist of widgets which are defined in a \nconfiguration file\n, \nconfig.yaml\n. Widgets provide readouts for data coming from a MATRIX application, or widgets can provide controls for users to modify how applications operate.\n\n\nWidgets\n\n\nWidgets are configured via \nconfig.yaml\n under the \nwidgets\n key.\nSee \nReference \n Widget Examples\n for more detailed information about widget configuration.\n\n\nLayout via \nscreens\n\n\nscreens\n and \nwidgets\n are both global entries in the \nconfig.yaml\n. \nscreens\n provides for a data-structure driven layout, where each row is a defined list of widgets. So if we have one array:\n\n\nscreens:\n  - leftWidget\n  - rightWidget\n\nwidgets:\n  leftWidget: ...\n  rightWidget: ...\n\n\n\n\nThe widgets will end up left 50% and right 50%. This way we can easily distinguish between layout and functionality.\n\n\nNesting Widgets\n\n\nYou can use nesting within the \nscreens\n data structure to further customize the layout. This example would produce two rows, the first with two panels, the second with three.\n\n\nscreens:\n  - - topLeft\n    - topRight\n  - - bottomLeft\n    - bottomCenter\n    - bottomRight\n\n\n\n\nDevices and Applications\n\n\nInside the dahsboard should be able to navigate to your active devices and applications. The dashboard for each application consists of widgets which display data from the selected devices.", 
            "title": "Dashboard"
        }, 
        {
            "location": "/matrix-os/overview/dashboard/#dashboard", 
            "text": "Login to your  MATRIX Dashboard .", 
            "title": "Dashboard"
        }, 
        {
            "location": "/matrix-os/overview/dashboard/#one-dashboard-per-application", 
            "text": "Dashboards consist of widgets which are defined in a  configuration file ,  config.yaml . Widgets provide readouts for data coming from a MATRIX application, or widgets can provide controls for users to modify how applications operate.", 
            "title": "One dashboard per application"
        }, 
        {
            "location": "/matrix-os/overview/dashboard/#widgets", 
            "text": "Widgets are configured via  config.yaml  under the  widgets  key.\nSee  Reference   Widget Examples  for more detailed information about widget configuration.", 
            "title": "Widgets"
        }, 
        {
            "location": "/matrix-os/overview/dashboard/#layout-via-screens", 
            "text": "screens  and  widgets  are both global entries in the  config.yaml .  screens  provides for a data-structure driven layout, where each row is a defined list of widgets. So if we have one array:  screens:\n  - leftWidget\n  - rightWidget\n\nwidgets:\n  leftWidget: ...\n  rightWidget: ...  The widgets will end up left 50% and right 50%. This way we can easily distinguish between layout and functionality.", 
            "title": "Layout via screens"
        }, 
        {
            "location": "/matrix-os/overview/dashboard/#nesting-widgets", 
            "text": "You can use nesting within the  screens  data structure to further customize the layout. This example would produce two rows, the first with two panels, the second with three.  screens:\n  - - topLeft\n    - topRight\n  - - bottomLeft\n    - bottomCenter\n    - bottomRight", 
            "title": "Nesting Widgets"
        }, 
        {
            "location": "/matrix-os/overview/dashboard/#devices-and-applications", 
            "text": "Inside the dahsboard should be able to navigate to your active devices and applications. The dashboard for each application consists of widgets which display data from the selected devices.", 
            "title": "Devices and Applications"
        }, 
        {
            "location": "/matrix-os/overview/configuration/", 
            "text": "Configuration\n\n\nEvery MOS application has a configuration file \nconfig.yaml\n.\n\n\nThis file:\n\n\n\n\nSets meta information for the application, which is used in the \nMATRIX App Store\n.\n\n\nDefines a schema for \nsending data\n from the device.\n\n\nIdentifies which \nsensors\n, \nservices\n, \nevents\n and \nintegrations\n an application utilizes.\n\n\nDefines dynamic \nsettings\n variables, which are available to the application and end-user modifiable.\n\n\nDefines the \nwidgets\n and their layout in the \ndashboard\n\n\nGenerates a policy on install, asking the user for specific access to their device.\n\n\n\n\nConfiguration Options\n\n\n\n\nname\n - Name of the application that appears as part of the application store when viewing it.\n\n\ndescription\n - Short description that appears as part of the application when deploying or pushing to App Store.\n\n\nkeywords\n - a few values about the application. ex: \nface, door, unlock\n\n\nversion\n - this field will be updated by the CLI on publish.\n\n\nconfigVersion\n - This field defines what version is the configuration. don't touch this. \n\n\nsettings\n - runtime variables for MOS applications\n\n\ndataTypes\n - schema for structured data from an application\n\n\nsensors\n - which sensors to activate for this application\n\n\nintegrations\n - which external integrations does this application support ie. \nifttt\n\n\nevents\n - which events this application has listeners for \n\n\nscreens\n - layout for widgets. see \nLayout\n\n\nwidgets\n - widget definitions. see \nWidgets\n\n\nservices\n - service definitions. see \nComputer Vision\n\n\n\n\nUsage Notes\n\n\nThe \nconfig.yaml\n is standardized before installation, which will modify it somewhat, especially in the widget definations. Do not be alarmed if your installed \nconfig.yaml\n does not match the original, this is normal.\n\n\nMore info\n\n\nSee the helper library with examples at: \nhttps://github.com/matrix-io/matrix-app-config-helper", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/overview/configuration/#configuration", 
            "text": "Every MOS application has a configuration file  config.yaml .  This file:   Sets meta information for the application, which is used in the  MATRIX App Store .  Defines a schema for  sending data  from the device.  Identifies which  sensors ,  services ,  events  and  integrations  an application utilizes.  Defines dynamic  settings  variables, which are available to the application and end-user modifiable.  Defines the  widgets  and their layout in the  dashboard  Generates a policy on install, asking the user for specific access to their device.", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/overview/configuration/#configuration-options", 
            "text": "name  - Name of the application that appears as part of the application store when viewing it.  description  - Short description that appears as part of the application when deploying or pushing to App Store.  keywords  - a few values about the application. ex:  face, door, unlock  version  - this field will be updated by the CLI on publish.  configVersion  - This field defines what version is the configuration. don't touch this.   settings  - runtime variables for MOS applications  dataTypes  - schema for structured data from an application  sensors  - which sensors to activate for this application  integrations  - which external integrations does this application support ie.  ifttt  events  - which events this application has listeners for   screens  - layout for widgets. see  Layout  widgets  - widget definitions. see  Widgets  services  - service definitions. see  Computer Vision", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/matrix-os/overview/configuration/#usage-notes", 
            "text": "The  config.yaml  is standardized before installation, which will modify it somewhat, especially in the widget definations. Do not be alarmed if your installed  config.yaml  does not match the original, this is normal.", 
            "title": "Usage Notes"
        }, 
        {
            "location": "/matrix-os/overview/configuration/#more-info", 
            "text": "See the helper library with examples at:  https://github.com/matrix-io/matrix-app-config-helper", 
            "title": "More info"
        }, 
        {
            "location": "/matrix-os/overview/cli/", 
            "text": "Command Line Interface (CLI)\n\n\n\n\nMATRIX CLI requires \nNode.js\n\n\n\n\nMATRIX devices can be managed via website, mobile phone applications or via CLI.\n\n\nInstallation\n\n\nInstall MATRIX CLI with \nnpm\n and you're good to go.\n\n\nnpm install -g matrix-cli\n\n\n\n\nLocal vs Device\n\n\nMATRIX CLI was designed to be used from your local machine, or can be installed to and used from your Raspberry Pi.\n\n\nRegistration\n\n\nUser registration\n\n\nIf you do not have an MATRIX Labs MATRIX account, use:\n\n\nmatrix register\n\n\n\n\nCheck your email to confirm the account then you can login.\n\n\nmatrix login\n\n\n\n\nManual device registration\n\n\nThis step can also be done via the MATRIX mobile application, which will automatically set the credentials.\n\n\nIn order to manually set up your device, use:\n\n\nmatrix register device\n\n\n\n\nFor more details about registering devices, see \nGetting Started \n Installation \n CLI Setup\n\n\nThis will ask for your device details and then provide you with an id and a secret, you need to set those ENV vars in your device so it can authenticate on boot. \n\n\nFor more information on running MATRIX OS manually, see \nMATRIX OS \n Overview \n Manual Setup\n.\n\n\nCommand list\n\n\nFor a list of all the available options, use:\n\n\nmatrix\n\n\n\n\nDevices\n\n\nHow to register, use, and see your MATRIX devices\n\n\nDevice Registration\n\n\nRegister a new device to your account\n\n\nmatrix register device\n\n\n\n\nList your Devices\n\n\nLists all registered devices on your account\n\n\nmatrix list devices\n\n\n\n\nUse a Specific Device\n\n\nTo use a specific device you can use either command below\n\n\nmatrix use \ndevice-id\n\nmatrix use \ndevice-name\n\n\n\n\n\nApplications\n\n\nSee \nMATRIX OS \n Overview \n Applications\n\n\nAll the application commands require an active device to be specified with \nmatrix use\n.\n\n\nInstall\n\n\nInstall an app from the store to MatrixOS\n\n\nmatrix install appName\n\n\n\n\nUninstall\n\n\nUninstall an app from your device\n\n\nmatrix uninstall appName\n\n\n\n\nCreate\n\n\nCreates a folder with a base matrix app template\n\n\nmatrix create appName\n\n\n\n\nSee \nMATRIX OS \n Overview \n Applications\n for more information about writing MATRIX OS applications.\n\n\nDeploy\n\n\nUploads app folder to MatrixOS\n\n\nmatrix deploy appName\n\n\n\n\nRun\n\n\nUsed to start an app\n\n\nmatrix start appName\n\n\n\n\nStop\n\n\nUsed to stop an app\n\n\nmatrix stop appName\n\n\n\n\nRestart\n\n\nUsed to restart an app\n\n\nmatrix restart appName", 
            "title": "Command Line"
        }, 
        {
            "location": "/matrix-os/overview/cli/#command-line-interface-cli", 
            "text": "MATRIX CLI requires  Node.js   MATRIX devices can be managed via website, mobile phone applications or via CLI.", 
            "title": "Command Line Interface (CLI)"
        }, 
        {
            "location": "/matrix-os/overview/cli/#installation", 
            "text": "Install MATRIX CLI with  npm  and you're good to go.  npm install -g matrix-cli", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-os/overview/cli/#local-vs-device", 
            "text": "MATRIX CLI was designed to be used from your local machine, or can be installed to and used from your Raspberry Pi.", 
            "title": "Local vs Device"
        }, 
        {
            "location": "/matrix-os/overview/cli/#registration", 
            "text": "", 
            "title": "Registration"
        }, 
        {
            "location": "/matrix-os/overview/cli/#user-registration", 
            "text": "If you do not have an MATRIX Labs MATRIX account, use:  matrix register  Check your email to confirm the account then you can login.  matrix login", 
            "title": "User registration"
        }, 
        {
            "location": "/matrix-os/overview/cli/#manual-device-registration", 
            "text": "This step can also be done via the MATRIX mobile application, which will automatically set the credentials.  In order to manually set up your device, use:  matrix register device  For more details about registering devices, see  Getting Started   Installation   CLI Setup  This will ask for your device details and then provide you with an id and a secret, you need to set those ENV vars in your device so it can authenticate on boot.   For more information on running MATRIX OS manually, see  MATRIX OS   Overview   Manual Setup .", 
            "title": "Manual device registration"
        }, 
        {
            "location": "/matrix-os/overview/cli/#command-list", 
            "text": "For a list of all the available options, use:  matrix", 
            "title": "Command list"
        }, 
        {
            "location": "/matrix-os/overview/cli/#devices", 
            "text": "How to register, use, and see your MATRIX devices", 
            "title": "Devices"
        }, 
        {
            "location": "/matrix-os/overview/cli/#device-registration", 
            "text": "Register a new device to your account  matrix register device", 
            "title": "Device Registration"
        }, 
        {
            "location": "/matrix-os/overview/cli/#list-your-devices", 
            "text": "Lists all registered devices on your account  matrix list devices", 
            "title": "List your Devices"
        }, 
        {
            "location": "/matrix-os/overview/cli/#use-a-specific-device", 
            "text": "To use a specific device you can use either command below  matrix use  device-id \nmatrix use  device-name", 
            "title": "Use a Specific Device"
        }, 
        {
            "location": "/matrix-os/overview/cli/#applications", 
            "text": "See  MATRIX OS   Overview   Applications  All the application commands require an active device to be specified with  matrix use .", 
            "title": "Applications"
        }, 
        {
            "location": "/matrix-os/overview/cli/#install", 
            "text": "Install an app from the store to MatrixOS  matrix install appName", 
            "title": "Install"
        }, 
        {
            "location": "/matrix-os/overview/cli/#uninstall", 
            "text": "Uninstall an app from your device  matrix uninstall appName", 
            "title": "Uninstall"
        }, 
        {
            "location": "/matrix-os/overview/cli/#create", 
            "text": "Creates a folder with a base matrix app template  matrix create appName  See  MATRIX OS   Overview   Applications  for more information about writing MATRIX OS applications.", 
            "title": "Create"
        }, 
        {
            "location": "/matrix-os/overview/cli/#deploy", 
            "text": "Uploads app folder to MatrixOS  matrix deploy appName", 
            "title": "Deploy"
        }, 
        {
            "location": "/matrix-os/overview/cli/#run", 
            "text": "Used to start an app  matrix start appName", 
            "title": "Run"
        }, 
        {
            "location": "/matrix-os/overview/cli/#stop", 
            "text": "Used to stop an app  matrix stop appName", 
            "title": "Stop"
        }, 
        {
            "location": "/matrix-os/overview/cli/#restart", 
            "text": "Used to restart an app  matrix restart appName", 
            "title": "Restart"
        }, 
        {
            "location": "/matrix-os/overview/data/", 
            "text": "Sending Data From MATRIX Devices\n\n\nMATRIX devices will only externally store data if it is explicitly sent via an application. If you want to use MATRIX Dashboard components to work with your data, it will need to be exported using the \nsend\n command.\n\n\nEnabling a MATRIX application to save information using \nsend\n requires a \nData Type\n to be configured.\n\n\n\n\nYou should have familiarity with \nConfiguration Files\n before exploring Data Types. \n\n\n\n\nData Types\n\n\nSimple applications can have a single, universal datatype, or a more complicated, keyed object. If you are familiar with database schemas, we have adopted a similiar approach.\n\n\nSingle Datatype\n\n\n# in app config.yaml \ndataTypes:\n  foo: string\n  bar: integer\n\n\n\n\nComplex Datatype\n\n\n# in config.yaml\ndataTypes:\n  foo:\n    foo1 : integer\n    fooA : string\n  bar:\n    bar1: integer\n    barA: string\n\n\n\n\nIn the above example \nfoo\n and \nbar\n are \nTypes\n available to extend the \nsend\n command, and to use with Widgets in the Dashboard.\n\n\nMigrations - IMPORTANT\n\n\nWe do not currently support changing dataTypes for newer versions of an application. If you need to change dataTypes after an application is published, please release a new application until we can address this issue.\n\n\nSend\n\n\nOnce a datatype is defined, you can save data and make it accessible in realtime via dashboard. \n\n\nSimple Send Example\n\n\n# config.yaml\ndataTypes:\n  foo: integer\n\n\n\n\n// app.js\nmatrix.send({\n  foo: 123\n})\n\n\n\n\nTypes\n\n\nTypes are a mechanism for segmenting the data coming off MatrixOS and make it available in end user applications, dashboards and reports.\n\n\nComplex Send Example\n\n\nmatrix.type('bar').send({\n  foo: 123\n})\n\n\n\n\n\nwould be utilized with the following widget\n\n\nname: fooApp\ndataTypes:\n  bar:\n    foo: integer\n\nwidgets:\n  fooWidget:\n    display: digit,\n    type: bar\n    key: foo", 
            "title": "Sending Data"
        }, 
        {
            "location": "/matrix-os/overview/data/#sending-data-from-matrix-devices", 
            "text": "MATRIX devices will only externally store data if it is explicitly sent via an application. If you want to use MATRIX Dashboard components to work with your data, it will need to be exported using the  send  command.  Enabling a MATRIX application to save information using  send  requires a  Data Type  to be configured.   You should have familiarity with  Configuration Files  before exploring Data Types.", 
            "title": "Sending Data From MATRIX Devices"
        }, 
        {
            "location": "/matrix-os/overview/data/#data-types", 
            "text": "Simple applications can have a single, universal datatype, or a more complicated, keyed object. If you are familiar with database schemas, we have adopted a similiar approach.", 
            "title": "Data Types"
        }, 
        {
            "location": "/matrix-os/overview/data/#single-datatype", 
            "text": "# in app config.yaml \ndataTypes:\n  foo: string\n  bar: integer", 
            "title": "Single Datatype"
        }, 
        {
            "location": "/matrix-os/overview/data/#complex-datatype", 
            "text": "# in config.yaml\ndataTypes:\n  foo:\n    foo1 : integer\n    fooA : string\n  bar:\n    bar1: integer\n    barA: string  In the above example  foo  and  bar  are  Types  available to extend the  send  command, and to use with Widgets in the Dashboard.", 
            "title": "Complex Datatype"
        }, 
        {
            "location": "/matrix-os/overview/data/#migrations-important", 
            "text": "We do not currently support changing dataTypes for newer versions of an application. If you need to change dataTypes after an application is published, please release a new application until we can address this issue.", 
            "title": "Migrations - IMPORTANT"
        }, 
        {
            "location": "/matrix-os/overview/data/#send", 
            "text": "Once a datatype is defined, you can save data and make it accessible in realtime via dashboard.", 
            "title": "Send"
        }, 
        {
            "location": "/matrix-os/overview/data/#simple-send-example", 
            "text": "# config.yaml\ndataTypes:\n  foo: integer  // app.js\nmatrix.send({\n  foo: 123\n})", 
            "title": "Simple Send Example"
        }, 
        {
            "location": "/matrix-os/overview/data/#types", 
            "text": "Types are a mechanism for segmenting the data coming off MatrixOS and make it available in end user applications, dashboards and reports.", 
            "title": "Types"
        }, 
        {
            "location": "/matrix-os/overview/data/#complex-send-example", 
            "text": "matrix.type('bar').send({\n  foo: 123\n})  would be utilized with the following widget  name: fooApp\ndataTypes:\n  bar:\n    foo: integer\n\nwidgets:\n  fooWidget:\n    display: digit,\n    type: bar\n    key: foo", 
            "title": "Complex Send Example"
        }, 
        {
            "location": "/matrix-os/overview/publishing/", 
            "text": "Publishing your Application\n\n\nApp Store\n\n\nhttp://apps.matrix.one\n\n\nThree Steps to Distribution\n\n\n\n\nmatrix create\n - Make your application\n\n\nmatrix deploy\n - Test your application\n\n\nmatrix publish\n - Publish on the app Store\n\n\n\n\nGuidelines\n\n\nYour application must do only what it claims to do with the name, description and README.md.\n\n\nAll sensors, integrations and computer vision usage must be registered in the \nconfig.yaml\n, and will be authorized by users on install.\n\n\nAll applications will be code reviewed and are subject to removal at any time.\n\n\nBefore publishing an application.\n\n\nEnsure Meta Information is Accurate\n\n\nname\n and \ndescription\n must be included in your config.yaml. If you want to use a multiword application name, provide a \ndisplayName\n with a correlating \nname\n. Users will use \nname\n when \nmatrix install\ning.\n\n\nThe contents of \nREADME.md\n will be shown on the app detail page, along with images provided\n\nimageUrls\n will be used on the detail page\n\n\ngalleryUrl\n will be used on the main App Store page, or the first item in \nimageUrls\n will be used\n\n\nkeywords\n are used to tag your application and will be used to return your application on searches for these keywords.\n\n\ncategories\n are not yet formalized, but will divide the store listings. Submitting proposed app categories will inform this process.\n\n\nexample config.yaml\n\nname: example-app\ndisplayName: The Example App\ndescription: An example application config.yaml.\n\nimageUrls:\n  - http://image.com/1\n  - http://image.com/2\n\ngalleryUrl: http://image.com/3\n\nkeywords:\n  - example\n  - configuration\n\ncategories:\n  - entertainment\n  - development\n\n\n\n\nEnsure Components are Setup\n\n\nAll applications which use events, CV or sensors, must register these in the config file.\n\n\nevents\n are registered as follows:\n\n\nEvents\n\n\nevents:\n  - face-recognized\n  - locked-door\n\n\n\n\nSensors\n\n\nsensors:\n  - temperature\n  - uv\n\n\n\n\nComputer Vision\n\n\nservices:\n  faceService:\n    engine: detection\n    type: face\n\n\n\n\nA user will be required to grant an application permissions before installing. A user may install an app with any or all permissions enabled.\n\n\nTest your Application\n\n\nUse \nmatrix deploy\n to test your application before publishing. Make sure it functions as intended. Share a video of your creation with us!", 
            "title": "Publishing"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#publishing-your-application", 
            "text": "", 
            "title": "Publishing your Application"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#app-store", 
            "text": "http://apps.matrix.one", 
            "title": "App Store"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#three-steps-to-distribution", 
            "text": "matrix create  - Make your application  matrix deploy  - Test your application  matrix publish  - Publish on the app Store", 
            "title": "Three Steps to Distribution"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#guidelines", 
            "text": "Your application must do only what it claims to do with the name, description and README.md.  All sensors, integrations and computer vision usage must be registered in the  config.yaml , and will be authorized by users on install.  All applications will be code reviewed and are subject to removal at any time.", 
            "title": "Guidelines"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#before-publishing-an-application", 
            "text": "", 
            "title": "Before publishing an application."
        }, 
        {
            "location": "/matrix-os/overview/publishing/#ensure-meta-information-is-accurate", 
            "text": "name  and  description  must be included in your config.yaml. If you want to use a multiword application name, provide a  displayName  with a correlating  name . Users will use  name  when  matrix install ing.  The contents of  README.md  will be shown on the app detail page, along with images provided imageUrls  will be used on the detail page  galleryUrl  will be used on the main App Store page, or the first item in  imageUrls  will be used  keywords  are used to tag your application and will be used to return your application on searches for these keywords.  categories  are not yet formalized, but will divide the store listings. Submitting proposed app categories will inform this process.  example config.yaml\n\nname: example-app\ndisplayName: The Example App\ndescription: An example application config.yaml.\n\nimageUrls:\n  - http://image.com/1\n  - http://image.com/2\n\ngalleryUrl: http://image.com/3\n\nkeywords:\n  - example\n  - configuration\n\ncategories:\n  - entertainment\n  - development", 
            "title": "Ensure Meta Information is Accurate"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#ensure-components-are-setup", 
            "text": "All applications which use events, CV or sensors, must register these in the config file.  events  are registered as follows:", 
            "title": "Ensure Components are Setup"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#events", 
            "text": "events:\n  - face-recognized\n  - locked-door", 
            "title": "Events"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#sensors", 
            "text": "sensors:\n  - temperature\n  - uv", 
            "title": "Sensors"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#computer-vision", 
            "text": "services:\n  faceService:\n    engine: detection\n    type: face  A user will be required to grant an application permissions before installing. A user may install an app with any or all permissions enabled.", 
            "title": "Computer Vision"
        }, 
        {
            "location": "/matrix-os/overview/publishing/#test-your-application", 
            "text": "Use  matrix deploy  to test your application before publishing. Make sure it functions as intended. Share a video of your creation with us!", 
            "title": "Test your Application"
        }, 
        {
            "location": "/matrix-os/overview/manual-setup/", 
            "text": "Manual Start\n\n\nMOS is a managed environment for running IoT applications. If you want more control and information, you can run MOS manually. \n\n\nHeadless Access\n\n\nEnable SSH Access\n\n\nThe latest version of Raspbian enables SSH via the presence of a \nSSH\n file in the \n/boot\n partition. Add this file, then you can access your Pi via \nssh pi@IP.ADD.RES.S\n. \n\n\nFind your Pi IP\n\n\nRun to output the IP address for any Pi's on your local network.\n\n\narp -a | grep b8:27:eb\n\n\n\n\nDevice Boot Behavior\n\n\nMATRIX OS uses \nsystemd\n to automatically start on boot. If you want more control over when MATRIX OS starts or stops, you will need to login to your device, and run MOS directly.\n\n\nYou can disable/enable MOS starting on boot with the following.\n\n\n# don't start on boot\nsudo systemctl disable matrix-os\n# start on boot\nsudo systemctl enable matrix-os\n\n\n\n\nFind \n Start MATRIX OS\n\n\nIf you didn't \ninstall\n, MOS execution is managed by \nsystemd\n and is located at \n/usr/share/admobilize/matrix-os\n\n\npi@raspberrypi:~ $ cd /usr/share/admobilize/matrix-os\nnode index.js\n\n\n\n\nLaunch Options\n\n\nSTART_APP\n - start this application after launch is finished\n\n\nNODE_ENV\n - set to \ndev\n to point at dev environments, default \nproduction\n\n\nDEBUG\n - set to \n*\n to see all messages, be careful when posting these publicly because they contain secrets\n\n\nMATRIX_DEVICE_ID\n - id from the cli device registration\n\n\nMATRIX_DEVICE_SECRET\n - secret from the cli device registration\n\n\nSUN_MODE\n - set to true to enable the white LEDs and luminance calculations. Such brightness.\n\n\nYou can save any of these as environment variables to \n~/.bash_profile\n and they will be automatically available when you ssh in. To add these to a MOS which is launched on device boot, you will have to add an \nEnvironment=\n line to \n/lib/systemd/system/matrix-os.service\n for each launch option you want to enable.\n\n\nHeed warning\n\n\nApplications need to be registered with the platform before they will run successfully inside MOS. After the initial installation or deployment of an application, you can make changes directly on the device, or work locally and \nscp\n changes. Of course, it is often much easier to just \nmatrix deploy\n.", 
            "title": "Manual Start"
        }, 
        {
            "location": "/matrix-os/overview/manual-setup/#manual-start", 
            "text": "MOS is a managed environment for running IoT applications. If you want more control and information, you can run MOS manually.", 
            "title": "Manual Start"
        }, 
        {
            "location": "/matrix-os/overview/manual-setup/#headless-access", 
            "text": "", 
            "title": "Headless Access"
        }, 
        {
            "location": "/matrix-os/overview/manual-setup/#enable-ssh-access", 
            "text": "The latest version of Raspbian enables SSH via the presence of a  SSH  file in the  /boot  partition. Add this file, then you can access your Pi via  ssh pi@IP.ADD.RES.S .", 
            "title": "Enable SSH Access"
        }, 
        {
            "location": "/matrix-os/overview/manual-setup/#find-your-pi-ip", 
            "text": "Run to output the IP address for any Pi's on your local network.  arp -a | grep b8:27:eb", 
            "title": "Find your Pi IP"
        }, 
        {
            "location": "/matrix-os/overview/manual-setup/#device-boot-behavior", 
            "text": "MATRIX OS uses  systemd  to automatically start on boot. If you want more control over when MATRIX OS starts or stops, you will need to login to your device, and run MOS directly.  You can disable/enable MOS starting on boot with the following.  # don't start on boot\nsudo systemctl disable matrix-os\n# start on boot\nsudo systemctl enable matrix-os", 
            "title": "Device Boot Behavior"
        }, 
        {
            "location": "/matrix-os/overview/manual-setup/#find-start-matrix-os", 
            "text": "If you didn't  install , MOS execution is managed by  systemd  and is located at  /usr/share/admobilize/matrix-os  pi@raspberrypi:~ $ cd /usr/share/admobilize/matrix-os\nnode index.js", 
            "title": "Find &amp; Start MATRIX OS"
        }, 
        {
            "location": "/matrix-os/overview/manual-setup/#launch-options", 
            "text": "START_APP  - start this application after launch is finished  NODE_ENV  - set to  dev  to point at dev environments, default  production  DEBUG  - set to  *  to see all messages, be careful when posting these publicly because they contain secrets  MATRIX_DEVICE_ID  - id from the cli device registration  MATRIX_DEVICE_SECRET  - secret from the cli device registration  SUN_MODE  - set to true to enable the white LEDs and luminance calculations. Such brightness.  You can save any of these as environment variables to  ~/.bash_profile  and they will be automatically available when you ssh in. To add these to a MOS which is launched on device boot, you will have to add an  Environment=  line to  /lib/systemd/system/matrix-os.service  for each launch option you want to enable.", 
            "title": "Launch Options"
        }, 
        {
            "location": "/matrix-os/overview/manual-setup/#heed-warning", 
            "text": "Applications need to be registered with the platform before they will run successfully inside MOS. After the initial installation or deployment of an application, you can make changes directly on the device, or work locally and  scp  changes. Of course, it is often much easier to just  matrix deploy .", 
            "title": "Heed warning"
        }, 
        {
            "location": "/matrix-os/examples/", 
            "text": "Examples\n\n\nApp Creation\n\n\n\n\nVery basics of app creation, deployment and starting. - [\nExample\n] \n\n\n\n\nSensor Test\n\n\n\n\nThe basics of connecting to sensors and using the LED. - [\nExample\n] \n\n\n\n\nIFTTT Integration\n\n\n\n\nIntegrate with the online universe via IFTTT. - [\nExample\n]\n\n\n\n\nDashboards\n\n\n\n\nMake amazing data-driven dashboards. - \n[Example]\n]", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-os/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-os/examples/#app-creation", 
            "text": "Very basics of app creation, deployment and starting. - [ Example ]", 
            "title": "App Creation"
        }, 
        {
            "location": "/matrix-os/examples/#sensor-test", 
            "text": "The basics of connecting to sensors and using the LED. - [ Example ]", 
            "title": "Sensor Test"
        }, 
        {
            "location": "/matrix-os/examples/#ifttt-integration", 
            "text": "Integrate with the online universe via IFTTT. - [ Example ]", 
            "title": "IFTTT Integration"
        }, 
        {
            "location": "/matrix-os/examples/#dashboards", 
            "text": "Make amazing data-driven dashboards. -  [Example] ]", 
            "title": "Dashboards"
        }, 
        {
            "location": "/matrix-os/examples/app-create/", 
            "text": "Creating, deploying and running applications\n\n\n\n\nYou must have installed the \nCLI\n and have a registered MATRIX device for this example.\n\n\n\n\n$ matrix create testApp\n$ cd testApp\n$ vi app.js\n\n\n\n\nEnter this to \napp.js\n. It will flash the LED green for 5 seconds.\n\n\nmatrix.led('green').render();\n\nsetTimeout(() =\n {\n  matrix.led('black').render();\n}, 5000)\n\n\n\n\nDeploy\n\n\nDeploy the application to your MATRIX device\n\n\n# if you don't know your device id\n$ matrix list devices\n\n# select from above list\n$ matrix use {deviceId}\n\n# from still inside the testApp directory\n$ matrix deploy testApp\n\n# run the MOS application\n$ matrix start testApp\n\n\n\n\nThat's it! The light should flash green.\n\n\n# stop the MOS application (optional)\n$ matrix stop testApp", 
            "title": "Create an App"
        }, 
        {
            "location": "/matrix-os/examples/app-create/#creating-deploying-and-running-applications", 
            "text": "You must have installed the  CLI  and have a registered MATRIX device for this example.   $ matrix create testApp\n$ cd testApp\n$ vi app.js  Enter this to  app.js . It will flash the LED green for 5 seconds.  matrix.led('green').render();\n\nsetTimeout(() =  {\n  matrix.led('black').render();\n}, 5000)", 
            "title": "Creating, deploying and running applications"
        }, 
        {
            "location": "/matrix-os/examples/app-create/#deploy", 
            "text": "Deploy the application to your MATRIX device  # if you don't know your device id\n$ matrix list devices\n\n# select from above list\n$ matrix use {deviceId}\n\n# from still inside the testApp directory\n$ matrix deploy testApp\n\n# run the MOS application\n$ matrix start testApp  That's it! The light should flash green.  # stop the MOS application (optional)\n$ matrix stop testApp", 
            "title": "Deploy"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/", 
            "text": "Creating a Dashboard\n\n\nIn this example we will make this simple dashboard.\n\n\n\n\n\n\nBefore attempting this example, you should have \nCLI\n installed and are familiar with \napplication \ncreate\n and \ndeploy\n and \ndata types\n.\n\n\nFor more details about what is covered in this example, please read about \nwidgets\n and \nsensors\n\n\n\n\nDashboards serve two primary purposes:\n\n\n\n\nPresenting data patterns over time.\n\n\nCommunicating with applications.\n\n\n\n\nMake application\n\n\n$ matrix create ezDash\n# enter details\n$ cd ezDash\n\n\n\n\nConfigure application\n\n\nSend data\n\n\nData is sent and sorted via it's structure which is defined in \ndataTypes\n. In this example \nmotd\n is the \ntype\n of data which is parsed for a given key \nmsg\n in the dashboard.\n\n\ndataTypes:\n  motd:\n    msg: string\n\n\n\n\nWidget Definition\n\n\nDefine a widget named \nmessage\n that holds options defining which data to display.\n\n\nwidgets: \n  message: \n    display: label\n    type: motd\n    key: msg\n    label: from device\n\n\n\n\nAdd to layout\n\n\nmessage\n is the widget name to add to the \nscreens\n layout definition.\n\n\nscreens:\n  - - message\n\n\n\n\nFinal Configuration File\n\n\n# config.yaml\n\ndataTypes:\n  motd:\n    msg: string\n\nwidgets: \n  message: \n    display: label\n    type: motd\n    key: msg\n    label: from device\n\nscreens:\n  - - message\n\n\n\n\nApplication to send a Basic Message\n\n\nHere, we use the dataType \nmotd\n, and send an object with a \nmsg\n key to display in the dashboard.\n\n\n// app.js\nmatrix.type('motd').send({msg: 'hello to dashboard'});\n\n\n\n\nOpen the Dashboard\n\n\nGoto \nMATRIX Dashboard\n\n\nStarting the App\n\n\nDashboard display real time information. If you open an application, it will not show data until you either query historical information or a device application sends information.\n\n\nCharting Realtime Data\n\n\nAdding a \ndisplay\n widget and a \nmonitor\n data type, the dashboard can begin to show information over time.\n\n\nConfiguration Additions\n\n\n# config.yaml\ndataTypes:\n  motd:\n    msg: string\n  monitor: # new data type\n    cpu: float\n    mem: integer\n\nscreens:\n  - - message\n  - - graph # new screen\n\nwidgets:\n  message:\n    display: label\n    type: motd\n    key: msg\n    label: from device \n  graph: # new widget\n    display: line\n    type: monitor\n    keys: cpu, mem\n    label: Device Status\n\n\n\n\nCode for chart widget\n\n\nThe following will send \ncpu\n and \nmem\n information to the \ngraph\n widget to be charted.\n\n\n// app.js\nconst os = require('os');\n\nsetInterval(function(){\n  matrix.type('monitor').send({ cpu: os.loadavg()[0], mem: os.freemem() })\n}, 1000);\n\n\n\n\nControls\n\n\nAdding interactivity through \ncontrol\n widgets is how end users can interface directly with devices in real time. \n\n\n# config.yaml\nscreens:\n  - - message\n  - - graph\n  - - interface # new screen\n\nwidgets:\n  message:\n    display: label\n    type: motd\n    key: msg\n    label: from device\n  graph:\n    display: line\n    type: monitor\n    keys: cpu, mem\n    label: Device Status\n  interface: # new widget\n    control: button\n    event: increasePower\n    value: + CPU\n    label: Device Control\n\n\n\n\nMore Controls\n\n\n# config.yaml\n  interface:\n    control: button\n    map:  \n      - event: increasePower\n        value: + CPU\n      - event: decreasePower\n        value: - CPU\n    label: Device Control\n\n\n\n\nScript For New Controls\n\n\nconst os = require('os');\n\nlet cpuOffset = 0;\nsetInterval(function(){\n  matrix.type('monitor').send({ cpu: os.loadavg()[0] + cpuOffset, mem: os.freemem() })\n}, 1000);\n\n\nmatrix.on('increasePower', () =\n {\n  cpuOffset++;\n})\n\nmatrix.on('decreasePower', () =\n {\n  cpuOffset--;\n})\n\n\n\n\nDeploy \n Start\n\n\nMake sure your registered MATRIX device is on, connected, and you have selected the proper device with \nmatrix use\n\n\n# from /ezDash will upload code to device\n$ matrix deploy\n$ matrix start exDash\n\n# subsequent deploys shouldn't need start, will automagically restart if deployed while active\n$ matrix deploy\n\n\n\n\nUsage Note\n\n\nIf you visit the dashboard after starting the application, you will see the real time data, but not the message. Why? MOS applications are event based, and the message is sent on start. If the \nsend\n for the message was placed inside the \nsetInterval\n then it would show.", 
            "title": "Basic Dashboard"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#creating-a-dashboard", 
            "text": "In this example we will make this simple dashboard.    Before attempting this example, you should have  CLI  installed and are familiar with  application  create  and  deploy  and  data types .  For more details about what is covered in this example, please read about  widgets  and  sensors   Dashboards serve two primary purposes:   Presenting data patterns over time.  Communicating with applications.", 
            "title": "Creating a Dashboard"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#make-application", 
            "text": "$ matrix create ezDash\n# enter details\n$ cd ezDash", 
            "title": "Make application"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#configure-application", 
            "text": "", 
            "title": "Configure application"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#send-data", 
            "text": "Data is sent and sorted via it's structure which is defined in  dataTypes . In this example  motd  is the  type  of data which is parsed for a given key  msg  in the dashboard.  dataTypes:\n  motd:\n    msg: string", 
            "title": "Send data"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#widget-definition", 
            "text": "Define a widget named  message  that holds options defining which data to display.  widgets: \n  message: \n    display: label\n    type: motd\n    key: msg\n    label: from device", 
            "title": "Widget Definition"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#add-to-layout", 
            "text": "message  is the widget name to add to the  screens  layout definition.  screens:\n  - - message", 
            "title": "Add to layout"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#final-configuration-file", 
            "text": "# config.yaml\n\ndataTypes:\n  motd:\n    msg: string\n\nwidgets: \n  message: \n    display: label\n    type: motd\n    key: msg\n    label: from device\n\nscreens:\n  - - message", 
            "title": "Final Configuration File"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#application-to-send-a-basic-message", 
            "text": "Here, we use the dataType  motd , and send an object with a  msg  key to display in the dashboard.  // app.js\nmatrix.type('motd').send({msg: 'hello to dashboard'});", 
            "title": "Application to send a Basic Message"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#open-the-dashboard", 
            "text": "Goto  MATRIX Dashboard", 
            "title": "Open the Dashboard"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#starting-the-app", 
            "text": "Dashboard display real time information. If you open an application, it will not show data until you either query historical information or a device application sends information.", 
            "title": "Starting the App"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#charting-realtime-data", 
            "text": "Adding a  display  widget and a  monitor  data type, the dashboard can begin to show information over time.", 
            "title": "Charting Realtime Data"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#configuration-additions", 
            "text": "# config.yaml\ndataTypes:\n  motd:\n    msg: string\n  monitor: # new data type\n    cpu: float\n    mem: integer\n\nscreens:\n  - - message\n  - - graph # new screen\n\nwidgets:\n  message:\n    display: label\n    type: motd\n    key: msg\n    label: from device \n  graph: # new widget\n    display: line\n    type: monitor\n    keys: cpu, mem\n    label: Device Status", 
            "title": "Configuration Additions"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#code-for-chart-widget", 
            "text": "The following will send  cpu  and  mem  information to the  graph  widget to be charted.  // app.js\nconst os = require('os');\n\nsetInterval(function(){\n  matrix.type('monitor').send({ cpu: os.loadavg()[0], mem: os.freemem() })\n}, 1000);", 
            "title": "Code for chart widget"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#controls", 
            "text": "Adding interactivity through  control  widgets is how end users can interface directly with devices in real time.   # config.yaml\nscreens:\n  - - message\n  - - graph\n  - - interface # new screen\n\nwidgets:\n  message:\n    display: label\n    type: motd\n    key: msg\n    label: from device\n  graph:\n    display: line\n    type: monitor\n    keys: cpu, mem\n    label: Device Status\n  interface: # new widget\n    control: button\n    event: increasePower\n    value: + CPU\n    label: Device Control", 
            "title": "Controls"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#more-controls", 
            "text": "# config.yaml\n  interface:\n    control: button\n    map:  \n      - event: increasePower\n        value: + CPU\n      - event: decreasePower\n        value: - CPU\n    label: Device Control", 
            "title": "More Controls"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#script-for-new-controls", 
            "text": "const os = require('os');\n\nlet cpuOffset = 0;\nsetInterval(function(){\n  matrix.type('monitor').send({ cpu: os.loadavg()[0] + cpuOffset, mem: os.freemem() })\n}, 1000);\n\n\nmatrix.on('increasePower', () =  {\n  cpuOffset++;\n})\n\nmatrix.on('decreasePower', () =  {\n  cpuOffset--;\n})", 
            "title": "Script For New Controls"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#deploy-start", 
            "text": "Make sure your registered MATRIX device is on, connected, and you have selected the proper device with  matrix use  # from /ezDash will upload code to device\n$ matrix deploy\n$ matrix start exDash\n\n# subsequent deploys shouldn't need start, will automagically restart if deployed while active\n$ matrix deploy", 
            "title": "Deploy &amp; Start"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#usage-note", 
            "text": "If you visit the dashboard after starting the application, you will see the real time data, but not the message. Why? MOS applications are event based, and the message is sent on start. If the  send  for the message was placed inside the  setInterval  then it would show.", 
            "title": "Usage Note"
        }, 
        {
            "location": "/matrix-os/examples/sensor-test/", 
            "text": "Test your Sensors\n\n\n\n\nYou need a \nregistered\n MATRIX device with \nCLI\n installed\n\n\n\n\nIn \nHello World\n, we installed an application which shines lights if a sensor is working properly. Here, we will build that application.\n\n\nCreate New Application\n\n\nFirst, create the application and visit the directory:\n\n\n$ matrix create mySensorTest\n# app folder is made\n$ cd mySensorTest\n\n\n\n\nEdit Configuration\n\n\nEdit \nconfig.yaml\n to add the sensors. This step is necessary to authorize the application to access the sensors.\n\n\nsensors:\n  - temperature\n  - pressure\n  - humidity\n  - uv\n  - altitude\n  - gyroscope\n  - magnetometer\n  - accelerometer\n\n\n\n\nEdit Application\n\n\nEdit \napp.js\n. This is an example of an implementation for one sensor, \ntemperature\n. You will have to repeat the code for every sensor, and adjust the LED \nangle\n option accordingly.\n\n\nmatrix.sensor('temperature', function(data){\n  matrix.led({\n    angle: 0,\n    color: 'blue'\n  }).render();\n});\n\n\n\n\nSave your work.\n\n\nDeploy\n\n\nAfter you have finished, return to the command prompt and \ndeploy\n. You will have to select a device with \nmatrix use\n before running this command.\n\n\n# inside mySensorTest folder\n$ matrix deploy\n\n\n\n\nIn a moment, the application will be uploaded to your device. Now start your deployed application.\n\n\nStart\n\n\n$ matrix start mySensorTest", 
            "title": "Sensor Tests"
        }, 
        {
            "location": "/matrix-os/examples/sensor-test/#test-your-sensors", 
            "text": "You need a  registered  MATRIX device with  CLI  installed   In  Hello World , we installed an application which shines lights if a sensor is working properly. Here, we will build that application.", 
            "title": "Test your Sensors"
        }, 
        {
            "location": "/matrix-os/examples/sensor-test/#create-new-application", 
            "text": "First, create the application and visit the directory:  $ matrix create mySensorTest\n# app folder is made\n$ cd mySensorTest", 
            "title": "Create New Application"
        }, 
        {
            "location": "/matrix-os/examples/sensor-test/#edit-configuration", 
            "text": "Edit  config.yaml  to add the sensors. This step is necessary to authorize the application to access the sensors.  sensors:\n  - temperature\n  - pressure\n  - humidity\n  - uv\n  - altitude\n  - gyroscope\n  - magnetometer\n  - accelerometer", 
            "title": "Edit Configuration"
        }, 
        {
            "location": "/matrix-os/examples/sensor-test/#edit-application", 
            "text": "Edit  app.js . This is an example of an implementation for one sensor,  temperature . You will have to repeat the code for every sensor, and adjust the LED  angle  option accordingly.  matrix.sensor('temperature', function(data){\n  matrix.led({\n    angle: 0,\n    color: 'blue'\n  }).render();\n});  Save your work.", 
            "title": "Edit Application"
        }, 
        {
            "location": "/matrix-os/examples/sensor-test/#deploy", 
            "text": "After you have finished, return to the command prompt and  deploy . You will have to select a device with  matrix use  before running this command.  # inside mySensorTest folder\n$ matrix deploy  In a moment, the application will be uploaded to your device. Now start your deployed application.", 
            "title": "Deploy"
        }, 
        {
            "location": "/matrix-os/examples/sensor-test/#start", 
            "text": "$ matrix start mySensorTest", 
            "title": "Start"
        }, 
        {
            "location": "/matrix-os/examples/ifttt/", 
            "text": "IFTTT Integration\n\n\nHere we will demonstrate a simple IFTTT integration to alert you to weather outside.\n\n\n\n\nYou should know the basics of application creation and deployment. See \nApplication Workflow Example\n for more information.\n\n\n\n\nIFTTT Setup\n\n\nFirst, get an account at \nhttp://ifttt.com\n.\n\n\n\n\nClick on the profile menu on the right and select \nNew Applet\n and click on \nthis\n\n\n\n\n\n\n\n\nSelect the Weather Underground Icon\n\n\n\n\n\n\n\n\nSelect \nCurrent Condition Changes To\n\n\n\n\n\n\n\n\nSelect Rain from the Dropdown\n\n\n\n\n\n\n\n\nSelect \nthat\n\n\n\n\n\n\n\n\nType in and select \nmatrix-io\n\n\n\n\n\n\n\n\nConnect with matrix-os\n\n\n\n\n\n\n\n\nLogin with your MATRIX Credentials\n\n\n\n\n\n\n\n\nAllow IFTTT access to your MATRIX account\n\n\n\n\n \n\n\n\n\nChoose \nSend a MATRIX Event\n action\n\n\n\n\n\n\n\n\nFill out details for your event. We are selecting to use an event named \nweather-change\n and passing the \nCondition\n (which should be \"Rain\").\n\n\n\n\n\n\n\n\nFinish making your applet.\n\n\n\n\n\n\nMOS Application Code\n\n\n\n\nCreate the application\n\n\n\n\n$ matrix create rain-oracle\n$ cd rain-oracle\n\n# first we setup the config\n$ vi config.yaml\n\n\n\n\n\n\nAdd to the \nconfig.yaml\n\n\n\n\nintegrations:\n  - ifttt\n\nevents: \n  - weather-change\n\n\n\n\n\n\nCreate \napp.js\n\n\n\n\nmatrix.on('weather-change', (condition) =\n {\n  if ( condition === 'Rain'){\n    matrix.led('blue').render();  \n  }\n})\n\n\n\n\n\n\nDeploy to device and start (ensure device is selected with \nmatrix use\n)\n\n\n\n\n$ matrix deploy\n\n# start application\n$ matrix start rain-oracle", 
            "title": "IFTTT Integration"
        }, 
        {
            "location": "/matrix-os/examples/ifttt/#ifttt-integration", 
            "text": "Here we will demonstrate a simple IFTTT integration to alert you to weather outside.   You should know the basics of application creation and deployment. See  Application Workflow Example  for more information.", 
            "title": "IFTTT Integration"
        }, 
        {
            "location": "/matrix-os/examples/ifttt/#ifttt-setup", 
            "text": "First, get an account at  http://ifttt.com .   Click on the profile menu on the right and select  New Applet  and click on  this     Select the Weather Underground Icon     Select  Current Condition Changes To     Select Rain from the Dropdown     Select  that     Type in and select  matrix-io     Connect with matrix-os     Login with your MATRIX Credentials     Allow IFTTT access to your MATRIX account       Choose  Send a MATRIX Event  action     Fill out details for your event. We are selecting to use an event named  weather-change  and passing the  Condition  (which should be \"Rain\").     Finish making your applet.", 
            "title": "IFTTT Setup"
        }, 
        {
            "location": "/matrix-os/examples/ifttt/#mos-application-code", 
            "text": "Create the application   $ matrix create rain-oracle\n$ cd rain-oracle\n\n# first we setup the config\n$ vi config.yaml   Add to the  config.yaml   integrations:\n  - ifttt\n\nevents: \n  - weather-change   Create  app.js   matrix.on('weather-change', (condition) =  {\n  if ( condition === 'Rain'){\n    matrix.led('blue').render();  \n  }\n})   Deploy to device and start (ensure device is selected with  matrix use )   $ matrix deploy\n\n# start application\n$ matrix start rain-oracle", 
            "title": "MOS Application Code"
        }, 
        {
            "location": "/matrix-os/reference/", 
            "text": "MATRIX OS SDK\n\n\nSensors\n\n\nSensor interfaces and data structures.\n\n\nEverloop\n\n\nEverloop interface.\n\n\nFilters\n\n\nFiltering data\n\n\nComputer Vision\n\n\nComputer Vision services.\n\n\nMicrophones\n\n\nMicrophone Services.\n\n\nIR TX/RX\n\n\nIR receiving and transmitter services.\n\n\nGPIO\n\n\nGPIO interfaces.\n\n\nServos\n\n\nServo interfaces.\n\n\nZigbee\n\n\nZigbee interfaces.\n\n\nConfiguration\n\n\nSettings\n\n\nFor application defaults or end-user configurable variables.\n\n\nData Types\n\n\nData structures and how to save to the infrastructure.\n\n\nScreens\n\n\nDashboard creation and how to structure your widgets.\n\n\nFilters\n\n\nDashboard filter configuration.\n\n\nWidgets\n\n\nDashboard widget configuration.\n\n\nComputer Vision Services\n\n\nAvailable infrastructure services.\n\n\nTroubleshooting\n\n\nTroubleshooting", 
            "title": "Reference"
        }, 
        {
            "location": "/matrix-os/reference/#matrix-os-sdk", 
            "text": "", 
            "title": "MATRIX OS SDK"
        }, 
        {
            "location": "/matrix-os/reference/#sensors", 
            "text": "Sensor interfaces and data structures.", 
            "title": "Sensors"
        }, 
        {
            "location": "/matrix-os/reference/#everloop", 
            "text": "Everloop interface.", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-os/reference/#filters", 
            "text": "Filtering data", 
            "title": "Filters"
        }, 
        {
            "location": "/matrix-os/reference/#computer-vision", 
            "text": "Computer Vision services.", 
            "title": "Computer Vision"
        }, 
        {
            "location": "/matrix-os/reference/#microphones", 
            "text": "Microphone Services.", 
            "title": "Microphones"
        }, 
        {
            "location": "/matrix-os/reference/#ir-txrx", 
            "text": "IR receiving and transmitter services.", 
            "title": "IR TX/RX"
        }, 
        {
            "location": "/matrix-os/reference/#gpio", 
            "text": "GPIO interfaces.", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-os/reference/#servos", 
            "text": "Servo interfaces.", 
            "title": "Servos"
        }, 
        {
            "location": "/matrix-os/reference/#zigbee", 
            "text": "Zigbee interfaces.", 
            "title": "Zigbee"
        }, 
        {
            "location": "/matrix-os/reference/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/#settings", 
            "text": "For application defaults or end-user configurable variables.", 
            "title": "Settings"
        }, 
        {
            "location": "/matrix-os/reference/#data-types", 
            "text": "Data structures and how to save to the infrastructure.", 
            "title": "Data Types"
        }, 
        {
            "location": "/matrix-os/reference/#screens", 
            "text": "Dashboard creation and how to structure your widgets.", 
            "title": "Screens"
        }, 
        {
            "location": "/matrix-os/reference/#filters_1", 
            "text": "Dashboard filter configuration.", 
            "title": "Filters"
        }, 
        {
            "location": "/matrix-os/reference/#widgets", 
            "text": "Dashboard widget configuration.", 
            "title": "Widgets"
        }, 
        {
            "location": "/matrix-os/reference/#computer-vision-services", 
            "text": "Available infrastructure services.", 
            "title": "Computer Vision Services"
        }, 
        {
            "location": "/matrix-os/reference/#troubleshooting", 
            "text": "Troubleshooting", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-os/reference/system/", 
            "text": "System Methods\n\n\nSeveral methods are available for common computing use cases, like application instance settings, storing files or persistant data lookups. These will be localized to the device and are not available across all instances of the application.\n\n\nSettings\n\n\nWhen an application requires a variable which should be user provided or will change between different installations, settings is a way to approach this problem.\n\n\nExample\n\n\n# in config.yaml\nname: appName\nsettings:\n  apiKey: 'enteryourapikey'\n\n\n\n\nEvery key in settings is exposed on the root \nmatrix\n object. Here, \nsettings.apiKey\n is available in the application environment as \nmatrix.apiKey\n.\n\n\n# in app.js\nexternalService.auth({ key:  matrix.apiKey }).then( ... );\n\n\n\n\nChanging application instance settings\n\n\nAfter a user installs the application, they can change the settings from the CLI tool.\n\n\nmatrix config appName apiKey=myrealapikeydontcopy\n\n\n\n\nLocal Database\n\n\nMATRIX OS provides a local, file-based key-value store for app usage. This is available across applications.\n\n\nIt is not recommended to set end user specific configurations here, and use \nconfig.yaml\nsettings\n instead.\n\n\nGet\n\n\nmatrix.store.get(key, cb)\n\n\n\n\nSet\n\n\nmatrix.store.set(key, value, cb)\n\n\n\n\nDelete\n\n\nmatrix.store.delete(key, cb)\n\n\n\n\nFile Storage\n\n\nMATRIX applications utilize a shared file storage, so files saved with one application are accessible from another.\n\n\nSave\n\n\n// url - publically accessible url\n// filename - what to save this file as\n// cb - function to call when save is complete\nmatrix.file.save( url, filename, cb )\n\n\n\n\nLoad\n\n\n// filename - file to load\n// cb - function to call after file is read, passed (err, data)\nmatrix.file.load(filename, cb)\n\n\n\n\nList\n\n\nmatrix.file.list(filename, function(err, files){\n  // files is an array of file names\n})\n\n\n\n\nRemove\n\n\n// filename - what file to Remove\n// cb - function to call when remove is complete\nmatrix.file.remove( filename, cb )", 
            "title": "System"
        }, 
        {
            "location": "/matrix-os/reference/system/#system-methods", 
            "text": "Several methods are available for common computing use cases, like application instance settings, storing files or persistant data lookups. These will be localized to the device and are not available across all instances of the application.", 
            "title": "System Methods"
        }, 
        {
            "location": "/matrix-os/reference/system/#settings", 
            "text": "When an application requires a variable which should be user provided or will change between different installations, settings is a way to approach this problem.", 
            "title": "Settings"
        }, 
        {
            "location": "/matrix-os/reference/system/#example", 
            "text": "# in config.yaml\nname: appName\nsettings:\n  apiKey: 'enteryourapikey'  Every key in settings is exposed on the root  matrix  object. Here,  settings.apiKey  is available in the application environment as  matrix.apiKey .  # in app.js\nexternalService.auth({ key:  matrix.apiKey }).then( ... );", 
            "title": "Example"
        }, 
        {
            "location": "/matrix-os/reference/system/#changing-application-instance-settings", 
            "text": "After a user installs the application, they can change the settings from the CLI tool.  matrix config appName apiKey=myrealapikeydontcopy", 
            "title": "Changing application instance settings"
        }, 
        {
            "location": "/matrix-os/reference/system/#local-database", 
            "text": "MATRIX OS provides a local, file-based key-value store for app usage. This is available across applications.  It is not recommended to set end user specific configurations here, and use  config.yaml settings  instead.", 
            "title": "Local Database"
        }, 
        {
            "location": "/matrix-os/reference/system/#get", 
            "text": "matrix.store.get(key, cb)", 
            "title": "Get"
        }, 
        {
            "location": "/matrix-os/reference/system/#set", 
            "text": "matrix.store.set(key, value, cb)", 
            "title": "Set"
        }, 
        {
            "location": "/matrix-os/reference/system/#delete", 
            "text": "matrix.store.delete(key, cb)", 
            "title": "Delete"
        }, 
        {
            "location": "/matrix-os/reference/system/#file-storage", 
            "text": "MATRIX applications utilize a shared file storage, so files saved with one application are accessible from another.", 
            "title": "File Storage"
        }, 
        {
            "location": "/matrix-os/reference/system/#save", 
            "text": "// url - publically accessible url\n// filename - what to save this file as\n// cb - function to call when save is complete\nmatrix.file.save( url, filename, cb )", 
            "title": "Save"
        }, 
        {
            "location": "/matrix-os/reference/system/#load", 
            "text": "// filename - file to load\n// cb - function to call after file is read, passed (err, data)\nmatrix.file.load(filename, cb)", 
            "title": "Load"
        }, 
        {
            "location": "/matrix-os/reference/system/#list", 
            "text": "matrix.file.list(filename, function(err, files){\n  // files is an array of file names\n})", 
            "title": "List"
        }, 
        {
            "location": "/matrix-os/reference/system/#remove", 
            "text": "// filename - what file to Remove\n// cb - function to call when remove is complete\nmatrix.file.remove( filename, cb )", 
            "title": "Remove"
        }, 
        {
            "location": "/matrix-os/reference/sensors/", 
            "text": "Sensors\n\n\nAvailable Sensors\n\n\ntemperature\n, \nhumidity\n, \npressure\n, \nuv\n, \ngyroscope\n, \naccelerometer\n\n\n\n\nYou should have familiarity with \nConfiguration Files\n before exploring Sensors. \n\n\n\n\nConfiguration\n\n\nEnd users must explicitly authorize MOS applications to utilize\u00a0hardware sensors.\n\n\nThis requires that each application identify required sensors in \nconfig.yaml\n.\n\n\nsensors:\n  - temperature\n  - uv\n\n\n\n\nOtherwise sensors will not work.\n\n\nmatrix.sensor()\n\n\nAll sensors are initialized using the \nsensor\n method.\n\n\n\n\nsensorType\n: Type of sensor you are initializing \n\n\noptions\n: The options for that sensor. By default, all sensors support a \nrefresh\n and \ntimeout\n property.\n\n\n\n\nvar options = {\n  refresh: 1000, //milliseconds between data points\n  timeout: 10000 //how long before stopping this sensor\n};\n\nmatrix.sensor('temperature', options).then(data =\n {\n  //see below for data formats\n});\n\n\n\n\nOutputs\n\n\nTemperature\n\n\nOutput for \ntemperature\n (in \n).\n\n\n{\n  value: 36.95899963378906,\n  type: 'temperature'\n}\n\n\n\n\nHumidity\n\n\nOutput for \nhumidity\n.\n\n\n{\n  value: 30.409704208374023,\n  type: 'humidity'\n}\n\n\n\n\nPressure\n\n\nOutput for \npressure\n (in mbars).\n\n\n{\n  value: 101692,\n  type: 'pressure'\n}\n\n\n\n\nUV\n\n\nOutput for \nUV\n.\n\n\n{\n   value: 0.0053547522984445095,\n   risk: 'Low'\n}\n\n\n\n\nGyroscope\n\n\nOutput for \ngyroscope\n.\n\n\n{\n  yaw: 144.78964233398438,\n  pitch: 2.112252950668335,\n  roll: -92.0414810180664,\n  x: -10.78155517578125,\n  y: 1.8841552734375,\n  z: 0.441131591796875,\n  type: 'gyroscope'\n}\n\n\n\n\n\nAccelerometer\n\n\nOutput for \naccelerometer\n\n\n{\n  x: 0.1,\n  y: 0.23,\n  z: 0.224,\n  type: 'accelerometer'\n}\n\n\n\n\nMagnetometer\n\n\nOutput for \nmagnetometer\n\n\n{\n  x: 0.51,\n  y: 0.53,\n  z: -0.124,\n  type: 'magnetometer'\n}\n\n\n\n\nFiltering Sensor Data\n\n\nSee \nMATRIX OS \n Reference \n Filter", 
            "title": "Sensors"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#sensors", 
            "text": "", 
            "title": "Sensors"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#available-sensors", 
            "text": "temperature ,  humidity ,  pressure ,  uv ,  gyroscope ,  accelerometer   You should have familiarity with  Configuration Files  before exploring Sensors.", 
            "title": "Available Sensors"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#configuration", 
            "text": "End users must explicitly authorize MOS applications to utilize\u00a0hardware sensors.  This requires that each application identify required sensors in  config.yaml .  sensors:\n  - temperature\n  - uv  Otherwise sensors will not work.", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#matrixsensor", 
            "text": "All sensors are initialized using the  sensor  method.   sensorType : Type of sensor you are initializing   options : The options for that sensor. By default, all sensors support a  refresh  and  timeout  property.   var options = {\n  refresh: 1000, //milliseconds between data points\n  timeout: 10000 //how long before stopping this sensor\n};\n\nmatrix.sensor('temperature', options).then(data =  {\n  //see below for data formats\n});", 
            "title": "matrix.sensor()"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#outputs", 
            "text": "", 
            "title": "Outputs"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#temperature", 
            "text": "Output for  temperature  (in  ).  {\n  value: 36.95899963378906,\n  type: 'temperature'\n}", 
            "title": "Temperature"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#humidity", 
            "text": "Output for  humidity .  {\n  value: 30.409704208374023,\n  type: 'humidity'\n}", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#pressure", 
            "text": "Output for  pressure  (in mbars).  {\n  value: 101692,\n  type: 'pressure'\n}", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#uv", 
            "text": "Output for  UV .  {\n   value: 0.0053547522984445095,\n   risk: 'Low'\n}", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#gyroscope", 
            "text": "Output for  gyroscope .  {\n  yaw: 144.78964233398438,\n  pitch: 2.112252950668335,\n  roll: -92.0414810180664,\n  x: -10.78155517578125,\n  y: 1.8841552734375,\n  z: 0.441131591796875,\n  type: 'gyroscope'\n}", 
            "title": "Gyroscope"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#accelerometer", 
            "text": "Output for  accelerometer  {\n  x: 0.1,\n  y: 0.23,\n  z: 0.224,\n  type: 'accelerometer'\n}", 
            "title": "Accelerometer"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#magnetometer", 
            "text": "Output for  magnetometer  {\n  x: 0.51,\n  y: 0.53,\n  z: -0.124,\n  type: 'magnetometer'\n}", 
            "title": "Magnetometer"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#filtering-sensor-data", 
            "text": "See  MATRIX OS   Reference   Filter", 
            "title": "Filtering Sensor Data"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/", 
            "text": "Computer Vision\n\n\nMATRIX OS is designed to integrate with computer vision in a powerful and robust way. You can use computer vision output to drive behavior, capture data for further analysis or anything you want!\n\n\nExample\n\n\nFrom \nfaceTest MATRIX App\n\n\nmatrix.led('red').render();\n\nmatrix.service('face').start().then(data =\n {\n  matrix.led('green').render();\n  setTimeout(function() {\n    matrix.led('black').render();\n  },2000);\n});\n\n\n\n\nConfiguration\n\n\nTo facilitate communication with the hardware,  CV services must be defined in \nconfig.yaml\n before they will be available to your application.\n\n\nservices:\n  faceDetection:\n    engine: detection\n    type: face\n\n\n\n\nmatrix.service\n\n\nThe base \nmatrix.service\n command is how you access computer vision services.\n\n\nmatrix.service( algorithm, options )\n\n\n\n\nbasic algorithms\n\n\nface\n - triggers when it sees a face shape\n\n\nfist\n - gesture recognition for a closed fist\n\n\npalm\n - gesture recognition for an open palm\n\n\noptions\n\n\nrefresh\n - how many seconds before restarting the detection, default: 3\n\n\ntimeout\n - if there is no detection, stop after this many seconds, default: none\n\n\nstart()\n\n\nStarts a given CV algorithm with provided options.\n\n\nmatrix.service( algorithm, options ).start()\n\n\n\n\nstop()\n\n\nStops running a CV algorithm.\n\n\nvar s = matrix.service( algorithm, options ).start();\ns.stop();\n\n//or\nmatrix.service(algorithm).stop();\n\n\n\n\n\n\n\n.then()\n\n\nReturns the data, \nPromise\n style.\n\n\npalm\n, \nface\n and \nfist\n have associated tags\n\n\nReturns \ntag\n: \nHAND_PALM\n, \nHAND_FIST\n, or\nFACE\n\n\nExample\n\n\n{\n  location: {\n   x: 333,\n   y: 237,\n   width: 55,\n   height: 55\n  },\n  tag: 'HAND_PALM'\n}\n\n\n\n\nComplete Example\n\n\n# app.js\nvar algorithm = 'face';\nvar options   = {};\nmatrix.service( algorithm, options ).start().then(function( data ){\n  // your CV detection data will be available here\n  console.log( data );\n});\n\n\n\n\nAdvanced Algorithms\n\n\ndemographics\n - age, gender and emotion detection\n\n\nrecognition\n - facial recognition\n\n\nExtended Face Analytics\n\n\nUse \ndemographics\n for the service call and in \nconfig\nservices\nname\nengine\n\n\nExample Config.yaml\n\n\nservices:\n  facelytics:\n    engine: detection\n    type: demographics\n\n\n\n\nExample app.js\n\n\nmatrix.service('demographics').start().then(function(output){\n  // see output below\n});\n\n\n\n\nDemographics Output\n\n\n{ location: { x: 213, y: 221, width: 55, height: 55 },\n tag: 'FACE',\n trackId: 2,\n demographics:\n  { gender: 'MALE',\n    emotion: 'CALM',\n    age: 25,\n    pose:\n     { yaw: -0.24303536117076874,\n       roll: 0.04344254732131958,\n       pitch: -0.10279278457164764 },\n    face_id: '4' } }\n\n\n\n\nTracking\n\n\ntrackId\n assigns a unique index-based identifier to each face detected. This number resets when the application or service is restarted, so do not rely on it for persistance.\n\n\nIf you need persistant facial detection, try the \nrecognition\n service.\n\n\navailable emotions\n\n\nHAPPY\n\n\nSAD\n\n\nCONFUSED\n\n\nANGRY\n\n\nCALM\n\n\nSURPRISED\n\n\nDISGUST\n\n\nRecognition\n\n\nrecognition\n - \nmatrix.service('recognition')\n\n\nMATRIX OS includes face recognition which turns a face into a series of numbers which can be used to identify the face when it is seen later. We do not store face images, just the numbers.\n\n\nRecognition only works from \n ~4 ft away. Removing hats and glasses will result in more accurate results.\n\n\nExample Config.yaml\n\n\nservices:\n  faceRecog:\n    engine: recognition\n    type: face\n\n\n\n\nExample app.js\n\n\nmatrix.service('recognition').start()\n\n\n\n\nBy default, \nrecognition\n works in \nRECOGNITION\n mode. Recognition requires training first.\n\n\ntrain()\n\n\nmatrix.service('recognition').train('test').then(data =\n  { ... });\n\n\n\n\nThis will associate a face with a particular tag. \n\n\nTraining Data Response\n\n\n{ \n  // number of trains performed\n  count: 2,\n  // number of trains desired\n  target: 7,\n  uuids: [...]\n}\n\n\n\n\nTraining Data Example\n\n\nThis will render a progress arc as training is completed.\n\n\nmatrix.service('recognition').train('test').then(function(d) {\n  matrix.led({\n    arc: Math.round(360 * (d.count / d.target)),\n    color: 'blue',\n    start: 0\n  }).render();\n});\n\n\n\n\nstart()\n\n\nAfter training, you can enable normal recognition as follows.\n\n\nmatrix.service('recognition').start().then(data =\n {...})\n\n\n\n\nRecognition Training Response\n\n\nOutputs a collection of tags and scores.\n\n\n[{ tags : ['tagName'], score: 0.8 }, {...}]\n\n\n\n\ntags\n are the tags matched with each recognition. \nscore\n is the measure of a match, lower numbers are better. \n 0.8\n is a good metric to use for recognition.\n\n\nRecognition Example\n\n\n\nmatrix.service('recognition').start().then(data =\n {...})\n// select the best match out of all the responses\n    var faces = _.values(d.matches);\n    faces = _.sortBy(faces, ['score'])[0];\n\n// if it passes a threshold, show green, otherwise show red\n    if (MinDistanceFace.score \n 0.85) {\n      matrix.led('green').render();\n    } else {\n      matrix.led('red').render();\n    }\n});\n\n\n\n\nStop()\n\n\nIf you need to explicitly stop a service, simply pass a \nstop()\n chained method.\n\n\nmatrix.service('recognition').stop()\n\n\n\n\nPlease note, that while this will tell the service to stop working, data may still trigger callbacks for a few seconds more.", 
            "title": "Computer Vision"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#computer-vision", 
            "text": "MATRIX OS is designed to integrate with computer vision in a powerful and robust way. You can use computer vision output to drive behavior, capture data for further analysis or anything you want!", 
            "title": "Computer Vision"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#example", 
            "text": "From  faceTest MATRIX App  matrix.led('red').render();\n\nmatrix.service('face').start().then(data =  {\n  matrix.led('green').render();\n  setTimeout(function() {\n    matrix.led('black').render();\n  },2000);\n});", 
            "title": "Example"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#configuration", 
            "text": "To facilitate communication with the hardware,  CV services must be defined in  config.yaml  before they will be available to your application.  services:\n  faceDetection:\n    engine: detection\n    type: face", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#matrixservice", 
            "text": "The base  matrix.service  command is how you access computer vision services.  matrix.service( algorithm, options )", 
            "title": "matrix.service"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#basic-algorithms", 
            "text": "face  - triggers when it sees a face shape  fist  - gesture recognition for a closed fist  palm  - gesture recognition for an open palm", 
            "title": "basic algorithms"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#options", 
            "text": "refresh  - how many seconds before restarting the detection, default: 3  timeout  - if there is no detection, stop after this many seconds, default: none", 
            "title": "options"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#start", 
            "text": "Starts a given CV algorithm with provided options.  matrix.service( algorithm, options ).start()", 
            "title": "start()"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#stop", 
            "text": "Stops running a CV algorithm.  var s = matrix.service( algorithm, options ).start();\ns.stop();\n\n//or\nmatrix.service(algorithm).stop();", 
            "title": "stop()"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#then", 
            "text": "Returns the data,  Promise  style.  palm ,  face  and  fist  have associated tags  Returns  tag :  HAND_PALM ,  HAND_FIST , or FACE", 
            "title": ".then()"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#example_1", 
            "text": "{\n  location: {\n   x: 333,\n   y: 237,\n   width: 55,\n   height: 55\n  },\n  tag: 'HAND_PALM'\n}", 
            "title": "Example"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#complete-example", 
            "text": "# app.js\nvar algorithm = 'face';\nvar options   = {};\nmatrix.service( algorithm, options ).start().then(function( data ){\n  // your CV detection data will be available here\n  console.log( data );\n});", 
            "title": "Complete Example"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#advanced-algorithms", 
            "text": "demographics  - age, gender and emotion detection  recognition  - facial recognition", 
            "title": "Advanced Algorithms"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#extended-face-analytics", 
            "text": "Use  demographics  for the service call and in  config services name engine", 
            "title": "Extended Face Analytics"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#example-configyaml", 
            "text": "services:\n  facelytics:\n    engine: detection\n    type: demographics", 
            "title": "Example Config.yaml"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#example-appjs", 
            "text": "matrix.service('demographics').start().then(function(output){\n  // see output below\n});", 
            "title": "Example app.js"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#demographics-output", 
            "text": "{ location: { x: 213, y: 221, width: 55, height: 55 },\n tag: 'FACE',\n trackId: 2,\n demographics:\n  { gender: 'MALE',\n    emotion: 'CALM',\n    age: 25,\n    pose:\n     { yaw: -0.24303536117076874,\n       roll: 0.04344254732131958,\n       pitch: -0.10279278457164764 },\n    face_id: '4' } }", 
            "title": "Demographics Output"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#tracking", 
            "text": "trackId  assigns a unique index-based identifier to each face detected. This number resets when the application or service is restarted, so do not rely on it for persistance.  If you need persistant facial detection, try the  recognition  service.", 
            "title": "Tracking"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#available-emotions", 
            "text": "HAPPY  SAD  CONFUSED  ANGRY  CALM  SURPRISED  DISGUST", 
            "title": "available emotions"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#recognition", 
            "text": "recognition  -  matrix.service('recognition')  MATRIX OS includes face recognition which turns a face into a series of numbers which can be used to identify the face when it is seen later. We do not store face images, just the numbers.  Recognition only works from   ~4 ft away. Removing hats and glasses will result in more accurate results.", 
            "title": "Recognition"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#example-configyaml_1", 
            "text": "services:\n  faceRecog:\n    engine: recognition\n    type: face", 
            "title": "Example Config.yaml"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#example-appjs_1", 
            "text": "matrix.service('recognition').start()  By default,  recognition  works in  RECOGNITION  mode. Recognition requires training first.", 
            "title": "Example app.js"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#train", 
            "text": "matrix.service('recognition').train('test').then(data =   { ... });  This will associate a face with a particular tag.", 
            "title": "train()"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#training-data-response", 
            "text": "{ \n  // number of trains performed\n  count: 2,\n  // number of trains desired\n  target: 7,\n  uuids: [...]\n}", 
            "title": "Training Data Response"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#training-data-example", 
            "text": "This will render a progress arc as training is completed.  matrix.service('recognition').train('test').then(function(d) {\n  matrix.led({\n    arc: Math.round(360 * (d.count / d.target)),\n    color: 'blue',\n    start: 0\n  }).render();\n});", 
            "title": "Training Data Example"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#start_1", 
            "text": "After training, you can enable normal recognition as follows.  matrix.service('recognition').start().then(data =  {...})", 
            "title": "start()"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#recognition-training-response", 
            "text": "Outputs a collection of tags and scores.  [{ tags : ['tagName'], score: 0.8 }, {...}]  tags  are the tags matched with each recognition.  score  is the measure of a match, lower numbers are better.   0.8  is a good metric to use for recognition.", 
            "title": "Recognition Training Response"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#recognition-example", 
            "text": "matrix.service('recognition').start().then(data =  {...})\n// select the best match out of all the responses\n    var faces = _.values(d.matches);\n    faces = _.sortBy(faces, ['score'])[0];\n\n// if it passes a threshold, show green, otherwise show red\n    if (MinDistanceFace.score   0.85) {\n      matrix.led('green').render();\n    } else {\n      matrix.led('red').render();\n    }\n});", 
            "title": "Recognition Example"
        }, 
        {
            "location": "/matrix-os/reference/computer-vision/#stop_1", 
            "text": "If you need to explicitly stop a service, simply pass a  stop()  chained method.  matrix.service('recognition').stop()  Please note, that while this will tell the service to stop working, data may still trigger callbacks for a few seconds more.", 
            "title": "Stop()"
        }, 
        {
            "location": "/matrix-os/reference/leds/", 
            "text": "Everloop LEDS\n\n\nA powerful tool for communicating with end users is the EverLoop LED circle. CLICK VIDEO BELOW:\n\n\n\n\nBasic Operations\n\n\nString Notation \n Render\n\n\nmatrix.led('blue'); //does nothing\n\nmatrix.led('green').render(); //lights change\n\n// supports css\nmatrix.led('rgb(255, 0, 100)').render();\n\n\n\n\nYou can use any CSS color property, including \nhttps://www.wikiwand.com/en/Web_colors#/X11_color_names\n. Darker colors on the Everloop generally display with more precision then lighter colors, which tend to get washed out. Please avoid \nrgba\n as alpha values do not render correctly. \n\n\nIntermediate Operation\n\n\nObject Notation - Shape Generators\n\n\nShape objects \n{Shape}\n are the fastest way to get started with Everloop. We are always building, \nlet us know\n what shapes you want us to work on next!\n\n\nThe object creation is simple, you combine global properties with specific properties into a single object that controls a single generator. To draw multiple shapes, see Multiple Shapes below.\n\n\nAvailable Shapes\n\n\nInclude one of these properties to enable the shape generator.\n\n\narc - number of degrees to draw an arc, important for smile faces, supports negative values\nfade - similiar to arc, except lights fade out\nangle - draw a single light at this degree point\n\n\n\n\nShape Properties\n\n\nEvery Shape object must include a \ncolor\n property to render.\n\n\ncolor - color strings, as specified above\nblend - mix lights to make angle positioning more precise\nspin - number of degrees by which to spin the hue ( 0 - 360 )\nstart - ( arc only ), start light index\n\n\n\n\nExample Shape Object\n\n\n{\n  color: 'red'\n  angle: 90\n}\n\n\n\n\nChaining Operations\n\n\nThese operate on the shapes and colors defined in the \nled\n object.\n\n\nrotate(angle) - rotates whole shape by this many degrees \nbrighten(steps) - brighten light by this many steps ( 0 - 10 )\ndarken(steps) - darken light by this many steps ( 0 - 10 )\n// brighten / darken are expensive operations and may not be suitable for rapidly updating displays\n\n\n\n\nMultiple shapes and pixel drawing\n\n\nUse an array to include multiple shapes. Color strings can also be included and will be drawn as a single light whose index matches the strings index in the array provided.\n\n\nExamples\n\n\nvar a = matrix.led({\n  // degrees of arc [ 90\u00b0 = quadrant ]   \n  arc: 90,\n\n  color: 'green',\n\n  // index to start drawing arc\n  start: 12\n}).render();\n\n\n// draw a point\nvar b = matrix.led({\n  angle: 245,\n  color: 'white',\n  // blends interlight space if true, solid lights if false, default false\n  blend: true\n}).render();\n\n// rotate the lights clockwise by a specified angle\nmatrix.led([a, b]).rotate(90).render();\n\n\n\n\nComposition\n\n\nShape Objects\n\n\n// make a smiley face\nmatrix.led([\n  {\n    angle: 45,\n    color: 'yellow'\n  },\n  {\n    angle: 135,\n    color: 'yellow'\n  },\n  {\n    arc: 90,\n    color: 'yellow',\n    start: 225\n  }\n]).render();\n\n\n\n\nDirect LED Manipulation\n\n\nArray index indicates the led to change\n\n\nmatrix.led([0, 0, 0, 0, 'yellow', 0,\n0, 0, 0, 0, 0, 0, 0, 'yellow', 0, 0,\n0, 0, 0, 0, 0, 0, 'yellow', 'yellow',\n'yellow', 'yellow', 'yellow', 'yellow',\n'yellow', 'yellow', 'yellow' ]).render();\n\n\n\n\nExample clock\n\n\nsetInterval(function(){\n  var time = new Date();\n  var h = time.getHours();\n  var m = time.getMinutes();\n  var s = time.getSeconds();\n\n  var hourLED = {\n    // translate hours (12) to angle (360)\n    arc: h * 3,\n    color: 'blue'\n  };\n\n  var minuteLED = {\n    // translate minutes ( 60 ) to angle ( 360 )\n    angle: m * 6,\n    color: 'green'\n  };\n\n  var secondLED = {\n    // translate seconds (60) to angle (360)\n    angle: s * 6,\n    color: 'yellow',\n    blend: true\n  };\n\n  // will draw all three\n  matrix.led([hourLED, minuteLED, secondLED]).render();\n\n}, 1000);\n\n\n\n\nAdvanced Use\n\n\nEnable \nSUN_MODE=true\n as a flag when launching MATRIX OS to turn on the white LEDs (and the luminence calculations). Wear sunglasses or use another mode of protecting your eyes when using this while developing. It is intended for use behind coverings.\n\n\nHigh Level Discussion\n\n\nMATRIX OS is an attempt at abstracting out the complexity of hardware to make it very accessible for end users. At the same time, one also wants to support those who might want to perform more complex operations. When designing a language, sometimes compromises between ease of use and features must be made.\n\n\nThe problem\n\n\nMany applications might want to write to the LED. We can leave it up to chance as to which gets to write, or we can approach it intelligently to optimize the aesthetics and performance. We also want to be able to manage and optimize LED transformations from a system level. Normally, MATRIX OS enables very fast communication with the hardware and tries to get out of the way as much as possible. For LEDS, we still get out of the way, but we need to blend all the input from different applications, otherwise this creates flicker as multiple applications compete for the same light indices. To discretely manage this, we created a special channel and notation just for leds.\n\n\nThe Solution\n\n\nmatrix.led", 
            "title": "Leds"
        }, 
        {
            "location": "/matrix-os/reference/leds/#everloop-leds", 
            "text": "A powerful tool for communicating with end users is the EverLoop LED circle. CLICK VIDEO BELOW:", 
            "title": "Everloop LEDS"
        }, 
        {
            "location": "/matrix-os/reference/leds/#basic-operations", 
            "text": "", 
            "title": "Basic Operations"
        }, 
        {
            "location": "/matrix-os/reference/leds/#string-notation-render", 
            "text": "matrix.led('blue'); //does nothing\n\nmatrix.led('green').render(); //lights change\n\n// supports css\nmatrix.led('rgb(255, 0, 100)').render();  You can use any CSS color property, including  https://www.wikiwand.com/en/Web_colors#/X11_color_names . Darker colors on the Everloop generally display with more precision then lighter colors, which tend to get washed out. Please avoid  rgba  as alpha values do not render correctly.", 
            "title": "String Notation &amp; Render"
        }, 
        {
            "location": "/matrix-os/reference/leds/#intermediate-operation", 
            "text": "", 
            "title": "Intermediate Operation"
        }, 
        {
            "location": "/matrix-os/reference/leds/#object-notation-shape-generators", 
            "text": "Shape objects  {Shape}  are the fastest way to get started with Everloop. We are always building,  let us know  what shapes you want us to work on next!  The object creation is simple, you combine global properties with specific properties into a single object that controls a single generator. To draw multiple shapes, see Multiple Shapes below.", 
            "title": "Object Notation - Shape Generators"
        }, 
        {
            "location": "/matrix-os/reference/leds/#available-shapes", 
            "text": "Include one of these properties to enable the shape generator.  arc - number of degrees to draw an arc, important for smile faces, supports negative values\nfade - similiar to arc, except lights fade out\nangle - draw a single light at this degree point", 
            "title": "Available Shapes"
        }, 
        {
            "location": "/matrix-os/reference/leds/#shape-properties", 
            "text": "Every Shape object must include a  color  property to render.  color - color strings, as specified above\nblend - mix lights to make angle positioning more precise\nspin - number of degrees by which to spin the hue ( 0 - 360 )\nstart - ( arc only ), start light index", 
            "title": "Shape Properties"
        }, 
        {
            "location": "/matrix-os/reference/leds/#example-shape-object", 
            "text": "{\n  color: 'red'\n  angle: 90\n}", 
            "title": "Example Shape Object"
        }, 
        {
            "location": "/matrix-os/reference/leds/#chaining-operations", 
            "text": "These operate on the shapes and colors defined in the  led  object.  rotate(angle) - rotates whole shape by this many degrees \nbrighten(steps) - brighten light by this many steps ( 0 - 10 )\ndarken(steps) - darken light by this many steps ( 0 - 10 )\n// brighten / darken are expensive operations and may not be suitable for rapidly updating displays", 
            "title": "Chaining Operations"
        }, 
        {
            "location": "/matrix-os/reference/leds/#multiple-shapes-and-pixel-drawing", 
            "text": "Use an array to include multiple shapes. Color strings can also be included and will be drawn as a single light whose index matches the strings index in the array provided.", 
            "title": "Multiple shapes and pixel drawing"
        }, 
        {
            "location": "/matrix-os/reference/leds/#examples", 
            "text": "var a = matrix.led({\n  // degrees of arc [ 90\u00b0 = quadrant ]   \n  arc: 90,\n\n  color: 'green',\n\n  // index to start drawing arc\n  start: 12\n}).render();\n\n\n// draw a point\nvar b = matrix.led({\n  angle: 245,\n  color: 'white',\n  // blends interlight space if true, solid lights if false, default false\n  blend: true\n}).render();\n\n// rotate the lights clockwise by a specified angle\nmatrix.led([a, b]).rotate(90).render();", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-os/reference/leds/#composition", 
            "text": "", 
            "title": "Composition"
        }, 
        {
            "location": "/matrix-os/reference/leds/#shape-objects", 
            "text": "// make a smiley face\nmatrix.led([\n  {\n    angle: 45,\n    color: 'yellow'\n  },\n  {\n    angle: 135,\n    color: 'yellow'\n  },\n  {\n    arc: 90,\n    color: 'yellow',\n    start: 225\n  }\n]).render();", 
            "title": "Shape Objects"
        }, 
        {
            "location": "/matrix-os/reference/leds/#direct-led-manipulation", 
            "text": "Array index indicates the led to change  matrix.led([0, 0, 0, 0, 'yellow', 0,\n0, 0, 0, 0, 0, 0, 0, 'yellow', 0, 0,\n0, 0, 0, 0, 0, 0, 'yellow', 'yellow',\n'yellow', 'yellow', 'yellow', 'yellow',\n'yellow', 'yellow', 'yellow' ]).render();", 
            "title": "Direct LED Manipulation"
        }, 
        {
            "location": "/matrix-os/reference/leds/#example-clock", 
            "text": "setInterval(function(){\n  var time = new Date();\n  var h = time.getHours();\n  var m = time.getMinutes();\n  var s = time.getSeconds();\n\n  var hourLED = {\n    // translate hours (12) to angle (360)\n    arc: h * 3,\n    color: 'blue'\n  };\n\n  var minuteLED = {\n    // translate minutes ( 60 ) to angle ( 360 )\n    angle: m * 6,\n    color: 'green'\n  };\n\n  var secondLED = {\n    // translate seconds (60) to angle (360)\n    angle: s * 6,\n    color: 'yellow',\n    blend: true\n  };\n\n  // will draw all three\n  matrix.led([hourLED, minuteLED, secondLED]).render();\n\n}, 1000);", 
            "title": "Example clock"
        }, 
        {
            "location": "/matrix-os/reference/leds/#advanced-use", 
            "text": "Enable  SUN_MODE=true  as a flag when launching MATRIX OS to turn on the white LEDs (and the luminence calculations). Wear sunglasses or use another mode of protecting your eyes when using this while developing. It is intended for use behind coverings.", 
            "title": "Advanced Use"
        }, 
        {
            "location": "/matrix-os/reference/leds/#high-level-discussion", 
            "text": "MATRIX OS is an attempt at abstracting out the complexity of hardware to make it very accessible for end users. At the same time, one also wants to support those who might want to perform more complex operations. When designing a language, sometimes compromises between ease of use and features must be made.", 
            "title": "High Level Discussion"
        }, 
        {
            "location": "/matrix-os/reference/leds/#the-problem", 
            "text": "Many applications might want to write to the LED. We can leave it up to chance as to which gets to write, or we can approach it intelligently to optimize the aesthetics and performance. We also want to be able to manage and optimize LED transformations from a system level. Normally, MATRIX OS enables very fast communication with the hardware and tries to get out of the way as much as possible. For LEDS, we still get out of the way, but we need to blend all the input from different applications, otherwise this creates flicker as multiple applications compete for the same light indices. To discretely manage this, we created a special channel and notation just for leds.", 
            "title": "The problem"
        }, 
        {
            "location": "/matrix-os/reference/leds/#the-solution", 
            "text": "matrix.led", 
            "title": "The Solution"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/", 
            "text": "Cross-Talk\n\n\nCross-Talk is a mechanism for applications to communicate, whether on the same device, or on different devices. Applications can exchange information with other applications, or with other instances of the same application. All messages get sent to all devices, so if you have the same app running on different devices, this is how to communicate between installations of the\u00a0same app.\n\n\nOverview\n\n\nCross talk events are publicly searchable by app, and allow MATRIX applications to easily exchange information between devices, or on the same device. For example, a face detection application could trigger a \nface-in\n, which is heard by a \nconfigured\n and \ntrained\n recognition program.\n\n\nConfig Setup\n\n\nCrossTalk requires setup in configuration to execute successfully. This information is also used in the app store to determine which applications can communicate via events.\n\n\nGlobal\n\n\nevents:\n  - globalEvent\n\n\n\n\nApp Targeted\n\n\nevents:\n  - appName\n\n\n\n\nApp/Event Targeted\n\n\nevents:\n  - appname:\n    - eventname\n\n\n\n\nGlobal Emitters \n Listeners\n\n\nGlobal messages that can be received across applications, devices, and clients. e.g. Emit from one device, receive on another.\n\n\n.emit(payload)\n\n\n\n\npayload\n Object or string to pass through to retrieve with the listener.\n\n\n\n\n// Send a payload to all listeners\nmatrix.emit(payload);\n\n\n\n\n.on(cb)\n\n\n\n\ncb\n Callback method with \npayload\n returned.\n\n\n\n\n// Listen for global CrossTalk messages\nmatrix.on(function(payload) { ... });\n\n\n\n\nApp Specific Message\n\n\nMessages that can be shared across applications on a single device.\n\n\n.emit(app, payload)\n\n\n\n\napp\n Label to later listen for.\n\n\npayload\n Object or string to pass through to retrieve with the listener.\n\n\n\n\n// Send a message to a particular application\nmatrix.emit('app', payload);\n\n\n\n\n.on(cb)\n\n\n\n\ncb\n Callback method with payload returned.\n\n\n\n\n// Listen for application specific CrossTalk messages\nmatrix.on(function(payload) { ... });\n\n\n\n\nSpecific Event within App\n\n\nMessages that can be filtered by application, and an event type.\n\n\n.emit(app, event, payload)\n\n\n\n\napp\n Label to later listen for.\n\n\nevent\n Event scope within \napp\n to listen for.\n\n\npayload\n Object or string to pass through to retrieve with the listener.\n\n\n\n\n// Trigger an event in a specific application\nmatrix.emit('app', 'event', payload);\n\n\n\n\n.on(event, cb)\n\n\n\n\nevent\n Event to listen on.\n\n\ncb\n Callback method with payload returned.\n\n\n\n\n// Listen for CrossTalk events sent to this application\nmatrix.on('event', function(payload) { ... });\n\n\n\n\nDashboard\n\n\nReceive events from web or mobile by binding them to widget controls.\n\n\n// Interface elements from Dashboards can also trigger CrossTalk events.\nmatrix.on('buttonClick', function(payload) { ... });\n\n\n\n\nConfiguration-Driven Events\n\n\nSee \nConfiguration \n Widgets", 
            "title": "Crosstalk"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#cross-talk", 
            "text": "Cross-Talk is a mechanism for applications to communicate, whether on the same device, or on different devices. Applications can exchange information with other applications, or with other instances of the same application. All messages get sent to all devices, so if you have the same app running on different devices, this is how to communicate between installations of the\u00a0same app.", 
            "title": "Cross-Talk"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#overview", 
            "text": "Cross talk events are publicly searchable by app, and allow MATRIX applications to easily exchange information between devices, or on the same device. For example, a face detection application could trigger a  face-in , which is heard by a  configured  and  trained  recognition program.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#config-setup", 
            "text": "CrossTalk requires setup in configuration to execute successfully. This information is also used in the app store to determine which applications can communicate via events.", 
            "title": "Config Setup"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#global", 
            "text": "events:\n  - globalEvent", 
            "title": "Global"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#app-targeted", 
            "text": "events:\n  - appName", 
            "title": "App Targeted"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#appevent-targeted", 
            "text": "events:\n  - appname:\n    - eventname", 
            "title": "App/Event Targeted"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#global-emitters-listeners", 
            "text": "Global messages that can be received across applications, devices, and clients. e.g. Emit from one device, receive on another.", 
            "title": "Global Emitters &amp; Listeners"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#emitpayload", 
            "text": "payload  Object or string to pass through to retrieve with the listener.   // Send a payload to all listeners\nmatrix.emit(payload);", 
            "title": ".emit(payload)"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#oncb", 
            "text": "cb  Callback method with  payload  returned.   // Listen for global CrossTalk messages\nmatrix.on(function(payload) { ... });", 
            "title": ".on(cb)"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#app-specific-message", 
            "text": "Messages that can be shared across applications on a single device.", 
            "title": "App Specific Message"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#emitapp-payload", 
            "text": "app  Label to later listen for.  payload  Object or string to pass through to retrieve with the listener.   // Send a message to a particular application\nmatrix.emit('app', payload);", 
            "title": ".emit(app, payload)"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#oncb_1", 
            "text": "cb  Callback method with payload returned.   // Listen for application specific CrossTalk messages\nmatrix.on(function(payload) { ... });", 
            "title": ".on(cb)"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#specific-event-within-app", 
            "text": "Messages that can be filtered by application, and an event type.", 
            "title": "Specific Event within App"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#emitapp-event-payload", 
            "text": "app  Label to later listen for.  event  Event scope within  app  to listen for.  payload  Object or string to pass through to retrieve with the listener.   // Trigger an event in a specific application\nmatrix.emit('app', 'event', payload);", 
            "title": ".emit(app, event, payload)"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#onevent-cb", 
            "text": "event  Event to listen on.  cb  Callback method with payload returned.   // Listen for CrossTalk events sent to this application\nmatrix.on('event', function(payload) { ... });", 
            "title": ".on(event, cb)"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#dashboard", 
            "text": "Receive events from web or mobile by binding them to widget controls.  // Interface elements from Dashboards can also trigger CrossTalk events.\nmatrix.on('buttonClick', function(payload) { ... });", 
            "title": "Dashboard"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#configuration-driven-events", 
            "text": "See  Configuration   Widgets", 
            "title": "Configuration-Driven Events"
        }, 
        {
            "location": "/matrix-os/reference/zigbee/", 
            "text": "Zigbee\n\n\nAlpha API, subject to deprecation\n\n\nVersion Introduced: 0.9.0\n\n\nConfiguration\n\n\nZigbee requires \nzigbee\n to be added to \nintegrations\n in the \nconfig.yaml\n\n\n# config.yaml\nintegrations:\n  - zigbee\n\n\n\n\nBase\n\n\nmatrix.zigbee()\n - activates the zigbee network and sees if any of the remembered devices are available\n\n\nReturns an object which is used to activate other zigbee commands\n\n\nvar zb = matrix.zigbee();\n\n\n\n\nNetwork\n\n\nzb.discover()\n - put zigbee into discover mode for 60 seconds. power on your zigbee device to have it be found\n\n\nzb.reset()\n - if you get into problems, issue a reset command\n\n\nLights\n\n\ncurrently, only zigbee lights are supported\n\nzb.light(n)\n - address found lights. \nn\n indicates the number of the light, in order of which it was added, default to the first.\n\n\nzb.light().on()\n - turns on the light\n\nzb.light().off()\n - turns off the light\n\nzb.light().toggle()\n - turns the light\u00a0on or off\n\n\nzb.light().fadeIn(time)\n - slowly turn a light over \ntime\n seconds\n\nzb.light().fadeOut(time)\n - slowly turn off a light over \ntime\n seconds\n\n\nzb.light().color(hue, time)\n - sets the light to \nhue\n color, over \ntime\n seconds, defaulting to 3 seconds. \nhue\n accepts 0-360 hue values, in addition any \ncolor\n value which would be passed to the Everloop, like \n'blue'\n or \n'#0000FF'\n. see \nEverloop\n\n\nzb.light().level(level, time)\n - sets the light level to \nlevel\n 0-100 over \ntime\n seconds, defaults to 3\n\n\nExample\n\n\nUse events to have precise control over your zigbee devices.\n\n\nmatrix.on('discover', function(){\n  matrix.zigbee().discover();\n});\n\nmatrix.on('reset', function(){\n  matrix.zigbee().reset();\n});\n\nmatrix.on('toggle', function(){\n  matrix.zigbee().light().toggle();\n});\n\nmatrix.on('off', function(){\n  matrix.zigbee().light().fadeOut(10);\n});\n\nmatrix.on('on', function(){\n  matrix.zigbee().light().fadeIn(10);\n});\n\nmatrix.on('dim', function(){\n  matrix.zigbee().light().level(10, 5);\n});\n\nvar spin;\nmatrix.on('spin', function(){\n  var hue = 0;\n  var i = 0;\n  setInterval( function(){\n    spin = matrix.led({\n        h: hue++,\n        s: 1,\n        l: 0.5\n      }).render();\n\n    if ( i \n 35 ){\n      i = 0;\n    }\n\n    if ( hue \n 360){\n      hue = 0;\n    }\n\n    if ( hue % 10 === 0){\n      matrix.zigbee().light().color(hue, 1);\n    }\n  }, 50);\n});\n\nmatrix.on('stop', function(){\n  clearInterval(spin);\n});\n\n\n\n\nIssue a \nspin\n event against the above application to cycle colors on the Everloop and set the zigbee light to the same color.", 
            "title": "Zigbee"
        }, 
        {
            "location": "/matrix-os/reference/zigbee/#zigbee", 
            "text": "Alpha API, subject to deprecation  Version Introduced: 0.9.0", 
            "title": "Zigbee"
        }, 
        {
            "location": "/matrix-os/reference/zigbee/#configuration", 
            "text": "Zigbee requires  zigbee  to be added to  integrations  in the  config.yaml  # config.yaml\nintegrations:\n  - zigbee", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/zigbee/#base", 
            "text": "matrix.zigbee()  - activates the zigbee network and sees if any of the remembered devices are available  Returns an object which is used to activate other zigbee commands  var zb = matrix.zigbee();", 
            "title": "Base"
        }, 
        {
            "location": "/matrix-os/reference/zigbee/#network", 
            "text": "zb.discover()  - put zigbee into discover mode for 60 seconds. power on your zigbee device to have it be found  zb.reset()  - if you get into problems, issue a reset command", 
            "title": "Network"
        }, 
        {
            "location": "/matrix-os/reference/zigbee/#lights", 
            "text": "currently, only zigbee lights are supported zb.light(n)  - address found lights.  n  indicates the number of the light, in order of which it was added, default to the first.  zb.light().on()  - turns on the light zb.light().off()  - turns off the light zb.light().toggle()  - turns the light\u00a0on or off  zb.light().fadeIn(time)  - slowly turn a light over  time  seconds zb.light().fadeOut(time)  - slowly turn off a light over  time  seconds  zb.light().color(hue, time)  - sets the light to  hue  color, over  time  seconds, defaulting to 3 seconds.  hue  accepts 0-360 hue values, in addition any  color  value which would be passed to the Everloop, like  'blue'  or  '#0000FF' . see  Everloop  zb.light().level(level, time)  - sets the light level to  level  0-100 over  time  seconds, defaults to 3", 
            "title": "Lights"
        }, 
        {
            "location": "/matrix-os/reference/zigbee/#example", 
            "text": "Use events to have precise control over your zigbee devices.  matrix.on('discover', function(){\n  matrix.zigbee().discover();\n});\n\nmatrix.on('reset', function(){\n  matrix.zigbee().reset();\n});\n\nmatrix.on('toggle', function(){\n  matrix.zigbee().light().toggle();\n});\n\nmatrix.on('off', function(){\n  matrix.zigbee().light().fadeOut(10);\n});\n\nmatrix.on('on', function(){\n  matrix.zigbee().light().fadeIn(10);\n});\n\nmatrix.on('dim', function(){\n  matrix.zigbee().light().level(10, 5);\n});\n\nvar spin;\nmatrix.on('spin', function(){\n  var hue = 0;\n  var i = 0;\n  setInterval( function(){\n    spin = matrix.led({\n        h: hue++,\n        s: 1,\n        l: 0.5\n      }).render();\n\n    if ( i   35 ){\n      i = 0;\n    }\n\n    if ( hue   360){\n      hue = 0;\n    }\n\n    if ( hue % 10 === 0){\n      matrix.zigbee().light().color(hue, 1);\n    }\n  }, 50);\n});\n\nmatrix.on('stop', function(){\n  clearInterval(spin);\n});  Issue a  spin  event against the above application to cycle colors on the Everloop and set the zigbee light to the same color.", 
            "title": "Example"
        }, 
        {
            "location": "/matrix-os/reference/gpio/", 
            "text": "GPIO\n\n\nGPIO can be used to communicate or receive input from analog and digital components through the MATRIX Creator, or any other sensor leveraging Raspberry Pi's GPIOs.\n\n\nConfiguration\n\n\nMake sure to add the following to your \nconfig.yaml\n to enable GPIO's/\n\n\nintegrations:\n  - gpio\n\n\n\n\nmatrix.gpio.read\n\n\n\n\npinNumber\n: The GPIO you are reading from.\n\n\ncallback\n: Returns \nerr\n, \nvalue\n.\n\n\n\n\nmatrix.gpio.read(16, function(err, value) {\n  if(err) throw err;\n  console.log(value);   // The current state of the pin\n});\n\n\n\n\nmatrix.gpio.write\n\n\n\n\npinNumber\n: The GPIO you are reading from.\n\n\nvalue\n: The value you would like to update the GPIO with.\n\n\ncallback\n: Returns \nerr\n, \nvalue\n.\n\n\n\n\nmatrix.gpio.write(16, 1, function(err) {\n    if(err) throw err;\n});\n\n\n\n\nServo\n\n\nConfiguration\n\n\nMake sure to add the following to your \nconfig.yaml\n to enable Servos/\n\n\nintegrations:\n  - gpio\n\n\n\n\nmatrix.servo\n\n\n\n\npin\n: The GPIO pin the servo is connected to.\n\n\nangle\n: Integer specifying the specific angle to set the servo to.\n\n\n\n\nmatrix.servo(pin, angle);", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-os/reference/gpio/#gpio", 
            "text": "GPIO can be used to communicate or receive input from analog and digital components through the MATRIX Creator, or any other sensor leveraging Raspberry Pi's GPIOs.", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-os/reference/gpio/#configuration", 
            "text": "Make sure to add the following to your  config.yaml  to enable GPIO's/  integrations:\n  - gpio", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/gpio/#matrixgpioread", 
            "text": "pinNumber : The GPIO you are reading from.  callback : Returns  err ,  value .   matrix.gpio.read(16, function(err, value) {\n  if(err) throw err;\n  console.log(value);   // The current state of the pin\n});", 
            "title": "matrix.gpio.read"
        }, 
        {
            "location": "/matrix-os/reference/gpio/#matrixgpiowrite", 
            "text": "pinNumber : The GPIO you are reading from.  value : The value you would like to update the GPIO with.  callback : Returns  err ,  value .   matrix.gpio.write(16, 1, function(err) {\n    if(err) throw err;\n});", 
            "title": "matrix.gpio.write"
        }, 
        {
            "location": "/matrix-os/reference/gpio/#servo", 
            "text": "", 
            "title": "Servo"
        }, 
        {
            "location": "/matrix-os/reference/gpio/#configuration_1", 
            "text": "Make sure to add the following to your  config.yaml  to enable Servos/  integrations:\n  - gpio", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/gpio/#matrixservo", 
            "text": "pin : The GPIO pin the servo is connected to.  angle : Integer specifying the specific angle to set the servo to.   matrix.servo(pin, angle);", 
            "title": "matrix.servo"
        }, 
        {
            "location": "/matrix-os/reference/ir/", 
            "text": "Sending IR Commands as a remote control\n\n\nCurrently,  we have implemented remote emulation. We will offer a more precise way to send and recieve information over IR.\n\n\nFind the remote you want to emulate at the \nLIRC Remote Table\n.\n\n\nOpen the \n.conf\n file and take note of the \ncodes\n. Sending these through MATRIX OS via \nmatrix.ir().send()\n will replicate a button press and blast a signal out the IR transmitters. \n\n\nmatrix.ir( brand, model )\n\n\nThis tells your device to lookup a definition for the remote and use those values for the IR transmission.\n\n\nExample\n\n\nmatrix.ir('SONY', 'RM-833').send('KEY_POWER')", 
            "title": "IR"
        }, 
        {
            "location": "/matrix-os/reference/ir/#sending-ir-commands-as-a-remote-control", 
            "text": "Currently,  we have implemented remote emulation. We will offer a more precise way to send and recieve information over IR.  Find the remote you want to emulate at the  LIRC Remote Table .  Open the  .conf  file and take note of the  codes . Sending these through MATRIX OS via  matrix.ir().send()  will replicate a button press and blast a signal out the IR transmitters.", 
            "title": "Sending IR Commands as a remote control"
        }, 
        {
            "location": "/matrix-os/reference/ir/#matrixir-brand-model", 
            "text": "This tells your device to lookup a definition for the remote and use those values for the IR transmission.", 
            "title": "matrix.ir( brand, model )"
        }, 
        {
            "location": "/matrix-os/reference/ir/#example", 
            "text": "matrix.ir('SONY', 'RM-833').send('KEY_POWER')", 
            "title": "Example"
        }, 
        {
            "location": "/matrix-os/reference/microphone/", 
            "text": "Voice Control\n\n\nMATRIX OS provides for voice recognition via wakeword detection. \"Hey Siri\", \"Alexa\", \"Ok Google\" are examples of common wakewords used in commercial products. The default wakeword for MATRIX OS is \"Matrix\", however, you can train any wakeword you want.\n\n\nConfiguration\n\n\nservices:\n  customListener:\n    engine: voice\n    phrase: hey joe\n\n\n\n\nWakeword Training\n\n\nmatrix.listen('hey joe', function(err, phrase){\n\n});\n\n// equivalent to\n\nmatrix.listen('customListener', function(err, phrase){\n\n});\n\n// equivalent to\n\nmatrix.service('voice').listen('hey joe', function(err, phrase){\n\n});\n\n// equivalent to \nmatrix.service('customListener').listen(function(err, phrase){\n\n})", 
            "title": "Microphone"
        }, 
        {
            "location": "/matrix-os/reference/microphone/#voice-control", 
            "text": "MATRIX OS provides for voice recognition via wakeword detection. \"Hey Siri\", \"Alexa\", \"Ok Google\" are examples of common wakewords used in commercial products. The default wakeword for MATRIX OS is \"Matrix\", however, you can train any wakeword you want.", 
            "title": "Voice Control"
        }, 
        {
            "location": "/matrix-os/reference/microphone/#configuration", 
            "text": "services:\n  customListener:\n    engine: voice\n    phrase: hey joe", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/microphone/#wakeword-training", 
            "text": "matrix.listen('hey joe', function(err, phrase){\n\n});\n\n// equivalent to\n\nmatrix.listen('customListener', function(err, phrase){\n\n});\n\n// equivalent to\n\nmatrix.service('voice').listen('hey joe', function(err, phrase){\n\n});\n\n// equivalent to \nmatrix.service('customListener').listen(function(err, phrase){\n\n})", 
            "title": "Wakeword Training"
        }, 
        {
            "location": "/matrix-os/reference/integrations/", 
            "text": "Integrations\n\n\nExternal integrations must be enabled via configuration.\n\n\nConfiguration\n\n\n# in config.yaml\nintegrations\n  - ifttt\n\n\n\n\nIFTTT\n\n\nIf This Then That\n enables a MATRIX device to trigger actions or react to external events. By piggybacking onto the existing \nevent system\n, MOS can seamlessly integrates with thousands of platforms available on IFTTT.\n\n\nZigbee\n\n\nZigbee is a popular wireless protocol for smart device control.\n\n\nSee \nZigbee", 
            "title": "Integrations"
        }, 
        {
            "location": "/matrix-os/reference/integrations/#integrations", 
            "text": "External integrations must be enabled via configuration.", 
            "title": "Integrations"
        }, 
        {
            "location": "/matrix-os/reference/integrations/#configuration", 
            "text": "# in config.yaml\nintegrations\n  - ifttt", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/integrations/#ifttt", 
            "text": "If This Then That  enables a MATRIX device to trigger actions or react to external events. By piggybacking onto the existing  event system , MOS can seamlessly integrates with thousands of platforms available on IFTTT.", 
            "title": "IFTTT"
        }, 
        {
            "location": "/matrix-os/reference/integrations/#zigbee", 
            "text": "Zigbee is a popular wireless protocol for smart device control.  See  Zigbee", 
            "title": "Zigbee"
        }, 
        {
            "location": "/matrix-os/reference/filters/", 
            "text": "Filters\n\n\nMatrixOS sensors and computer vision algorithms provide data which can be filtered between the \nsensor\n, which can be regarded as the data source, and the \nthen\n, which can be regarded as the data receiver. Between the two, we can use chaining methods to easily filter what data is received.\n\n\n// filtering in a simple application\nmatrix.sensor('temperature')\n.above(80)\n.then(data =\n {\n  // see CrossTalk documentation for more information about matrix.emit\n  matrix.emit('ac-control', 'turnOn');\n});\n\n\n\n\nFiltering decides whether or not a data point is passed to the \nthen()\n, it does not change the data in any way.\n\n\nSimple Filtering methods\n\n\nequality\n\n\nNumeric\n\n\nis()\n \nlike()\n\n\nmatrix.sensor('temperature').is(72)\n\n\n\n\n\n\n\nhas\n\n\nhas()\n is used to refine a data source by additional criteria and keys.\n\n\n// for simple sensors\nmatrix.sensor('temperature').has('value')\n// equivalent to\nmatrix.sensor('temperature').has()\n\n// for complex sensors\nmatrix.sensor('gyroscope').has('x')\n\n\n\n\n\nbounds\n\n\n greater then\n\n\nabove\n, \nover\n, \nafter\n\n\nmatrix.sensor('temperature').has().above(72)\n\n\n\n\n less then\n\n\nbelow\n, \nunder\n, \nbefore\n\n\nmatrix.sensor('temperature').has().below(32)\n\n\n\n\nbetween\n\n\nmatrix.service('face').start().has('happy').between(50,100)", 
            "title": "Filters"
        }, 
        {
            "location": "/matrix-os/reference/filters/#filters", 
            "text": "MatrixOS sensors and computer vision algorithms provide data which can be filtered between the  sensor , which can be regarded as the data source, and the  then , which can be regarded as the data receiver. Between the two, we can use chaining methods to easily filter what data is received.  // filtering in a simple application\nmatrix.sensor('temperature')\n.above(80)\n.then(data =  {\n  // see CrossTalk documentation for more information about matrix.emit\n  matrix.emit('ac-control', 'turnOn');\n});  Filtering decides whether or not a data point is passed to the  then() , it does not change the data in any way.", 
            "title": "Filters"
        }, 
        {
            "location": "/matrix-os/reference/filters/#simple-filtering-methods", 
            "text": "", 
            "title": "Simple Filtering methods"
        }, 
        {
            "location": "/matrix-os/reference/filters/#equality", 
            "text": "", 
            "title": "equality"
        }, 
        {
            "location": "/matrix-os/reference/filters/#numeric", 
            "text": "is()   like()  matrix.sensor('temperature').is(72)", 
            "title": "Numeric"
        }, 
        {
            "location": "/matrix-os/reference/filters/#has", 
            "text": "has()  is used to refine a data source by additional criteria and keys.  // for simple sensors\nmatrix.sensor('temperature').has('value')\n// equivalent to\nmatrix.sensor('temperature').has()\n\n// for complex sensors\nmatrix.sensor('gyroscope').has('x')", 
            "title": "has"
        }, 
        {
            "location": "/matrix-os/reference/filters/#bounds", 
            "text": "", 
            "title": "bounds"
        }, 
        {
            "location": "/matrix-os/reference/filters/#greater-then", 
            "text": "above ,  over ,  after  matrix.sensor('temperature').has().above(72)", 
            "title": "&gt; greater then"
        }, 
        {
            "location": "/matrix-os/reference/filters/#less-then", 
            "text": "below ,  under ,  before  matrix.sensor('temperature').has().below(32)", 
            "title": "&lt; less then"
        }, 
        {
            "location": "/matrix-os/reference/filters/#between", 
            "text": "matrix.service('face').start().has('happy').between(50,100)", 
            "title": "between"
        }, 
        {
            "location": "/matrix-os/reference/screens/", 
            "text": "Screens\n\n\nMATRIX Dashboards are made up of \nwidgets\n, and the \nscreens\n option in the \nconfiguration\n file, \nconfig.yaml\n determines how they are arranged and laid out.\n\n\nscreens\n uses structured data to represnent layouts. One array represents a row, elements of that array are columns within that row. Widget names must be used in the \nscreens\n array to link the layout with the configuration widget object.\n\n\nThis means that every \nscreen\n must be a nested array. In YAML, `[[a, b]]`` is represented by\n\n\nscreens:\n  - - a\n    - b\n\n\n\n\nIt's not pretty, but it allows us much design flexibility in a configuration file. \n\n\nFor example, this creates a dashboard with two widgets in one row, each taking up 50% of the available width.\n\n\nscreens:\n  - - leftWidget\n    - rightWidget\n\nwidgets:\n  leftWidget: ...\n  rightWidget: ...\n\n\n\n\nYou can use nesting within the \nscreens\n data structure to further customize the layout.\n\n\nThis example would produce two rows, the first with two panels, the second with three.\n\n\nscreens:\n  - - topLeft\n    - topRight\n  - - bottomLeft\n    - bottomCenter\n    - bottomRight", 
            "title": "Screens"
        }, 
        {
            "location": "/matrix-os/reference/screens/#screens", 
            "text": "MATRIX Dashboards are made up of  widgets , and the  screens  option in the  configuration  file,  config.yaml  determines how they are arranged and laid out.  screens  uses structured data to represnent layouts. One array represents a row, elements of that array are columns within that row. Widget names must be used in the  screens  array to link the layout with the configuration widget object.  This means that every  screen  must be a nested array. In YAML, `[[a, b]]`` is represented by  screens:\n  - - a\n    - b  It's not pretty, but it allows us much design flexibility in a configuration file.   For example, this creates a dashboard with two widgets in one row, each taking up 50% of the available width.  screens:\n  - - leftWidget\n    - rightWidget\n\nwidgets:\n  leftWidget: ...\n  rightWidget: ...  You can use nesting within the  screens  data structure to further customize the layout.  This example would produce two rows, the first with two panels, the second with three.  screens:\n  - - topLeft\n    - topRight\n  - - bottomLeft\n    - bottomCenter\n    - bottomRight", 
            "title": "Screens"
        }, 
        {
            "location": "/matrix-os/reference/widgets/", 
            "text": "Widgets\n\n\nDefined in config.yaml, widgets display information from the device and allow you to send information via familiar interfaces, like dropdowns and buttons.\n\n\nLayout\n\n\nFor details on how to arrange widgets on a dashboard, see \nScreens\n\n\nWidgets are basically configuration objects which can be defined with the following options. \n\n\nOptions\n\n\nAll Widgets\n\n\n\n\nlabel\n - text label for this widget box\n\n\n\n\nWidgets come in two forms:\n\n Display Widgets - Displays data from an application\n\n Interactive Widgets - Sends real-time events to an application\n\n\nDisplay Widget Options\n\n\nDisplay widgets, like tables, charts and value outputs are only concerned with what data to display and how to display it.\n\n \ndisplay\n - which display widget to load\n\n \nkey\n/\nkeys\n - show these keys from the data payload\n\n \ntype\n - select keys from this data segment (see \nOverview \n Sending Data\n )\n\n \nformat\n - filter the data. choose from \ncount\n, \nsum\n, \navg\n, \npercent\n, \nmax\n, \nmin\n, \nfixed\n, \nround\n.\n\n \nrealtime\n - defaults to true. set to false and use refresh option for manual updates.\n\n \nrefresh\n - how many seconds between data refresh. not set by default. use with realtime: false. \n\n\nInteractive Widget Options\n\n\n\n\ncontrol\n - which interactive widget to load\n\n\ntrigger\n - the event to listen for in your application ( see \nReference \n Crosstalk\n)\n\n\nvalue\n - on button widgets, what text should be in the button\n\n\nmap\n - on button widgets, a collection of \nvalue: trigger\n where value is the button text, and trigger is the event fired\n\n\n\n\nData Operations\n\n\nUsing \nformat\n, data operations can be applied to the data for each Display Widget. The current widget configuration supports the operations: \ncount\n, \nsum\n, \navg\n, \npercent\n, \nmax\n, \nmin\n, \nfixed\n, \nround\n.\n\n\nData Handling\n\n\nThe dashboard holds a central data store which the widgets receive or request data from.\n\n\nDefault operation is for a widget to be updated with data in real time. This is represented by enabling the option \nrealtime\n:\n\n\n// To enable realtime updates\nwidgets:\n  testWidget:\n     realtime: true\n\n\n\n\nThe alternative is to have a widget manually refresh it's data on an interval by disabling \nrealtime\n. Default \nrefresh\n is 5 seconds. If you wanted to refresh a graph every minute:\n\n\n// To disable realtime updates\nwidgets:\n  testWidget:\n     realtime: false\n     refresh: 60\n\n\n\n\nWidget Size\n\n\nWidgets can be resized horizontally with the \nsize\n attribute.\n\n\nSize is simply the percentage width you would like the widget to take. If size is not specified, then the widget will take up a equal proportion of the remaining width.\n\n\nExample\n\n\nwidgets:\n  halfWidth:\n    size: 50\n  quarterWidth:\n    size: 25\n    # size doesn't need to be specified\n  quarterWidth2:\n    # size doesn't need to be specified\n\n\n\n\nDisplay widgets\n\n\nIndicated via a \ndisplay\n option.\n\n\nwidgets:\n  barChart:\n    display: bar\n\n\n\n\nbar\n - bar chart\n\n\ndigit\n - numerical\n\n\nradar\n - radar chart\n\n\nline\n - line chart\n\n\nlist\n - data table\n\n\nlist-group\n - grouped data table\n\n\npie-chart\n - pie chart\n\n\npolar\n - polar area chart\n\n\nlabel\n - string display\n\n\ngauge\n - gauge\n\n\nindicator\n -  light indicator on/off\n\n\nmap\n - map\n\n\nlink\n - link to a destination (URL)\n\n\nInteractive Widgets\n\n\nIndicated via a \ncontrol\n option.\n\n\nwidgets:\n  controlButton:\n    control: button\n\n\n\n\ninput\n - input field, single or multiple\n\n\nbutton\n - button, single or multiple\n\n\nswitch\n - switch, single or multiple\n\n\nradio\n - radio, single or multiple\n\n\ndropdown\n - dropdown menu\n\n\nrange\n - range slider\n\n\nxy\n - track pad\n\n\nradial\n - joystick, single or multiple\n\n\ncolor\n - color picker\n\n\nWidget Examples\n\n\nDisplays\n\n\nDigit\n\n\n\n\ndigitTest:\n  display: digit\n  type: monitor\n  key: cpu\n  format: round\n  label: cpu\n\n\n\n\nHandling Code\n\n\nmatrix.type('monitor').send({\n  'cpu': 2.4,\n  'memory': 5.4 }\n);  \n\n\n\n\nLabel\n\n\n\n\nlabelTest:\n  display: label\n  type: uv\n  key: risk\n  label: UV Risk\n\n\n\n\nHandling Code\n\n\nmatrix.type('uv').send({\n  'value': 0.56773,\n  'risk': 'Low' }\n);  \n\n\n\n\nBar Chart\n\n\n\n\nbarChartTest:\n  display: bar\n  type: monitor\n  keys: cpu, memory\n  format: avg\n  realtime: false\n  refresh: 60\n  label: Bar Chart\n\n\n\n\nHandling Code\n\n\nmatrix.type('monitor').send({\n  'cpu': 7.03,\n  'memory': 2.30 }\n);  \n\n\n\n\nLine Chart\n\n\n\n\nlineChartTest:\n  display: line\n  type: monitor\n  format: avg\n  keys: cpu, memory\n  realtime: true\n  label: Line Chart\n\n\n\n\nHandling Code\n\n\nmatrix.type('monitor').send({\n  'cpu': 7.03,\n  'memory': 2.30 }\n);  \n\n\n\n\nRadar Chart\n\n\n\n\nradarTest:\n  display: radar\n  type: emotions\n  keys: happy,sad,disgust,surprised,confused,calm,angry\n  label: Emotions\n\n\n\n\nHandling Code\n\n\nmatrix.type('emotions').send({\n  'happy': 67,\n  'sad': 50,\n  'disgust': 78,\n  'surprised': 56,\n  'confused': 86,\n  'calm': 70,\n  'angry': 60 }\n);  \n\n\n\n\nPie Chart\n\n\n\n\npieChartTest:\n  display: pie-chart\n  type: gender\n  keys: women,men\n  label: Gender\n\n\n\n\nHandling Code\n\n\nmatrix.type('gender').send({\n  'women': 76,\n  'men': 45 }\n);  \n\n\n\n\nPolar Chart\n\n\n\n\npolarTest:\n  display: polar\n  type: emotions\n  keys: happy,sad,disgust,surprised,confused,calm,angry\n  label: Emotions\n\n\n\n\nHandling Code\n\n\nmatrix.type('emotions').send({\n  'happy': 67,\n  'sad': 50,\n  'disgust': 78,\n  'surprised': 56,\n  'confused': 86,\n  'calm': 70,\n  'angry': 60 }\n);  \n\n\n\n\nGauge\n\n\n\n\ngaugeTest:\n  display: gauge\n  type: detection\n  keys: views\n  min: 0\n  max: 100\n  label: 'Views'\n\n\n\n\nHandling Code\n\n\nmatrix.type('detection').send({\n  'views': 60,\n  'impressions': 100 }\n);  \n\n\n\n\nIndicator\n\n\n\n\nindicatorTest:\n  display: indicator\n  type: system\n  keys: isOn\n  label: 'Indicator Test'\n\n\n\n\nHandling Code\n\n\nmatrix.type('system').send({\n  'isOn': true}\n);  \n\n\n\n\nMap\n\n\n\n\nmapTest:\n  display: map\n  type: location\n  label: 'Map Test'\n\n\n\n\nHandling Code\n\n\nmatrix.type('location').send({\n  'latitude': 25.791632,\n  'longitude': -80.1414447,\n  'label': 'AdMobilize'}\n);  \n\n\n\n\nLists\n\n\n\n\nlistTest:\n  display: list\n  type: device\n  keys: Hostname,Type,Platform,Arch\n  label: Secret Information\n\n\n\n\nHandling Code\n\n\nmatrix.type('device').send({\n  'Hostname': 'h7n.domain',\n  'Type': 'Darwin',\n  'Platform': 'darwin',\n  'Arch': 'x64'}\n);  \n\n\n\n\nList Group\n\n\nSimple Group\n\n\n\n\ninfo:\n  display: list-group\n  type: vehicleDetection\n  keys: count\n  format: count\n  label: Total\n\n\n\n\nHandling Code\n\n\nmatrix.type('vehicleDetection').send({\n  'zoneId': 'zone1',\n  'count': '4',\n  'speed': '56'}\n);  \n\n\n\n\nGroup by Key\n\n\n\n\ninfo:\n  display: list-group\n  type: device\n  keys: zone, count\n  format: count\n  groupby: zone\n  label: Total\n\n\n\n\nHandling Code\n\n\nmatrix.type('vehicleDetection').send({\n  'zoneId': 'zone1',\n  'count': '4',\n  'speed': '56'}\n);  \n\n\n\n\nLinks\n\n\n\n\nlink:\n  display: link\n  label: \nLink display\n\n  title: \nGoogle\n\n  url: \nhttps://www.google.com\n\n\n\n\n\nInteractive (Controls)\n\n\nInput\n\n\nSingle\n\n\n\n\n  inputTest:\n    control: input\n    event: testInput\n    value: 'type text'\n    label: 'Test Input'\n\n\n\n\nHandling Code\n\n\nmatrix.on('testInput', function(p){\n var text = p.value;\n})\n\n\n\n\nMultiple\n\n\n\n\n  inputMapTest:\n    control: input\n    map:\n      - event: testInput1\n        value: first type text\n      - event: testInput2\n        value: second type text\n    label: Test Input Map\n\n\n\n\nHandling Code\n\n\nmatrix.on('testInput1', function(p){\n var text = p.value;\n})\n\nmatrix.on('testInput2', function(p){\n var text = p.value;\n})\n\n\n\n\n\nButtons\n\n\nSingle\n\n\n\n\n  buttonTest:\n    control: button\n    event: buttonInfo\n    value: Get Secret Information\n    label: Hacking Buttons\n\n\n\n\nHandling Code\n\n\nmatrix.on('buttonInfo', function(){\n  // ...\n})\n\n\n\n\nMultiple\n\n\n\n\n  buttonMapTest:\n    control: button\n    map:\n      - event: buttonUp\n        value: amps+\n      - event: buttonDown\n        value: amps-\n      - event: buttonStart\n        value: begin\n      - event: buttonStop\n        value: end\n      - event: buttonCapture\n        value: capture\n      - event: buttonSlow\n        value: refresh+\n      - event: buttonFast\n        value: refresh-\n    label: Matrix Activation Buttons\n\n\n\n\nHandling Code\n\n\nmatrix.on('buttonUp', function(){\n  // ...\n})\n\nmatrix.on('buttonDown', function(){\n  // ...\n})\n\nmatrix.on('buttonStart', function(){\n  // ...\n})\n\nmatrix.on('buttonStop', function(){\n  // ...\n})\n\nmatrix.on('buttonCapture', function(){\n  // ...\n})\n\nmatrix.on('buttonSlow', function(){\n  // ...\n})\n\nmatrix.on('buttonFast', function(){\n  // ...\n})\n\n\n\n\nSwitch\n\n\nSingle\n\n\n\n\n  switchTest:\n    control: switch\n    event: ledEnabledChanged\n    value: Leds enabled\n    label: Switch Test\n\n\n\n\nHandling Code\n\n\nmatrix.on('ledEnabledChanged', function(p){\n var isOn = p.value;\n})\n\n\n\n\nMultiple\n\n\n\n\n  switchMapTest:\n    control: switch\n    map:\n      - event: ledEnabledChanged\n        value: Leds enabled\n      - event: detectionEnabledChanged\n        value: Detection Enabled\n    label: Switch Map Test\n\n\n\n\nHandling Code\n\n\nmatrix.on('ledEnabledChanged', function(p){\n var isOn = p.value;\n})\n\nmatrix.on('detectionEnabledChanged', function(p){\n var isOn = p.value;\n})\n\n\n\n\nRadio\n\n\n\n\n  radioTest:\n    control: radio\n    map:\n      - event: optionOneSelected\n        value: Option One\n      - event: optionTwoSelected\n        value: Option Two\n    label: Radio Test\n\n\n\n\nHandling Code\n\n\nmatrix.on('optionOneSelected', function(p){\n  // ...\n})\n\nmatrix.on('optionTwoSelected', function(p){\n  // ...\n})\n\n\n\n\nDrop Downs\n\n\n\n\n  dropDownTest:\n    control: dropdown\n    map:\n      - event: optionOneSelected\n        value: Option One\n      - event: optionTwoSelected\n        value: Option Two\n    label: Dropdown Test\n\n\n\n\nHandling Code\n\n\nmatrix.on('optionOneSelected', function(){\n //...\n})\n\nmatrix.on('optionTwoSelected', function(){\n //...\n})\n\n\n\n\nRange\n\n\n\n\n  rangeTest:\n    control: range\n    event: rangeChanged\n    min: 0\n    max: 35\n    label: Range Test\n\n\n\n\nHandling Code\n\n\nmatrix.on('rangeChanged', function(p){\n var value = p.value;\n})\n\n\n\n\nXY\n\n\n\n\n  xyTest:\n    control: xy\n    event: xyChanging\n    value: 'xy'\n    xMax: 100\n    yMax: 50\n    label: Test XY\n\n\n\n\nHandling Code\n\n\nmatrix.on('xyChanging', function(p){\n var x = p.value.x;\n var y = p.value.y;\n})\n\n\n\n\nRadial\n\n\nSingle\n\n\n\n\n  radial:\n    control: radial\n    event: radialChanging\n    label: Radial Test\n\n\n\n\nHandling Code\n\n\nmatrix.on('radialChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n})\n\n\n\n\nMultiple\n\n\n\n\n  radialMap:\n    control: radial\n    map:\n    - event: radialRChanging\n      value: right\n    - event: radialLChanging\n      value: left\n    label: Radial Map Test\n\n\n\n\nHandling Code\n\n\nmatrix.on('radialRChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n})\n\nmatrix.on('radialLChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n})\n\n\n\n\nColor\n\n\n \n \n\n\n  color:\n    control: color\n    event: colorChange\n    value: 'color'\n    label: 'Change MATRIX color'\n\n\n\n\nHandling Code\n\n\nmatrix.on('colorChange', function(color){\n  color = color.value;\n  matrix.led(color).render();\n});\n\n\n\n\nResponsive Data Flow\n\n\nmatrix.on('buttonInfo', function(){\n  matrix.type('device').send({\n    'os_hostname': os.hostname(),\n    'os_type': os.type(),\n    'os_platform': os.platform(),\n    'os_arch': os.arch()\n  });\n})\n\n\n\n\nWhen \nbuttonInfo\n is triggered, respond with information with a type \ndevice\n.\n\n\nThe list looks for\n\n\nwidgets:\n  list:\n    type: device\n\n\n\n\nThe \nlist\n widget displays information of type \ndevice\n.", 
            "title": "Widgets"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#widgets", 
            "text": "Defined in config.yaml, widgets display information from the device and allow you to send information via familiar interfaces, like dropdowns and buttons.", 
            "title": "Widgets"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#layout", 
            "text": "For details on how to arrange widgets on a dashboard, see  Screens  Widgets are basically configuration objects which can be defined with the following options.", 
            "title": "Layout"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#options", 
            "text": "", 
            "title": "Options"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#all-widgets", 
            "text": "label  - text label for this widget box   Widgets come in two forms:  Display Widgets - Displays data from an application  Interactive Widgets - Sends real-time events to an application", 
            "title": "All Widgets"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#display-widget-options", 
            "text": "Display widgets, like tables, charts and value outputs are only concerned with what data to display and how to display it.   display  - which display widget to load   key / keys  - show these keys from the data payload   type  - select keys from this data segment (see  Overview   Sending Data  )   format  - filter the data. choose from  count ,  sum ,  avg ,  percent ,  max ,  min ,  fixed ,  round .   realtime  - defaults to true. set to false and use refresh option for manual updates.   refresh  - how many seconds between data refresh. not set by default. use with realtime: false.", 
            "title": "Display Widget Options"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#interactive-widget-options", 
            "text": "control  - which interactive widget to load  trigger  - the event to listen for in your application ( see  Reference   Crosstalk )  value  - on button widgets, what text should be in the button  map  - on button widgets, a collection of  value: trigger  where value is the button text, and trigger is the event fired", 
            "title": "Interactive Widget Options"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#data-operations", 
            "text": "Using  format , data operations can be applied to the data for each Display Widget. The current widget configuration supports the operations:  count ,  sum ,  avg ,  percent ,  max ,  min ,  fixed ,  round .", 
            "title": "Data Operations"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#data-handling", 
            "text": "The dashboard holds a central data store which the widgets receive or request data from.  Default operation is for a widget to be updated with data in real time. This is represented by enabling the option  realtime :  // To enable realtime updates\nwidgets:\n  testWidget:\n     realtime: true  The alternative is to have a widget manually refresh it's data on an interval by disabling  realtime . Default  refresh  is 5 seconds. If you wanted to refresh a graph every minute:  // To disable realtime updates\nwidgets:\n  testWidget:\n     realtime: false\n     refresh: 60", 
            "title": "Data Handling"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#widget-size", 
            "text": "Widgets can be resized horizontally with the  size  attribute.  Size is simply the percentage width you would like the widget to take. If size is not specified, then the widget will take up a equal proportion of the remaining width.", 
            "title": "Widget Size"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#example", 
            "text": "widgets:\n  halfWidth:\n    size: 50\n  quarterWidth:\n    size: 25\n    # size doesn't need to be specified\n  quarterWidth2:\n    # size doesn't need to be specified", 
            "title": "Example"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#display-widgets", 
            "text": "Indicated via a  display  option.  widgets:\n  barChart:\n    display: bar  bar  - bar chart  digit  - numerical  radar  - radar chart  line  - line chart  list  - data table  list-group  - grouped data table  pie-chart  - pie chart  polar  - polar area chart  label  - string display  gauge  - gauge  indicator  -  light indicator on/off  map  - map  link  - link to a destination (URL)", 
            "title": "Display widgets"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#interactive-widgets", 
            "text": "Indicated via a  control  option.  widgets:\n  controlButton:\n    control: button  input  - input field, single or multiple  button  - button, single or multiple  switch  - switch, single or multiple  radio  - radio, single or multiple  dropdown  - dropdown menu  range  - range slider  xy  - track pad  radial  - joystick, single or multiple  color  - color picker", 
            "title": "Interactive Widgets"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#widget-examples", 
            "text": "", 
            "title": "Widget Examples"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#displays", 
            "text": "", 
            "title": "Displays"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#digit", 
            "text": "digitTest:\n  display: digit\n  type: monitor\n  key: cpu\n  format: round\n  label: cpu", 
            "title": "Digit"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code", 
            "text": "matrix.type('monitor').send({\n  'cpu': 2.4,\n  'memory': 5.4 }\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#label", 
            "text": "labelTest:\n  display: label\n  type: uv\n  key: risk\n  label: UV Risk", 
            "title": "Label"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_1", 
            "text": "matrix.type('uv').send({\n  'value': 0.56773,\n  'risk': 'Low' }\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#bar-chart", 
            "text": "barChartTest:\n  display: bar\n  type: monitor\n  keys: cpu, memory\n  format: avg\n  realtime: false\n  refresh: 60\n  label: Bar Chart", 
            "title": "Bar Chart"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_2", 
            "text": "matrix.type('monitor').send({\n  'cpu': 7.03,\n  'memory': 2.30 }\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#line-chart", 
            "text": "lineChartTest:\n  display: line\n  type: monitor\n  format: avg\n  keys: cpu, memory\n  realtime: true\n  label: Line Chart", 
            "title": "Line Chart"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_3", 
            "text": "matrix.type('monitor').send({\n  'cpu': 7.03,\n  'memory': 2.30 }\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#radar-chart", 
            "text": "radarTest:\n  display: radar\n  type: emotions\n  keys: happy,sad,disgust,surprised,confused,calm,angry\n  label: Emotions", 
            "title": "Radar Chart"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_4", 
            "text": "matrix.type('emotions').send({\n  'happy': 67,\n  'sad': 50,\n  'disgust': 78,\n  'surprised': 56,\n  'confused': 86,\n  'calm': 70,\n  'angry': 60 }\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#pie-chart", 
            "text": "pieChartTest:\n  display: pie-chart\n  type: gender\n  keys: women,men\n  label: Gender", 
            "title": "Pie Chart"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_5", 
            "text": "matrix.type('gender').send({\n  'women': 76,\n  'men': 45 }\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#polar-chart", 
            "text": "polarTest:\n  display: polar\n  type: emotions\n  keys: happy,sad,disgust,surprised,confused,calm,angry\n  label: Emotions", 
            "title": "Polar Chart"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_6", 
            "text": "matrix.type('emotions').send({\n  'happy': 67,\n  'sad': 50,\n  'disgust': 78,\n  'surprised': 56,\n  'confused': 86,\n  'calm': 70,\n  'angry': 60 }\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#gauge", 
            "text": "gaugeTest:\n  display: gauge\n  type: detection\n  keys: views\n  min: 0\n  max: 100\n  label: 'Views'", 
            "title": "Gauge"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_7", 
            "text": "matrix.type('detection').send({\n  'views': 60,\n  'impressions': 100 }\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#indicator", 
            "text": "indicatorTest:\n  display: indicator\n  type: system\n  keys: isOn\n  label: 'Indicator Test'", 
            "title": "Indicator"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_8", 
            "text": "matrix.type('system').send({\n  'isOn': true}\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#map", 
            "text": "mapTest:\n  display: map\n  type: location\n  label: 'Map Test'", 
            "title": "Map"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_9", 
            "text": "matrix.type('location').send({\n  'latitude': 25.791632,\n  'longitude': -80.1414447,\n  'label': 'AdMobilize'}\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#lists", 
            "text": "listTest:\n  display: list\n  type: device\n  keys: Hostname,Type,Platform,Arch\n  label: Secret Information", 
            "title": "Lists"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_10", 
            "text": "matrix.type('device').send({\n  'Hostname': 'h7n.domain',\n  'Type': 'Darwin',\n  'Platform': 'darwin',\n  'Arch': 'x64'}\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#list-group", 
            "text": "", 
            "title": "List Group"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#simple-group", 
            "text": "info:\n  display: list-group\n  type: vehicleDetection\n  keys: count\n  format: count\n  label: Total", 
            "title": "Simple Group"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_11", 
            "text": "matrix.type('vehicleDetection').send({\n  'zoneId': 'zone1',\n  'count': '4',\n  'speed': '56'}\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#group-by-key", 
            "text": "info:\n  display: list-group\n  type: device\n  keys: zone, count\n  format: count\n  groupby: zone\n  label: Total", 
            "title": "Group by Key"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_12", 
            "text": "matrix.type('vehicleDetection').send({\n  'zoneId': 'zone1',\n  'count': '4',\n  'speed': '56'}\n);", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#links", 
            "text": "link:\n  display: link\n  label:  Link display \n  title:  Google \n  url:  https://www.google.com", 
            "title": "Links"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#interactive-controls", 
            "text": "", 
            "title": "Interactive (Controls)"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#input", 
            "text": "", 
            "title": "Input"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#single", 
            "text": "inputTest:\n    control: input\n    event: testInput\n    value: 'type text'\n    label: 'Test Input'", 
            "title": "Single"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_13", 
            "text": "matrix.on('testInput', function(p){\n var text = p.value;\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#multiple", 
            "text": "inputMapTest:\n    control: input\n    map:\n      - event: testInput1\n        value: first type text\n      - event: testInput2\n        value: second type text\n    label: Test Input Map", 
            "title": "Multiple"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_14", 
            "text": "matrix.on('testInput1', function(p){\n var text = p.value;\n})\n\nmatrix.on('testInput2', function(p){\n var text = p.value;\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#buttons", 
            "text": "", 
            "title": "Buttons"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#single_1", 
            "text": "buttonTest:\n    control: button\n    event: buttonInfo\n    value: Get Secret Information\n    label: Hacking Buttons", 
            "title": "Single"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_15", 
            "text": "matrix.on('buttonInfo', function(){\n  // ...\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#multiple_1", 
            "text": "buttonMapTest:\n    control: button\n    map:\n      - event: buttonUp\n        value: amps+\n      - event: buttonDown\n        value: amps-\n      - event: buttonStart\n        value: begin\n      - event: buttonStop\n        value: end\n      - event: buttonCapture\n        value: capture\n      - event: buttonSlow\n        value: refresh+\n      - event: buttonFast\n        value: refresh-\n    label: Matrix Activation Buttons", 
            "title": "Multiple"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_16", 
            "text": "matrix.on('buttonUp', function(){\n  // ...\n})\n\nmatrix.on('buttonDown', function(){\n  // ...\n})\n\nmatrix.on('buttonStart', function(){\n  // ...\n})\n\nmatrix.on('buttonStop', function(){\n  // ...\n})\n\nmatrix.on('buttonCapture', function(){\n  // ...\n})\n\nmatrix.on('buttonSlow', function(){\n  // ...\n})\n\nmatrix.on('buttonFast', function(){\n  // ...\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#switch", 
            "text": "", 
            "title": "Switch"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#single_2", 
            "text": "switchTest:\n    control: switch\n    event: ledEnabledChanged\n    value: Leds enabled\n    label: Switch Test", 
            "title": "Single"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_17", 
            "text": "matrix.on('ledEnabledChanged', function(p){\n var isOn = p.value;\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#multiple_2", 
            "text": "switchMapTest:\n    control: switch\n    map:\n      - event: ledEnabledChanged\n        value: Leds enabled\n      - event: detectionEnabledChanged\n        value: Detection Enabled\n    label: Switch Map Test", 
            "title": "Multiple"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_18", 
            "text": "matrix.on('ledEnabledChanged', function(p){\n var isOn = p.value;\n})\n\nmatrix.on('detectionEnabledChanged', function(p){\n var isOn = p.value;\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#radio", 
            "text": "radioTest:\n    control: radio\n    map:\n      - event: optionOneSelected\n        value: Option One\n      - event: optionTwoSelected\n        value: Option Two\n    label: Radio Test", 
            "title": "Radio"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_19", 
            "text": "matrix.on('optionOneSelected', function(p){\n  // ...\n})\n\nmatrix.on('optionTwoSelected', function(p){\n  // ...\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#drop-downs", 
            "text": "dropDownTest:\n    control: dropdown\n    map:\n      - event: optionOneSelected\n        value: Option One\n      - event: optionTwoSelected\n        value: Option Two\n    label: Dropdown Test", 
            "title": "Drop Downs"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_20", 
            "text": "matrix.on('optionOneSelected', function(){\n //...\n})\n\nmatrix.on('optionTwoSelected', function(){\n //...\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#range", 
            "text": "rangeTest:\n    control: range\n    event: rangeChanged\n    min: 0\n    max: 35\n    label: Range Test", 
            "title": "Range"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_21", 
            "text": "matrix.on('rangeChanged', function(p){\n var value = p.value;\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#xy", 
            "text": "xyTest:\n    control: xy\n    event: xyChanging\n    value: 'xy'\n    xMax: 100\n    yMax: 50\n    label: Test XY", 
            "title": "XY"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_22", 
            "text": "matrix.on('xyChanging', function(p){\n var x = p.value.x;\n var y = p.value.y;\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#radial", 
            "text": "", 
            "title": "Radial"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#single_3", 
            "text": "radial:\n    control: radial\n    event: radialChanging\n    label: Radial Test", 
            "title": "Single"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_23", 
            "text": "matrix.on('radialChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#multiple_3", 
            "text": "radialMap:\n    control: radial\n    map:\n    - event: radialRChanging\n      value: right\n    - event: radialLChanging\n      value: left\n    label: Radial Map Test", 
            "title": "Multiple"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_24", 
            "text": "matrix.on('radialRChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n})\n\nmatrix.on('radialLChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n})", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#color", 
            "text": "color:\n    control: color\n    event: colorChange\n    value: 'color'\n    label: 'Change MATRIX color'", 
            "title": "Color"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#handling-code_25", 
            "text": "matrix.on('colorChange', function(color){\n  color = color.value;\n  matrix.led(color).render();\n});", 
            "title": "Handling Code"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#responsive-data-flow", 
            "text": "matrix.on('buttonInfo', function(){\n  matrix.type('device').send({\n    'os_hostname': os.hostname(),\n    'os_type': os.type(),\n    'os_platform': os.platform(),\n    'os_arch': os.arch()\n  });\n})  When  buttonInfo  is triggered, respond with information with a type  device .  The list looks for  widgets:\n  list:\n    type: device  The  list  widget displays information of type  device .", 
            "title": "Responsive Data Flow"
        }, 
        {
            "location": "/matrix-os/troubleshooting/", 
            "text": "Troubleshooting\n\n\nPlease visit our community support forums at:\n\ncommunity.matrix.one\n\n\nStarting MOS from your device, you will have access to more error messages with \nDEBUG=*,-engine*,-Component*\n prepended to the commands presented below. \nengine\n, refers to \nengine.io\n, sockets, and \nComponent\n, is very verbose hardware communications, disable these filters as necessary.\n\n\nTest applications\n\n\nSeveral applications are available in the \nMATRIX App Store\n.\n\n\n\n\nsensorTest\n - Tests all sensors\n\n\nclock\n - Runs a clock which tests the LEDs\n\n\nfaceTest\n - Face detection services via \nmalos-eye\n.\n\n\n\n\nLights are spinning, but don't stop\n\n\nExits with message\n\n\nDevice Error undefined\n\n\n\n\nSolution. Run again with correct environment set. Users and made in \ndev\n environment do not\u00a0cross over to \nproduction\n.\n\n\nNODE_ENV =dev node index.js\n\n\n\n\nMATRIX Vision Services not working\n\n\nMessages appear when \nmalos_eye\n is running, and hardware is not properly installed. Please shut off device, firmly reconnect the camera connection, and restart.\n\n\nVIDIOC_STREAMON: Invalid argument\nVIDIOC_STREAMON: Invalid argument\n\nMessage received: gesture error: Could not read frame\nMessage received: gesture error: 1, Could not send update for GESTURE driver.\n\nselect timeout\nselect timeout\nselect timeout\nselect timeout", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-os/troubleshooting/#troubleshooting", 
            "text": "Please visit our community support forums at: community.matrix.one  Starting MOS from your device, you will have access to more error messages with  DEBUG=*,-engine*,-Component*  prepended to the commands presented below.  engine , refers to  engine.io , sockets, and  Component , is very verbose hardware communications, disable these filters as necessary.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-os/troubleshooting/#test-applications", 
            "text": "Several applications are available in the  MATRIX App Store .   sensorTest  - Tests all sensors  clock  - Runs a clock which tests the LEDs  faceTest  - Face detection services via  malos-eye .", 
            "title": "Test applications"
        }, 
        {
            "location": "/matrix-os/troubleshooting/#lights-are-spinning-but-dont-stop", 
            "text": "Exits with message  Device Error undefined  Solution. Run again with correct environment set. Users and made in  dev  environment do not\u00a0cross over to  production .  NODE_ENV =dev node index.js", 
            "title": "Lights are spinning, but don't stop"
        }, 
        {
            "location": "/matrix-os/troubleshooting/#matrix-vision-services-not-working", 
            "text": "Messages appear when  malos_eye  is running, and hardware is not properly installed. Please shut off device, firmly reconnect the camera connection, and restart.  VIDIOC_STREAMON: Invalid argument\nVIDIOC_STREAMON: Invalid argument\n\nMessage received: gesture error: Could not read frame\nMessage received: gesture error: 1, Could not send update for GESTURE driver.\n\nselect timeout\nselect timeout\nselect timeout\nselect timeout", 
            "title": "MATRIX Vision Services not working"
        }, 
        {
            "location": "/matrix-core/", 
            "text": "MATRIX CORE\n\n\nMATRIX CORE provides \nProtobufs\n over \nZeroMQ\n. An intended target for this layer is \nMATRIX Open System\n. You can also use CORE to query sensors and control any MATRIX Device from any language that supports protocol buffers (version 3.X) and 0MQ. \n\n\nConnections to CORE can be made both from localhost (127.0.0.1) and from remote computers that are in the same network.\n\n\nSpecification\n\n\nOur \nProtocol Buffer Specifications\n are currently defined in \nproto\n files. Please use these files to inform your ZMQ payloads. More information can be found in the examples below.\n\n\nInstallation\n\n\nSee \nInstallation\n\n\nExamples\n\n\n\n\nSee \nJavascript Test Example\n\n\nSee \nPython Test Example\n\n\n\n\nProtocol\n\n\nAll the CORE drivers use the same protocol to interact with other programs. Drivers allow read-only,\nwrite-only or read-write modes.\n\n\nCORE uses 0MQ to transfer information from and to the client interfacing with it. Each CORE driver has a base 0MQ port.\nThis is the current list of base ports (This is printed by CORE when it is started from the console):\n\n\nRegistered driver IMU with port 20013.\nRegistered driver Humidity with port 20017.\nRegistered driver Everloop with port 20021.\nRegistered driver Pressure with port 20025.\nRegistered driver UV with port 20029.\nRegistered driver ZigbeeBulb with port 20033.\nRegistered driver MicArray_Alsa with port 20037.\nRegistered driver Lirc with port 20041.\n\n\n\n\nEach port reserves a range of 4 ports that are used for a driver. They are described in the following sections.\n\n\nBase port\n\n\nThis is the first port of the driver and the one used to denote the \ndriver port\n.\nIt is used to configure the device and it makes sense for the devices that support configuration.\nIt is a 0MQ PULL port.\nTo send a configuration you need to send a valid message (serialized to a string) for the given driver. For instance, the\nEverloop driver (LED array) uses a configuration message to set the LEDs.\n\n\nThe message is named EverloopImage and it is in the file \ndriver.proto\n.\nThe message follows:\n\n\nmessage LedValue {\n  uint32 red = 1;\n  uint32 green = 2;\n  uint32 blue = 3;\n  uint32 white = 4;\n}\n\n// The led array.\nmessage EverloopImage {\n  repeated LedValue led = 1;\n}\n\n\n\n\nIn order to turn all the LEDs RED you need to add 35 messages of type LedValue to the EverloopImage message.\nEach of the LedValue messages would need to have the following values:\n\n\n\n\nred: 10\n\n\ngreen: 0\n\n\nblue: 0\n\n\nwhite: 0\n\n\n\n\nThe valid values for led intensities range from 0 to 255, but we set red to 10 because this value is bright enough.\n\n\nOnce the message of type Everloop Image is filled out it needs to be serialized as a string and sent to the 0MQ configuration port.\n\n\nIf invalid values are used for the LED values of the number of LED values inside of EverloopImage is not 35 the configuration will be discarded and an error message will be generated and sent to the error channel described below.\n\n\nError port\n\n\nPrograms can subscribe to the 0MQ error port. It is a PUSH port. The port number is obtained by adding 2 to the base port (Also known as driver port).\nThe errors are returned as strings but there's a pending task to change the error messages to a protocol buffer (\ntrack issue\n).\nPlease do not depend on errors reported as strings as we will change the errors to protocol buffers soon.\n\n\nKeep-alive port\n\n\nThe port number is obtained by adding 1 to the base port (Also known as driver port). It is a PUSH port.\n\n\nIn order to save CPU power and other resources some drivers require applications to send pings to it in order to keep them alive.\nFor most driveres it means that the driver keeps sending updates as fast as they have been configured to do so.\nThe Everloop driver doesn't require keep-alive messages. The IMU driver does.\n\n\nDrivers that need keep-alive messages can be configured using the message that is used for all the configurations.\nThe way to do it is set relevant field while doing other driver specific configuration (if this is required).\n\n\n\nmessage DriverConfig {\n  // Delay between updates. In seconds.\n  float delay_between_updates = 1;\n  // Timeout after last ping.\n  float timeout_after_last_ping = 2;\n\n  // More fields here -- Omitted.\n}\n\n\n\n\nThe field timeout_after_last_ping defaults to 5 seconds and it can be set during driver configuration.\nIf a driver doesn't receive Clive messages after \ntimeout_after_last_ping\n seconds  it will stop sending updates.\nThis field is ignored by drivers that do not require keep alive messages. For instance, the Everloop driver ignores this setting.\n\n\nAfter the setting is done (or not if the default value of 5 seconds is OK) you can start sending keepalive messages to the\ndriver by sending messages to the respective 0MQ port. Any message that is sent to this port will be discarded, so the\nempty string \"\" makes for a good keep-alive message.\n\n\nData update port\n\n\nThe port number is obtained by adding 3 to the base port (Also known as driver port). This port is used by drivers that\nsend data (for instance Humidity and UV). Each driver uses a different message to report data to programs that subscribe\nexpecting updates.\n\n\nLet's use the UV driver as an example. The relevant message:\n\n\n// Basic UV radiation lecture.\nmessage UV{\n  // UV index.\n  float uv_index = 1;\n\n  // Risk of harm from unprotected sun exposure, for the average adult.\n  // According to the OMS table. https://www.epa.gov/sunsafety/uv-index-scale-0\n  string oms_risk = 2;\n}\n\n\n\n\nDrivers that subscribe to updates via 0MQ will receive a string with serialized messages of type UV (within the matrix_malos namespace).\nThen this message needs to be deserialized and the values can be used.\n\n\nWorkflow\n\n\nWrapping up the protocol section, a program that talks to CORE can:\n\n\n\n\nConfigure a driver if needed. Or configure it many times if the drivers needs it.\n\n\nSubscribe to error messages if it is interested in them.\n\n\nSends keep-alive messages if those are needed by the driver to remain active.\n\n\nSubscribe to updates from the driver if the drivers produces them.\n\n\n\n\nInterfaces\n\n\n\n\nEverloop\n\n\nHumidity\n\n\nIMU\n\n\nIR\n\n\nPressure\n\n\nUV\n\n\nGPIO\n\n\n\n\nExamples\n\n\nNote:\n pre-requisite is NodeJS. Don't use the one shipped with Raspbian because it's a bit old. If you don't have it, please check a recipe included below.\n\n\ngit clone https://github.com/matrix-io/matrix-creator-malos.git \n cd matrix-creator-malos\ngit submodule init \n git submodule update\ncd src/js_test\n\n// humidity, temperature\nnode test_humidity.js \n\n// inertial measurement unit\nnode test_imu.js \n\n// pressure, altitude\nnode test_pressure.js \n\n// uv index, uv range\nnode test_uv.js\n\n\n\n\n\n\nHistory\n\n\nMATRIX CORE was previously packaged as MALOS and MALOS EYE.", 
            "title": "MATRIX CORE"
        }, 
        {
            "location": "/matrix-core/#matrix-core", 
            "text": "MATRIX CORE provides  Protobufs  over  ZeroMQ . An intended target for this layer is  MATRIX Open System . You can also use CORE to query sensors and control any MATRIX Device from any language that supports protocol buffers (version 3.X) and 0MQ.   Connections to CORE can be made both from localhost (127.0.0.1) and from remote computers that are in the same network.", 
            "title": "MATRIX CORE"
        }, 
        {
            "location": "/matrix-core/#specification", 
            "text": "Our  Protocol Buffer Specifications  are currently defined in  proto  files. Please use these files to inform your ZMQ payloads. More information can be found in the examples below.", 
            "title": "Specification"
        }, 
        {
            "location": "/matrix-core/#installation", 
            "text": "See  Installation", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-core/#examples", 
            "text": "See  Javascript Test Example  See  Python Test Example", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-core/#protocol", 
            "text": "All the CORE drivers use the same protocol to interact with other programs. Drivers allow read-only,\nwrite-only or read-write modes.  CORE uses 0MQ to transfer information from and to the client interfacing with it. Each CORE driver has a base 0MQ port.\nThis is the current list of base ports (This is printed by CORE when it is started from the console):  Registered driver IMU with port 20013.\nRegistered driver Humidity with port 20017.\nRegistered driver Everloop with port 20021.\nRegistered driver Pressure with port 20025.\nRegistered driver UV with port 20029.\nRegistered driver ZigbeeBulb with port 20033.\nRegistered driver MicArray_Alsa with port 20037.\nRegistered driver Lirc with port 20041.  Each port reserves a range of 4 ports that are used for a driver. They are described in the following sections.", 
            "title": "Protocol"
        }, 
        {
            "location": "/matrix-core/#base-port", 
            "text": "This is the first port of the driver and the one used to denote the  driver port .\nIt is used to configure the device and it makes sense for the devices that support configuration.\nIt is a 0MQ PULL port.\nTo send a configuration you need to send a valid message (serialized to a string) for the given driver. For instance, the\nEverloop driver (LED array) uses a configuration message to set the LEDs.  The message is named EverloopImage and it is in the file  driver.proto .\nThe message follows:  message LedValue {\n  uint32 red = 1;\n  uint32 green = 2;\n  uint32 blue = 3;\n  uint32 white = 4;\n}\n\n// The led array.\nmessage EverloopImage {\n  repeated LedValue led = 1;\n}  In order to turn all the LEDs RED you need to add 35 messages of type LedValue to the EverloopImage message.\nEach of the LedValue messages would need to have the following values:   red: 10  green: 0  blue: 0  white: 0   The valid values for led intensities range from 0 to 255, but we set red to 10 because this value is bright enough.  Once the message of type Everloop Image is filled out it needs to be serialized as a string and sent to the 0MQ configuration port.  If invalid values are used for the LED values of the number of LED values inside of EverloopImage is not 35 the configuration will be discarded and an error message will be generated and sent to the error channel described below.", 
            "title": "Base port"
        }, 
        {
            "location": "/matrix-core/#error-port", 
            "text": "Programs can subscribe to the 0MQ error port. It is a PUSH port. The port number is obtained by adding 2 to the base port (Also known as driver port).\nThe errors are returned as strings but there's a pending task to change the error messages to a protocol buffer ( track issue ).\nPlease do not depend on errors reported as strings as we will change the errors to protocol buffers soon.", 
            "title": "Error port"
        }, 
        {
            "location": "/matrix-core/#keep-alive-port", 
            "text": "The port number is obtained by adding 1 to the base port (Also known as driver port). It is a PUSH port.  In order to save CPU power and other resources some drivers require applications to send pings to it in order to keep them alive.\nFor most driveres it means that the driver keeps sending updates as fast as they have been configured to do so.\nThe Everloop driver doesn't require keep-alive messages. The IMU driver does.  Drivers that need keep-alive messages can be configured using the message that is used for all the configurations.\nThe way to do it is set relevant field while doing other driver specific configuration (if this is required).  \nmessage DriverConfig {\n  // Delay between updates. In seconds.\n  float delay_between_updates = 1;\n  // Timeout after last ping.\n  float timeout_after_last_ping = 2;\n\n  // More fields here -- Omitted.\n}  The field timeout_after_last_ping defaults to 5 seconds and it can be set during driver configuration.\nIf a driver doesn't receive Clive messages after  timeout_after_last_ping  seconds  it will stop sending updates.\nThis field is ignored by drivers that do not require keep alive messages. For instance, the Everloop driver ignores this setting.  After the setting is done (or not if the default value of 5 seconds is OK) you can start sending keepalive messages to the\ndriver by sending messages to the respective 0MQ port. Any message that is sent to this port will be discarded, so the\nempty string \"\" makes for a good keep-alive message.", 
            "title": "Keep-alive port"
        }, 
        {
            "location": "/matrix-core/#data-update-port", 
            "text": "The port number is obtained by adding 3 to the base port (Also known as driver port). This port is used by drivers that\nsend data (for instance Humidity and UV). Each driver uses a different message to report data to programs that subscribe\nexpecting updates.  Let's use the UV driver as an example. The relevant message:  // Basic UV radiation lecture.\nmessage UV{\n  // UV index.\n  float uv_index = 1;\n\n  // Risk of harm from unprotected sun exposure, for the average adult.\n  // According to the OMS table. https://www.epa.gov/sunsafety/uv-index-scale-0\n  string oms_risk = 2;\n}  Drivers that subscribe to updates via 0MQ will receive a string with serialized messages of type UV (within the matrix_malos namespace).\nThen this message needs to be deserialized and the values can be used.", 
            "title": "Data update port"
        }, 
        {
            "location": "/matrix-core/#workflow", 
            "text": "Wrapping up the protocol section, a program that talks to CORE can:   Configure a driver if needed. Or configure it many times if the drivers needs it.  Subscribe to error messages if it is interested in them.  Sends keep-alive messages if those are needed by the driver to remain active.  Subscribe to updates from the driver if the drivers produces them.", 
            "title": "Workflow"
        }, 
        {
            "location": "/matrix-core/#interfaces", 
            "text": "Everloop  Humidity  IMU  IR  Pressure  UV  GPIO", 
            "title": "Interfaces"
        }, 
        {
            "location": "/matrix-core/#examples_1", 
            "text": "Note:  pre-requisite is NodeJS. Don't use the one shipped with Raspbian because it's a bit old. If you don't have it, please check a recipe included below.  git clone https://github.com/matrix-io/matrix-creator-malos.git   cd matrix-creator-malos\ngit submodule init   git submodule update\ncd src/js_test\n\n// humidity, temperature\nnode test_humidity.js \n\n// inertial measurement unit\nnode test_imu.js \n\n// pressure, altitude\nnode test_pressure.js \n\n// uv index, uv range\nnode test_uv.js", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-core/#history", 
            "text": "MATRIX CORE was previously packaged as MALOS and MALOS EYE.", 
            "title": "History"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/", 
            "text": "Prerequisites\n\n\nHardware\n\n\n\n\nRaspberry Pi with MATRIX Creator\n\n\nSD Card with \nMATRIX CORE installed\n\n\n\n\nDevelopment Prerequisites\n\n\n\n\nLanguage \nsupported by ZeroMQ\n\n\nProtocol Buffers\n\n\n\n\nContinue\n\n\n\n\nGet your Pi ready at \ninstallation\n.\n\n\nDo \nHello World\n\n\nTry \nJavaScript\n or \nPython\n tests.\n\n\nWrite and run your own CORE-enabled software by using our \nReference\n documentation.", 
            "title": "Prerequisities"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/#prerequisites", 
            "text": "", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/#hardware", 
            "text": "Raspberry Pi with MATRIX Creator  SD Card with  MATRIX CORE installed", 
            "title": "Hardware"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/#development-prerequisites", 
            "text": "Language  supported by ZeroMQ  Protocol Buffers", 
            "title": "Development Prerequisites"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/#continue", 
            "text": "Get your Pi ready at  installation .  Do  Hello World  Try  JavaScript  or  Python  tests.  Write and run your own CORE-enabled software by using our  Reference  documentation.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/", 
            "text": "Installation\n\n\n# Add rep and key\ncurl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add -\necho \ndeb https://apt.matrix.one/raspbian $(lsb_release -sc) main\n | sudo tee /etc/apt/sources.list.d/matrixlabs.list\n# update \n upgrade\nsudo apt-get update;\nsudo apt-get upgrade;\n# install malos package\nsudo apt-get install matrixio-malos\n# reboot\nsudo reboot\n\n\n\n\nCORE should be running on next boot.\n\n\nUpgrades\n\n\nIf you need to upgrade your MATRIX CORE package at any time, please run the following commands and restart.\n\n\nsudo apt-get update;\nsudo apt-get upgrade;\nsudo shutdown -r now;\n\n\n\n\nStart / Stop manually\n\n\nCORE runs as a service after boot. If you need to stop it use:\n\n\nsudo pkill -9 malos\n\n\n\n\nTo manually run it back again use:\n\n\nmalos \n\n\n\n\n\nThe output will be similar to:\n\n\npi@raspberrypi:~ $ malos \n\n[1] 24343\npi@raspberrypi:~ $ **************\nMALOS starting\n**************\n\nYou can query specific driver info using port 20012.\nRegistered driver IMU with port 20013.\nRegistered driver Humidity with port 20017.\nRegistered driver Everloop with port 20021.\nRegistered driver Pressure with port 20025.\nRegistered driver UV with port 20029.\nRegistered driver MicArray_Alsa with port 20037.\nRegistered driver Servo with port 20045.\nRegistered driver Gpio with port 20049.\n\npi@raspberrypi:~ $\n\n\n\n\nContinue\n\n\n\n\nDo \nHello World\n\n\nTry \nJavaScript\n or \nPython\n tests.\n\n\nWrite and run your own CORE-enabled software by using our \nReference\n documentation.", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/#installation", 
            "text": "# Add rep and key\ncurl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add -\necho  deb https://apt.matrix.one/raspbian $(lsb_release -sc) main  | sudo tee /etc/apt/sources.list.d/matrixlabs.list\n# update   upgrade\nsudo apt-get update;\nsudo apt-get upgrade;\n# install malos package\nsudo apt-get install matrixio-malos\n# reboot\nsudo reboot  CORE should be running on next boot.", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/#upgrades", 
            "text": "If you need to upgrade your MATRIX CORE package at any time, please run the following commands and restart.  sudo apt-get update;\nsudo apt-get upgrade;\nsudo shutdown -r now;", 
            "title": "Upgrades"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/#start-stop-manually", 
            "text": "CORE runs as a service after boot. If you need to stop it use:  sudo pkill -9 malos  To manually run it back again use:  malos    The output will be similar to:  pi@raspberrypi:~ $ malos  \n[1] 24343\npi@raspberrypi:~ $ **************\nMALOS starting\n**************\n\nYou can query specific driver info using port 20012.\nRegistered driver IMU with port 20013.\nRegistered driver Humidity with port 20017.\nRegistered driver Everloop with port 20021.\nRegistered driver Pressure with port 20025.\nRegistered driver UV with port 20029.\nRegistered driver MicArray_Alsa with port 20037.\nRegistered driver Servo with port 20045.\nRegistered driver Gpio with port 20049.\n\npi@raspberrypi:~ $", 
            "title": "Start / Stop manually"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/#continue", 
            "text": "Do  Hello World  Try  JavaScript  or  Python  tests.  Write and run your own CORE-enabled software by using our  Reference  documentation.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/", 
            "text": "Download and Prepare\n\n\n\n\nYou need \nNodeJS, and the Node Package Manager (npm)\n installed on the Raspberry Pi.\n\n\n\n\ngit clone https://github.com/matrix-io/matrix-creator-malos;\ncd matrix-creator-malos;\ngit submodule update --init;\ncd src/js_test;\nnpm install;\n\n\n\n\nExamples\n\n\nMATRIX CORE is the program that sits between the low level hardware layer and MATRIX OS. This program allows MATRIX OS to access the board hardware via ZeroMQ sockets. You can also use it directly, as it is done with the examples below. The The IPs used in the examples are 127.0.0.1. Remember to edit them if you're accessing the Creator from another host and not from the Raspberry itself.\n\n\nDrivers\n\n\nnode test_driver_info.js\n\n\n\n\nContinue\n\n\n\n\nTry the rest of the \nJavaScript\n or \nPython\n tests.\n\n\nWrite and run your own CORE-enabled software by using our \nReference\n documentation.", 
            "title": "Hello World"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/#download-and-prepare", 
            "text": "You need  NodeJS, and the Node Package Manager (npm)  installed on the Raspberry Pi.   git clone https://github.com/matrix-io/matrix-creator-malos;\ncd matrix-creator-malos;\ngit submodule update --init;\ncd src/js_test;\nnpm install;", 
            "title": "Download and Prepare"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/#examples", 
            "text": "MATRIX CORE is the program that sits between the low level hardware layer and MATRIX OS. This program allows MATRIX OS to access the board hardware via ZeroMQ sockets. You can also use it directly, as it is done with the examples below. The The IPs used in the examples are 127.0.0.1. Remember to edit them if you're accessing the Creator from another host and not from the Raspberry itself.", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/#drivers", 
            "text": "node test_driver_info.js", 
            "title": "Drivers"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/#continue", 
            "text": "Try the rest of the  JavaScript  or  Python  tests.  Write and run your own CORE-enabled software by using our  Reference  documentation.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-core/getting-started/next-steps/", 
            "text": "Next Steps\n\n\nShare your creation\n\n\nShow us know what you've made and we'll share it to our channels! \n\n\n\n\nMATRIX Community\n\n\nTutorials/Projects Pages\n\n\nVideos\n\n\nMATRIX Twitter", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-core/getting-started/next-steps/#next-steps", 
            "text": "", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-core/getting-started/next-steps/#share-your-creation", 
            "text": "Show us know what you've made and we'll share it to our channels!    MATRIX Community  Tutorials/Projects Pages  Videos  MATRIX Twitter", 
            "title": "Share your creation"
        }, 
        {
            "location": "/matrix-core/examples/pytests/", 
            "text": "Python Examples\n\n\nPrerequisites\n\n\nMake sure to have cloned the Python examples found below to your Raspberry Pi.\n\n\ngit clone https://github.com/matrix-io/matrix-creator-malos;\ngit submodule update --init;\ncd matrix-creator-malos/src/python_test;\n\n\n\n\nPython packages\n\n\nInstall the following python packages dependences via Terminal.\n\n\nsudo apt-get install build-essential python-dev\npip install -r requirements.txt\n\n\n\n\nIf you're using \npipenv\n, then do the following:\n\n\n# Install dependencies\npipenv install\n\n\n\n\nMATRIX Creator software\n\n\nInstall CORE and perform device reboot. \n\n\necho \ndeb http://packages.matrix.one/matrix-creator/ ./\n | sudo tee --append /etc/apt/sources.list\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install matrix-creator-init matrix-creator-malos cmake g++ git libzmq3-dev --no-install-recommends\nreboot\n\n\n\n\nTest GPIO\n\n\n$ python test_gpio.py\nGPIO15=0\nGPIO15=1\nGPIO15=0\n\n\n\n\n\nIf you're using \npipenv\n:\n\n\n$ pipenv run python test_gpio.py\n\n\n\n\n(on this example: pin 15 on write mode, toggle value 0 and 1)\n\n\nPython Test Files\n\n\nDriver_info\n\n\npython test_driver_info.py\n\n\n\n\nEverloop\n\n\npython test_everloop.py\n\n\n\n\nEverloop color\n\n\npython test_set_everloop_color.py\n\n\n\n\nGPIO\n\n\npython test_gpio.py\n\n\n\n\nGPIO Read \n Write\n\n\npython test_gpio_read_write.py\n\n\n\n\nHumidity\n\n\npython test_humidity.py\n\n\n\n\nImu\n\n\npython test_imu.py\n\n\n\n\nIR\n\n\npython test_ir_remote.py\n\n\n\n\nPressure\n\n\npython test_pressure.py\n\n\n\n\nServo\n\n\npython test_servo.py\n\n\n\n\nUV\n\n\npython test_uv.py\n\n\n\n\nGPIO python example\n\n\nOn this example, we will connect to CORE GPIO driver for controlling a single pin. GPIO driver on MATRIX creator supports:\n\n\n\n\nGPIO pin input\n\n\nGPIO pin output\n\n\nGPIO updates (state from all pins)\n\n\n\n\nThe CORE driver follows the \nCORE protocol\n.\n\n\n\n\nGPIO Example details\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n because we are connecting from the local host. It will be your creator's IP address if you wish to run the python samples from a different computer, in such case you can \nexport CREATOR_IP=\nip\n variable, and the samples will connect to the specified host.\n\n\nWe also set the base port for the CORE Pressure driver (20013).\n\n\nimport zmq\nimport time\nimport driver_pb2 as driver_proto # proto buffer precompiled\n\n# Either local host or the value you set in env var\ncreator_ip = os.environ.get('CREATOR_IP', '127.0.0.1')\ncreator_gpio_base_port = 20013 + 36\n\n# connection to device\ncontext = zmq.Context()\nsocket = context.socket(zmq.PUSH)\nsocket.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port))\n\n# instance for config driver message\nconfig = driver_proto.DriverConfig()\nconfig.gpio.pin = 15  # pin on board\nconfig.gpio.mode = driver_proto.GpioParams.OUTPUT # pin mode OUTPUT/INPUT\n\nwhile True:\n    config.gpio.value ^= 1 # toggle value\n    print ('GPIO'+str(config.gpio.pin)+'='+str(config.gpio.value))\n    socket.send(config.SerializeToString()) # send proto message\n    time.sleep(1)\n\n\n\n\nAdvanced sample\n\n\nMATRIX CORE layer uses ZMQ push/subscriptions to send driver configurations and to get driver updates. For more info see \nCORE protocol\n driver details.\n\n\nEnhanced description of the \nsample source code\n.\n\n\nimport zmq\nimport time\nimport driver_pb2 as driver_proto\nfrom  multiprocessing import Process\nfrom zmq.eventloop import ioloop, zmqstream\nioloop.install()\n\n# Either local host or the value you set in env var\ncreator_ip = os.environ.get('CREATOR_IP', '127.0.0.1')\ncreator_gpio_base_port = 20013 + 36\n\n# setup GPIO pin to output mode and set gpio value\ndef config_gpio_write(pin,value):\n    config = driver_proto.DriverConfig()\n    config.gpio.pin = pin\n    config.gpio.mode = driver_proto.GpioParams.OUTPUT\n    config.gpio.value = value\n    sconfig.send(config.SerializeToString())\n\n# setup GPIO pin to input mode\ndef config_gpio_read(pin):\n    config = driver_proto.DriverConfig()\n    # 250 miliseconds between updates.\n    config.delay_between_updates = 0.5\n    # Stop sending updates 2 seconds after pings.\n    config.timeout_after_last_ping = 3.5\n    config.gpio.pin = pin\n    config.gpio.mode = driver_proto.GpioParams.INPUT\n    sconfig.send(config.SerializeToString())\n\n# get complete GPIO register status. (all pines)\ndef gpio_callback(msg):\n    print \nReceived gpio register: %s\n % msg\n\n# ZMQ subscription for driver notifications via gpio_callback\ndef register_gpio_callback():\n    ssub = context.socket(zmq.SUB)\n    ssub_port = str(creator_gpio_base_port+3)\n    ssub.connect('tcp://' + creator_ip + ':' + ssub_port)\n    ssub.setsockopt(zmq.SUBSCRIBE,\n)\n    stream = zmqstream.ZMQStream(ssub)\n    stream.on_recv(gpio_callback)\n    print \nConnected to publisher with port %s\n % ssub_port\n    ioloop.IOLoop.instance().start()\n    print \nWorker has stopped processing messages.\n\n\n# toggle 0/1 on GPIO pin output\ndef task_gpio_write(pin):\n    pin_value = 0\n    while True:\n        pin_value ^= 1\n        config_gpio_write(pin,pin_value)\n        print ('GPIO:'+str(pin)+' =\n '+str(pin_value))\n        time.sleep(1)\n\n# request notifications to driver\ndef task_driver_ping():\n    context = zmq.Context()\n    sping = context.socket(zmq.PUSH)\n    sping.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port + 1))\n    while True:\n        sping.send('')\n        time.sleep(1)\n\nif __name__ == \n__main__\n:\n    # ZMQ initialization and build socket config\n    context = zmq.Context()\n    sconfig = context.socket(zmq.PUSH)\n    sconfig.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port))\n\n    config_gpio_write(0,0) # pin 0 in output mode, value 0\n    config_gpio_read(1)    # pin 1 in input mode\n\n    # register async tasks\n    Process(target = task_gpio_write, args = (0, )).start()\n    Process(target = task_driver_ping).start()\n\n    register_gpio_callback()\n\n\n\n\n\n\nCORE Driver details\n\n\n0MQ Port\n\n\n20049\n\n\n\n\nProtocol buffers\n\n\n// GPIO handler params\nmessage GpioParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // GPIO mode input/output\n  enum EnumMode {\n    INPUT = 0;\n    OUTPUT = 1;\n  }\n  EnumMode mode = 2;\n\n  // GPIO value\n  uint32 value = 3;\n\n  // GPIO all values\n  uint32 values = 4;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver reports errors when an invalid configuration is sent.\n\n\nWrite\n\n\nAll pins on matrix creator start as inputs. For change to outputs the driver need message for each pin on OUTPUT mode.\n\n\nRead\n\n\nThe driver will send a serialized message of integer \nvalues\n which reprensets of state from all GPIO pins \nsee figure 1\n. For example: \nvalues=5\n represents \n101\n (pin 0 on 1, pin 1 on 0 and pin 2 on 1).", 
            "title": "Python"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#python-examples", 
            "text": "", 
            "title": "Python Examples"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#prerequisites", 
            "text": "Make sure to have cloned the Python examples found below to your Raspberry Pi.  git clone https://github.com/matrix-io/matrix-creator-malos;\ngit submodule update --init;\ncd matrix-creator-malos/src/python_test;", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#python-packages", 
            "text": "Install the following python packages dependences via Terminal.  sudo apt-get install build-essential python-dev\npip install -r requirements.txt  If you're using  pipenv , then do the following:  # Install dependencies\npipenv install", 
            "title": "Python packages"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#matrix-creator-software", 
            "text": "Install CORE and perform device reboot.   echo  deb http://packages.matrix.one/matrix-creator/ ./  | sudo tee --append /etc/apt/sources.list\nsudo apt-get update\nsudo apt-get upgrade\nsudo apt-get install matrix-creator-init matrix-creator-malos cmake g++ git libzmq3-dev --no-install-recommends\nreboot", 
            "title": "MATRIX Creator software"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#test-gpio", 
            "text": "$ python test_gpio.py\nGPIO15=0\nGPIO15=1\nGPIO15=0  If you're using  pipenv :  $ pipenv run python test_gpio.py  (on this example: pin 15 on write mode, toggle value 0 and 1)", 
            "title": "Test GPIO"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#python-test-files", 
            "text": "", 
            "title": "Python Test Files"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#driver_info", 
            "text": "python test_driver_info.py", 
            "title": "Driver_info"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#everloop", 
            "text": "python test_everloop.py", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#everloop-color", 
            "text": "python test_set_everloop_color.py", 
            "title": "Everloop color"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#gpio", 
            "text": "python test_gpio.py", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#gpio-read-write", 
            "text": "python test_gpio_read_write.py", 
            "title": "GPIO Read &amp; Write"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#humidity", 
            "text": "python test_humidity.py", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#imu", 
            "text": "python test_imu.py", 
            "title": "Imu"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#ir", 
            "text": "python test_ir_remote.py", 
            "title": "IR"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#pressure", 
            "text": "python test_pressure.py", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#servo", 
            "text": "python test_servo.py", 
            "title": "Servo"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#uv", 
            "text": "python test_uv.py", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#gpio-python-example", 
            "text": "On this example, we will connect to CORE GPIO driver for controlling a single pin. GPIO driver on MATRIX creator supports:   GPIO pin input  GPIO pin output  GPIO updates (state from all pins)   The CORE driver follows the  CORE protocol .", 
            "title": "GPIO python example"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#gpio-example-details", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1  because we are connecting from the local host. It will be your creator's IP address if you wish to run the python samples from a different computer, in such case you can  export CREATOR_IP= ip  variable, and the samples will connect to the specified host.  We also set the base port for the CORE Pressure driver (20013).  import zmq\nimport time\nimport driver_pb2 as driver_proto # proto buffer precompiled\n\n# Either local host or the value you set in env var\ncreator_ip = os.environ.get('CREATOR_IP', '127.0.0.1')\ncreator_gpio_base_port = 20013 + 36\n\n# connection to device\ncontext = zmq.Context()\nsocket = context.socket(zmq.PUSH)\nsocket.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port))\n\n# instance for config driver message\nconfig = driver_proto.DriverConfig()\nconfig.gpio.pin = 15  # pin on board\nconfig.gpio.mode = driver_proto.GpioParams.OUTPUT # pin mode OUTPUT/INPUT\n\nwhile True:\n    config.gpio.value ^= 1 # toggle value\n    print ('GPIO'+str(config.gpio.pin)+'='+str(config.gpio.value))\n    socket.send(config.SerializeToString()) # send proto message\n    time.sleep(1)", 
            "title": "GPIO Example details"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#advanced-sample", 
            "text": "MATRIX CORE layer uses ZMQ push/subscriptions to send driver configurations and to get driver updates. For more info see  CORE protocol  driver details.  Enhanced description of the  sample source code .  import zmq\nimport time\nimport driver_pb2 as driver_proto\nfrom  multiprocessing import Process\nfrom zmq.eventloop import ioloop, zmqstream\nioloop.install()\n\n# Either local host or the value you set in env var\ncreator_ip = os.environ.get('CREATOR_IP', '127.0.0.1')\ncreator_gpio_base_port = 20013 + 36\n\n# setup GPIO pin to output mode and set gpio value\ndef config_gpio_write(pin,value):\n    config = driver_proto.DriverConfig()\n    config.gpio.pin = pin\n    config.gpio.mode = driver_proto.GpioParams.OUTPUT\n    config.gpio.value = value\n    sconfig.send(config.SerializeToString())\n\n# setup GPIO pin to input mode\ndef config_gpio_read(pin):\n    config = driver_proto.DriverConfig()\n    # 250 miliseconds between updates.\n    config.delay_between_updates = 0.5\n    # Stop sending updates 2 seconds after pings.\n    config.timeout_after_last_ping = 3.5\n    config.gpio.pin = pin\n    config.gpio.mode = driver_proto.GpioParams.INPUT\n    sconfig.send(config.SerializeToString())\n\n# get complete GPIO register status. (all pines)\ndef gpio_callback(msg):\n    print  Received gpio register: %s  % msg\n\n# ZMQ subscription for driver notifications via gpio_callback\ndef register_gpio_callback():\n    ssub = context.socket(zmq.SUB)\n    ssub_port = str(creator_gpio_base_port+3)\n    ssub.connect('tcp://' + creator_ip + ':' + ssub_port)\n    ssub.setsockopt(zmq.SUBSCRIBE, )\n    stream = zmqstream.ZMQStream(ssub)\n    stream.on_recv(gpio_callback)\n    print  Connected to publisher with port %s  % ssub_port\n    ioloop.IOLoop.instance().start()\n    print  Worker has stopped processing messages. \n\n# toggle 0/1 on GPIO pin output\ndef task_gpio_write(pin):\n    pin_value = 0\n    while True:\n        pin_value ^= 1\n        config_gpio_write(pin,pin_value)\n        print ('GPIO:'+str(pin)+' =  '+str(pin_value))\n        time.sleep(1)\n\n# request notifications to driver\ndef task_driver_ping():\n    context = zmq.Context()\n    sping = context.socket(zmq.PUSH)\n    sping.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port + 1))\n    while True:\n        sping.send('')\n        time.sleep(1)\n\nif __name__ ==  __main__ :\n    # ZMQ initialization and build socket config\n    context = zmq.Context()\n    sconfig = context.socket(zmq.PUSH)\n    sconfig.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port))\n\n    config_gpio_write(0,0) # pin 0 in output mode, value 0\n    config_gpio_read(1)    # pin 1 in input mode\n\n    # register async tasks\n    Process(target = task_gpio_write, args = (0, )).start()\n    Process(target = task_driver_ping).start()\n\n    register_gpio_callback()", 
            "title": "Advanced sample"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#core-driver-details", 
            "text": "", 
            "title": "CORE Driver details"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#0mq-port", 
            "text": "20049", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#protocol-buffers", 
            "text": "// GPIO handler params\nmessage GpioParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // GPIO mode input/output\n  enum EnumMode {\n    INPUT = 0;\n    OUTPUT = 1;\n  }\n  EnumMode mode = 2;\n\n  // GPIO value\n  uint32 value = 3;\n\n  // GPIO all values\n  uint32 values = 4;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#errors", 
            "text": "This driver reports errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#write", 
            "text": "All pins on matrix creator start as inputs. For change to outputs the driver need message for each pin on OUTPUT mode.", 
            "title": "Write"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#read", 
            "text": "The driver will send a serialized message of integer  values  which reprensets of state from all GPIO pins  see figure 1 . For example:  values=5  represents  101  (pin 0 on 1, pin 1 on 0 and pin 2 on 1).", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/examples/jstests/", 
            "text": "Javascript Example\n\n\n\n\nYou need \nNodeJS, and the Node Package Manager (npm)\n installed on the Raspberry Pi.\n\n\n\n\nCORE is the program that sits between the low level hardware layer and MATRIX OS. This program allows MATRIX OS to access the board hardware via ZeroMQ sockets. You can also use it directly, as it is done with the examples below. The IPs are hardcoded in the examples to 127.0.0.1. Remember to edit them if you're accessing the Creator from another host and not from the Raspberry itself.\n\n\nFor an in-depth discussion of these tests, please examine the \nReference\n sections for JavaScript details.\n\n\nOn the Raspberry Pi\n\n\n# Install npm (doesn't really matter what version, apt-get node is v0.10...)\nsudo apt-get install npm\n\n# n is a node version manager\nsudo npm install -g n\n\n# node 6.5 is the latest target node version, also installs new npm\nn 6.5\n\n# check version\nnode -v\n\n\n\n\nDownload and Prepare CORE\n\n\ngit clone https://github.com/matrix-io/matrix-creator-malos;\ncd matrix-creator-malos;\ngit submodule update --init;\ncd src/js_test;\nnpm install;\n\n\n\n\nUsing CORE\n\n\nCORE Examples\n\n\nConnecting to CORE with NodeJS\n\n\nNote:\n You'll need \nprotobufjs\n and \nzmq\n npm packages, and protobuf as a submodule. See the \nEverloop Example\n for the full implementation of the code below.\n\n\n// This is how we connect to the creator. IP and port.\n// The IP is the IP I'm using and you need to edit it.\n// By default, CORE has its 0MQ ports open to the world.\n\n// Every device is identified by a base port. Then the mapping works\n// as follows:\n// BasePort     =\n Configuration port. Used to config the device.\n// BasePort + 1 =\n Keepalive port. Send pings to this port.\n// BasePort + 2 =\n Error port. Receive errros from device.\n// BasePort + 3 =\n Data port. Receive data from device.\n\nvar protoBuf = require(\nprotobufjs\n);\nvar zmq = require('zmq');\nvar configSocket = zmq.socket('push')\n\nvar creator_ip = '127.0.0.1'\nvar creator_everloop_base_port = 20013 + 8 // port for Everloop driver.\n\n// relative to where you have the protobufs\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n\n// malos interface\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_everloop_base_port /* config */)\n\n...\n\n\n\n\nPassing Commands to CORE\n\n\nBelow is an example of Node interfacing with the Everloop via CORE. See the \nEverloop Example\n for the full implementation of the code below.\n\n\n...\n\nvar max_intensity = 50\nvar intensity_value = max_intensity\n\nfunction setEverloop() {\n    var config = new matrixMalosBuilder.DriverConfig\n    config.image = new matrixMalosBuilder.EverloopImage\n\n    // Iteration over all 35 Everloop LEDs to turn them green.\n    for (var j = 0; j \n 35; ++j) {\n      var ledValue = new matrixMalosBuilder.LedValue;\n\n      // set brightness/intensity of the color for each rgb LED.\n      ledValue.setRed(0);\n      ledValue.setGreen(intensity_value);\n      ledValue.setBlue(0);\n      ledValue.setWhite(0);\n      config.image.led.push(ledValue);\n    }\n    configSocket.send(config.encode().toBuffer());\n}\n\nsetEverloop(intensity_value)\nsetInterval(function() {\n  intensity_value -= 1\n  if (intensity_value \n 0)\n    intensity_value = max_intensity\n  setEverloop()\n}, 10);\n\n\n\n\nReading from CORE\n\n\nBelow is a simple implementation via NodeJS to read a \nhumidity\n from CORE via 0MQ. See \nHumidity Example\n for the full example.\n\n\n// Start configuration for refresh rate, and heartbeat timeouts\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_humidity_base_port)\n// Send driver configuration.\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n// 2 seconds between updates.\ndriverConfigProto.delay_between_updates = 2.0\n// Stop sending updates 6 seconds after pings.\ndriverConfigProto.timeout_after_last_ping = 6.0\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n// ********** End configuration.\n\n// ********** Start updates - Here is where they are received.\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  // read Humidity (or Pressure, Imu, UV, etc...) \n  var data = new matrixMalosBuilder.Humidity.decode(buffer)\n  console.log(data)\n});\n// ********** End updates\n\n\n\n\nDrivers\n\n\nnode test_driver_info.js\n\n\n\n\nEverloop\n\n\nnode test_everloop.js\n\n\n\n\nHumidity\n\n\nnode test_humidity.js\n\n\n\n\nIMU\n\n\nnode test_imu.js\n\n\n\n\nIR Remote\n\n\nnode test_ir_remote.js\n\n\n\n\nPressure\n\n\nnode test_pressure.js\n\n\n\n\nUV\n\n\nnode test_uv.js\n\n\n\n\nZigbee Bulb On/Off\n\n\nnode test_zigbee_bulb.js\n\n\n\n\nZigbee Bulb Color\n\n\nnode test_zigbee_color.js\n\n\n\n\nZigbee Bulb Brightness\n\n\nnode test_zigbee_level.js", 
            "title": "JavaScript"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#javascript-example", 
            "text": "You need  NodeJS, and the Node Package Manager (npm)  installed on the Raspberry Pi.   CORE is the program that sits between the low level hardware layer and MATRIX OS. This program allows MATRIX OS to access the board hardware via ZeroMQ sockets. You can also use it directly, as it is done with the examples below. The IPs are hardcoded in the examples to 127.0.0.1. Remember to edit them if you're accessing the Creator from another host and not from the Raspberry itself.  For an in-depth discussion of these tests, please examine the  Reference  sections for JavaScript details.", 
            "title": "Javascript Example"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#on-the-raspberry-pi", 
            "text": "# Install npm (doesn't really matter what version, apt-get node is v0.10...)\nsudo apt-get install npm\n\n# n is a node version manager\nsudo npm install -g n\n\n# node 6.5 is the latest target node version, also installs new npm\nn 6.5\n\n# check version\nnode -v", 
            "title": "On the Raspberry Pi"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#download-and-prepare-core", 
            "text": "git clone https://github.com/matrix-io/matrix-creator-malos;\ncd matrix-creator-malos;\ngit submodule update --init;\ncd src/js_test;\nnpm install;", 
            "title": "Download and Prepare CORE"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#using-core", 
            "text": "", 
            "title": "Using CORE"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#core-examples", 
            "text": "", 
            "title": "CORE Examples"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#connecting-to-core-with-nodejs", 
            "text": "Note:  You'll need  protobufjs  and  zmq  npm packages, and protobuf as a submodule. See the  Everloop Example  for the full implementation of the code below.  // This is how we connect to the creator. IP and port.\n// The IP is the IP I'm using and you need to edit it.\n// By default, CORE has its 0MQ ports open to the world.\n\n// Every device is identified by a base port. Then the mapping works\n// as follows:\n// BasePort     =  Configuration port. Used to config the device.\n// BasePort + 1 =  Keepalive port. Send pings to this port.\n// BasePort + 2 =  Error port. Receive errros from device.\n// BasePort + 3 =  Data port. Receive data from device.\n\nvar protoBuf = require( protobufjs );\nvar zmq = require('zmq');\nvar configSocket = zmq.socket('push')\n\nvar creator_ip = '127.0.0.1'\nvar creator_everloop_base_port = 20013 + 8 // port for Everloop driver.\n\n// relative to where you have the protobufs\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n\n// malos interface\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_everloop_base_port /* config */)\n\n...", 
            "title": "Connecting to CORE with NodeJS"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#passing-commands-to-core", 
            "text": "Below is an example of Node interfacing with the Everloop via CORE. See the  Everloop Example  for the full implementation of the code below.  ...\n\nvar max_intensity = 50\nvar intensity_value = max_intensity\n\nfunction setEverloop() {\n    var config = new matrixMalosBuilder.DriverConfig\n    config.image = new matrixMalosBuilder.EverloopImage\n\n    // Iteration over all 35 Everloop LEDs to turn them green.\n    for (var j = 0; j   35; ++j) {\n      var ledValue = new matrixMalosBuilder.LedValue;\n\n      // set brightness/intensity of the color for each rgb LED.\n      ledValue.setRed(0);\n      ledValue.setGreen(intensity_value);\n      ledValue.setBlue(0);\n      ledValue.setWhite(0);\n      config.image.led.push(ledValue);\n    }\n    configSocket.send(config.encode().toBuffer());\n}\n\nsetEverloop(intensity_value)\nsetInterval(function() {\n  intensity_value -= 1\n  if (intensity_value   0)\n    intensity_value = max_intensity\n  setEverloop()\n}, 10);", 
            "title": "Passing Commands to CORE"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#reading-from-core", 
            "text": "Below is a simple implementation via NodeJS to read a  humidity  from CORE via 0MQ. See  Humidity Example  for the full example.  // Start configuration for refresh rate, and heartbeat timeouts\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_humidity_base_port)\n// Send driver configuration.\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n// 2 seconds between updates.\ndriverConfigProto.delay_between_updates = 2.0\n// Stop sending updates 6 seconds after pings.\ndriverConfigProto.timeout_after_last_ping = 6.0\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n// ********** End configuration.\n\n// ********** Start updates - Here is where they are received.\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  // read Humidity (or Pressure, Imu, UV, etc...) \n  var data = new matrixMalosBuilder.Humidity.decode(buffer)\n  console.log(data)\n});\n// ********** End updates", 
            "title": "Reading from CORE"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#drivers", 
            "text": "node test_driver_info.js", 
            "title": "Drivers"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#everloop", 
            "text": "node test_everloop.js", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#humidity", 
            "text": "node test_humidity.js", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#imu", 
            "text": "node test_imu.js", 
            "title": "IMU"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#ir-remote", 
            "text": "node test_ir_remote.js", 
            "title": "IR Remote"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#pressure", 
            "text": "node test_pressure.js", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#uv", 
            "text": "node test_uv.js", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#zigbee-bulb-onoff", 
            "text": "node test_zigbee_bulb.js", 
            "title": "Zigbee Bulb On/Off"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#zigbee-bulb-color", 
            "text": "node test_zigbee_color.js", 
            "title": "Zigbee Bulb Color"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#zigbee-bulb-brightness", 
            "text": "node test_zigbee_level.js", 
            "title": "Zigbee Bulb Brightness"
        }, 
        {
            "location": "/matrix-core/reference/", 
            "text": "Reference\n\n\n\n\nEverloop\n\n\nHumidity\n\n\nIMU\n\n\nIR\n\n\nPressure\n\n\nUV\n\n\nGPIO", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-core/reference/#reference", 
            "text": "Everloop  Humidity  IMU  IR  Pressure  UV  GPIO", 
            "title": "Reference"
        }, 
        {
            "location": "/matrix-core/reference/everloop/", 
            "text": "Everloop\n\n\nThe Everloop driver controls the LED array of the MATRIX Creator.\nIt follows the \nCORE protocol\n.\n\n\n0MQ Port\n\n\n20021\n\n\n\n\nKeep-alives\n\n\nThis driver doesn't need keep-alive messages as it doesn't send data to the subscribed programs.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThis driver doesn't send any data to a subscribed program.\n\n\nExample Usage\n\n\nThis section provides an enhanced description of the relevant parts of the \nsample source code\n.\n\n\nTo run the source code of this example you need to execute the following commands:\n\n\ngit clone https://github.com/matrix-io/matrix-creator-malos.git\ncd matrix-creator-malos\ngit submodule update --init\ncd src/js_test/\nnpm install\nnode test_everloop.js\n\n\n\n\nIn order to set the LEDs of the Creator you need to perform the following steps.\n\n\nInitialize Configuration\n\n\nvar config = new matrixMalosBuilder.DriverConfig\n\n\n\nCreate LED configuration object\n\n\nconfig.image = new matrixMalosBuilder.EverloopImage\n\n\n\nSet LED states\n\n\nThe following steps needs to be repeated 35 times, once per LED.\n\n\nThe LEDs are counted starting from the left, clock-wise\nas shown in the picture.\n\n\n\n\nIndividual LED state\n\n\nFirst, create the object.\n\n\nvar ledValue = new matrixMalosBuilder.LedValue\n\n\n\nNow fill out the state of a given led by calling the following functions on ledValue.\nEach of the following functions receives an integer in the range [0, 255].\n\n\n\n\n\n\n\n\nFunction\n\n\nObjective\n\n\n\n\n\n\n\n\n\n\nsetRed\n\n\nSet value of red component\n\n\n\n\n\n\nsetGreen\n\n\nSet value of green component\n\n\n\n\n\n\nSetBlue\n\n\nSet value of blue component\n\n\n\n\n\n\nSeWhite\n\n\nSet value of white component\n\n\n\n\n\n\n\n\nThat is, repeat 35 times:\n\n\nledValue.setRed(red_value)\nledValue.setGreen(green_value)\nledValue.setBlue(blue_value)\nledValue.setWhite(white_value)\n\nconfig.image.led.push(ledValue)\n\n\n\nSend configuration\n\n\nconfigSocket.send(config.encode().toBuffer())\n\n\nAll steps combined\n\n\nThe following snippet will make all the greens display the green color.\n\n\nvar config = new matrixMalosBuilder.DriverConfig\nconfig.image = new matrixMalosBuilder.EverloopImage\nfor (var j = 0; j \n 35; ++j) {\n  var ledValue = new matrixMalosBuilder.LedValue\n  ledValue.setRed(0)\n  ledValue.setGreen(30)\n  ledValue.setBlue(0)\n  ledValue.setWhite(0)\n  config.image.led.push(ledValue)\n}\nconfigSocket.send(config.encode().toBuffer())\n\n\n\nGlossary\n\n\nProtocol buffers\n\n\nIn this section we get into the details of the \nprotocol buffers\n used by the\nJavaScript example to communicate with the Everloop driver.\nThe messages used by this driver are defined in \ndriver.proto\n.\n\n\nmessage EverloopImage {\n  repeated LedValue led = 1;\n}\n\n\n\n\nThe message \nEverloopImage\n needs to have exactly 35 messages of type \nLedValue\n in the repeated field \nled\n,\ncorresponding to each of the LEDs present in the Creator.\n\n\nThe message LedValue holds the color values for each LED and each value is in the range [0, 255].\n\n\nmessage LedValue {\n  uint32 red = 1;\n  uint32 green = 2;\n  uint32 blue = 3;\n  uint32 white = 4;\n}", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#everloop", 
            "text": "The Everloop driver controls the LED array of the MATRIX Creator.\nIt follows the  CORE protocol .", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#0mq-port", 
            "text": "20021", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#keep-alives", 
            "text": "This driver doesn't need keep-alive messages as it doesn't send data to the subscribed programs.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#read", 
            "text": "This driver doesn't send any data to a subscribed program.", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#example-usage", 
            "text": "This section provides an enhanced description of the relevant parts of the  sample source code .  To run the source code of this example you need to execute the following commands:  git clone https://github.com/matrix-io/matrix-creator-malos.git\ncd matrix-creator-malos\ngit submodule update --init\ncd src/js_test/\nnpm install\nnode test_everloop.js  In order to set the LEDs of the Creator you need to perform the following steps.", 
            "title": "Example Usage"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#initialize-configuration", 
            "text": "var config = new matrixMalosBuilder.DriverConfig", 
            "title": "Initialize Configuration"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#create-led-configuration-object", 
            "text": "config.image = new matrixMalosBuilder.EverloopImage", 
            "title": "Create LED configuration object"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#set-led-states", 
            "text": "The following steps needs to be repeated 35 times, once per LED.  The LEDs are counted starting from the left, clock-wise\nas shown in the picture.", 
            "title": "Set LED states"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#individual-led-state", 
            "text": "First, create the object.  var ledValue = new matrixMalosBuilder.LedValue  Now fill out the state of a given led by calling the following functions on ledValue.\nEach of the following functions receives an integer in the range [0, 255].     Function  Objective      setRed  Set value of red component    setGreen  Set value of green component    SetBlue  Set value of blue component    SeWhite  Set value of white component     That is, repeat 35 times:  ledValue.setRed(red_value)\nledValue.setGreen(green_value)\nledValue.setBlue(blue_value)\nledValue.setWhite(white_value)\n\nconfig.image.led.push(ledValue)", 
            "title": "Individual LED state"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#send-configuration", 
            "text": "configSocket.send(config.encode().toBuffer())", 
            "title": "Send configuration"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#all-steps-combined", 
            "text": "The following snippet will make all the greens display the green color.  var config = new matrixMalosBuilder.DriverConfig\nconfig.image = new matrixMalosBuilder.EverloopImage\nfor (var j = 0; j   35; ++j) {\n  var ledValue = new matrixMalosBuilder.LedValue\n  ledValue.setRed(0)\n  ledValue.setGreen(30)\n  ledValue.setBlue(0)\n  ledValue.setWhite(0)\n  config.image.led.push(ledValue)\n}\nconfigSocket.send(config.encode().toBuffer())", 
            "title": "All steps combined"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#glossary", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#protocol-buffers", 
            "text": "In this section we get into the details of the  protocol buffers  used by the\nJavaScript example to communicate with the Everloop driver.\nThe messages used by this driver are defined in  driver.proto .  message EverloopImage {\n  repeated LedValue led = 1;\n}  The message  EverloopImage  needs to have exactly 35 messages of type  LedValue  in the repeated field  led ,\ncorresponding to each of the LEDs present in the Creator.  The message LedValue holds the color values for each LED and each value is in the range [0, 255].  message LedValue {\n  uint32 red = 1;\n  uint32 green = 2;\n  uint32 blue = 3;\n  uint32 white = 4;\n}", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/gpio/", 
            "text": "GPIO\n\n\nThe GPIO driver on current version supports:\n\n\n\n\nGPIO pin input\n\n\nGPIO pin output\n\n\nGPIO updates (state from all pins)\n\n\n\n\nThe driver follows the \nCORE protocol\n.\n\n\nGPIO electrical characteristics\n\n\n\n\nGPIO voltage: 0.60-4.10 VDC (\ndetails\n)\n\n\ncurrent 10mA max\n\n\nall GPIO pins need pullups\n\n\n\n\n0MQ Port\n\n\n20049\n\n\n\n\nProtocol buffers\n\n\n// GPIO handler params\nmessage GpioParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // GPIO mode input/output\n  enum EnumMode {\n    INPUT = 0;\n    OUTPUT = 1;\n  }\n  EnumMode mode = 2;\n\n  // GPIO value\n  uint32 value = 3;\n\n  // GPIO all values\n  uint32 values = 4;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver reports errors when an invalid configuration is sent.\n\n\nWrite\n\n\nAll pins on matrix creator start as inputs. For change to outputs the driver need message for each pin on OUTPUT mode. (see Javascript example below)\n\n\nRead\n\n\nThe driver will send a serialized message of integer \nvalues\n which represents of state from all GPIO pins \nsee figure 1\n. For example: \nvalues=5\n represents \n101\n (pin 0 on 1, pin 1 on 0 and pin 2 on 1).\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_gpio.js \nSending pings every 5 seconds\n==\n pin 0 set to: true\n\n== GPIO pins register:  1\n\n\n\n\n(pin0 set on true and GPIO register return values field on 1, only pin 0 set 1)\n\n\n$ node test_gpio.js \nSending pings every 5 seconds\n==\n pin 0 set to: true\n\n== GPIO pins register:  101\n\n\n\n\n(pin0 set on true and GPIO register return values field on 3 (binary 101) pin 0 on 1, pin 2 on 1 all then on 0)\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_gpio_base_port = 20013 + 36\n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n);\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver (optional)\n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nConfigure GPIO pins modes and set values for GPIO outputs:\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\n\n\nOutput mode:\n\n\ninstance driver config object \n\n\n  var config = new matrixMalosBuilder.DriverConfig\n\n\n\n\nwith GpioParams proto message set GPIO 0 to output mode \n\n\n  var gpio_cfg_cmd = new matrixMalosBuilder.GpioParams\n  gpio_cfg_cmd.set_pin(0)\n  gpio_cfg_cmd.set_mode(matrixMalosBuilder.GpioParams.EnumMode.OUTPUT)\n\n\n\n\nset GPIO pin value (0 or 1)\n\n\n  gpio_cfg_cmd.set_value(1);\n\n\n\n\nset on config driver params, encode and send\n\n\n  config.set_gpio(gpio_cfg_cmd)\n  configSocket.send(config.encode().toBuffer())\n\n\n\n\nInput mode:\n\n\ninstance driver config object \n\n\n  var config = new matrixMalosBuilder.DriverConfig\n\n\n\n\nset 250 ms between updates for example: (optional, default 1 second)\n\n\n  config.delay_between_updates = .250\n\n\n\n\nconfigure sending updates 2 seconds after pings (optional)\n\n\n  config.timeout_after_last_ping = 2.0\n\n\n\n\nwith \nGpioParams\n for example set GPIO 1 to input mode:\n\n\n  var gpio_cfg_cmd = new matrixMalosBuilder.GpioParams\n  gpio_cfg_cmd.set_pin(1)\n  gpio_cfg_cmd.set_mode(matrixMalosBuilder.GpioParams.EnumMode.INPUT)\n\n\n\n\nset on config driver params, encode and send\n\n\n  config.set_gpio(gpio_cfg_cmd)\n  configSocket.send(config.encode().toBuffer())\n\n\n\n\nSubscribe to GPIO updates\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 3))\nupdateSocket.subscribe('')\n\n\n\n\nRegister update callback:\n\n\nupdateSocket.on('message', function(gpio_buffer) {\n  var gpioData = new matrixMalosBuilder.GpioParams.decode(gpio_buffer)\n  // output in binary format all 15 pins of GPIO\n  console.log('\n== GPIO pins register: ',dec2bin(gpioData.values))\n});\n\n\n\n\nThe driver will send on callback a serialized message of integer \nvalues\n which represents of state from all GPIO pins\n\n\nKeep-alive messages\n\n\nAn empty keep-alive message is sent to the driver every 2 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 1))\n// Ping the first time.\npingSocket.send(''); \n// Ping every 2 seconds (same to delay between updates)\nsetInterval(function() {\n  pingSocket.send(''); // ping for new updates\n}, 2000);", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#gpio", 
            "text": "The GPIO driver on current version supports:   GPIO pin input  GPIO pin output  GPIO updates (state from all pins)   The driver follows the  CORE protocol .", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#gpio-electrical-characteristics", 
            "text": "GPIO voltage: 0.60-4.10 VDC ( details )  current 10mA max  all GPIO pins need pullups", 
            "title": "GPIO electrical characteristics"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#0mq-port", 
            "text": "20049", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#protocol-buffers", 
            "text": "// GPIO handler params\nmessage GpioParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // GPIO mode input/output\n  enum EnumMode {\n    INPUT = 0;\n    OUTPUT = 1;\n  }\n  EnumMode mode = 2;\n\n  // GPIO value\n  uint32 value = 3;\n\n  // GPIO all values\n  uint32 values = 4;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#errors", 
            "text": "This driver reports errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#write", 
            "text": "All pins on matrix creator start as inputs. For change to outputs the driver need message for each pin on OUTPUT mode. (see Javascript example below)", 
            "title": "Write"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#read", 
            "text": "The driver will send a serialized message of integer  values  which represents of state from all GPIO pins  see figure 1 . For example:  values=5  represents  101  (pin 0 on 1, pin 1 on 0 and pin 2 on 1).  This is a sample output given by the example described below.  $ node test_gpio.js \nSending pings every 5 seconds\n==  pin 0 set to: true == GPIO pins register:  1  (pin0 set on true and GPIO register return values field on 1, only pin 0 set 1)  $ node test_gpio.js \nSending pings every 5 seconds\n==  pin 0 set to: true == GPIO pins register:  101  (pin0 set on true and GPIO register return values field on 3 (binary 101) pin 0 on 1, pin 2 on 1 all then on 0)", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.  var creator_ip = '127.0.0.1'\nvar creator_gpio_base_port = 20013 + 36", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#load-the-protocol-buffers-used-in-the-example", 
            "text": "var protoBuf = require( protobufjs );\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )", 
            "title": "Load the protocol buffers used in the example."
        }, 
        {
            "location": "/matrix-core/reference/gpio/#subscribe-to-the-errors-reported-by-the-driver-optional", 
            "text": "var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') +  \\n )\n});", 
            "title": "Subscribe to the errors reported by the driver (optional)"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#configure-gpio-pins-modes-and-set-values-for-gpio-outputs", 
            "text": "All the drivers are configured using the message  DriverConfig  (see  driver.proto ).", 
            "title": "Configure GPIO pins modes and set values for GPIO outputs:"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#output-mode", 
            "text": "instance driver config object     var config = new matrixMalosBuilder.DriverConfig  with GpioParams proto message set GPIO 0 to output mode     var gpio_cfg_cmd = new matrixMalosBuilder.GpioParams\n  gpio_cfg_cmd.set_pin(0)\n  gpio_cfg_cmd.set_mode(matrixMalosBuilder.GpioParams.EnumMode.OUTPUT)  set GPIO pin value (0 or 1)    gpio_cfg_cmd.set_value(1);  set on config driver params, encode and send    config.set_gpio(gpio_cfg_cmd)\n  configSocket.send(config.encode().toBuffer())", 
            "title": "Output mode:"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#input-mode", 
            "text": "instance driver config object     var config = new matrixMalosBuilder.DriverConfig  set 250 ms between updates for example: (optional, default 1 second)    config.delay_between_updates = .250  configure sending updates 2 seconds after pings (optional)    config.timeout_after_last_ping = 2.0  with  GpioParams  for example set GPIO 1 to input mode:    var gpio_cfg_cmd = new matrixMalosBuilder.GpioParams\n  gpio_cfg_cmd.set_pin(1)\n  gpio_cfg_cmd.set_mode(matrixMalosBuilder.GpioParams.EnumMode.INPUT)  set on config driver params, encode and send    config.set_gpio(gpio_cfg_cmd)\n  configSocket.send(config.encode().toBuffer())", 
            "title": "Input mode:"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#subscribe-to-gpio-updates", 
            "text": "Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 3))\nupdateSocket.subscribe('')  Register update callback:  updateSocket.on('message', function(gpio_buffer) {\n  var gpioData = new matrixMalosBuilder.GpioParams.decode(gpio_buffer)\n  // output in binary format all 15 pins of GPIO\n  console.log(' == GPIO pins register: ',dec2bin(gpioData.values))\n});  The driver will send on callback a serialized message of integer  values  which represents of state from all GPIO pins", 
            "title": "Subscribe to GPIO updates"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#keep-alive-messages", 
            "text": "An empty keep-alive message is sent to the driver every 2 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 1))\n// Ping the first time.\npingSocket.send(''); \n// Ping every 2 seconds (same to delay between updates)\nsetInterval(function() {\n  pingSocket.send(''); // ping for new updates\n}, 2000);", 
            "title": "Keep-alive messages"
        }, 
        {
            "location": "/matrix-core/reference/humidity/", 
            "text": "Humidity\n\n\nThe Humidity driver reports values for:\n\n\n\n\nRelative Humidity on the Board \n\n\nTemperature in Celsius\n\n\nRAW Values of temperature\n\n\n\n\nThe Humidity can be configured with:\n\n Current temperature in Celsius\n\n Flag to set software calibration.\n\n\nThe driver follows the \nCORE protocol\n.\n\n\n0MQ Port\n\n\n20029\n\n\n\n\nProtocol buffers\n\n\nmessage Humidity {\n  float humidity = 1;\n  float temperature = 2;\n  float temperature_raw = 3;\n  bool temperature_is_calibrated = 4 ;\n}\n\nmessage HumidityParams{\n  float current_temperature = 1; \n  bool do_calibration = 2;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThe driver will send a serialized message of type \nHumidity\n.\n\n\nmessage Humidity {\n  float humidity = 1;\n  float temperature = 2;\n  float temperature_raw = 3;\n  bool temperature_is_calibrated = 4 ;\n}\n\nmessage HumidityParams{\n  float current_temperature = 1;\n  bool do_calibration = 2;\n}\n\n\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_humidity.js \nSending pings every 5 secondsMessage received: Humidity error: 0, Invalid specific configuration for Humidity driver.\n{ humidity: 30.716121673583984,\n  temperature: 20.246780395507812,\n  temperature_raw: 35.456275939941406,\n  temperature_is_calibrated: true }\n{ humidity: 30.716121673583984,\n  temperature: 20.246780395507812,\n  temperature_raw: 35.456275939941406,\n  temperature_is_calibrated: true }\n\n\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Humidity driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_humidity_base_port = 20013 + 4 \n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n)\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver. \n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Humidity error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\nThis is what the message looks like if we omit the fields that are not used in this example.\n\n\nmessage DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n  HumidityParams humidity = 9;\n}\n\n\n\nThe following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.\n\n\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_uv_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\nvar hum_params_msg = new matrixMalosBuilder.HumidityParams\nhum_params_msg.current_temperature = 23\nhum_params_msg.do_calibration = false\ndriverConfigProto.set_humidity(hum_params_msg)\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n\n\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.Humidity.decode(buffer)\n  console.log(data)\n});\n\n\n\n\nAn empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 1))\nprocess.stdout.write(\nSending pings every 5 seconds\n);\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#humidity", 
            "text": "The Humidity driver reports values for:   Relative Humidity on the Board   Temperature in Celsius  RAW Values of temperature   The Humidity can be configured with:  Current temperature in Celsius  Flag to set software calibration.  The driver follows the  CORE protocol .", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#0mq-port", 
            "text": "20029", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#protocol-buffers", 
            "text": "message Humidity {\n  float humidity = 1;\n  float temperature = 2;\n  float temperature_raw = 3;\n  bool temperature_is_calibrated = 4 ;\n}\n\nmessage HumidityParams{\n  float current_temperature = 1; \n  bool do_calibration = 2;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#read", 
            "text": "The driver will send a serialized message of type  Humidity .  message Humidity {\n  float humidity = 1;\n  float temperature = 2;\n  float temperature_raw = 3;\n  bool temperature_is_calibrated = 4 ;\n}\n\nmessage HumidityParams{\n  float current_temperature = 1;\n  bool do_calibration = 2;\n}  This is a sample output given by the example described below.  $ node test_humidity.js \nSending pings every 5 secondsMessage received: Humidity error: 0, Invalid specific configuration for Humidity driver.\n{ humidity: 30.716121673583984,\n  temperature: 20.246780395507812,\n  temperature_raw: 35.456275939941406,\n  temperature_is_calibrated: true }\n{ humidity: 30.716121673583984,\n  temperature: 20.246780395507812,\n  temperature_raw: 35.456275939941406,\n  temperature_is_calibrated: true }", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Humidity driver.  var creator_ip = '127.0.0.1'\nvar creator_humidity_base_port = 20013 + 4   Load the protocol buffers used in the example.  var protoBuf = require( protobufjs )\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )  Subscribe to the errors reported by the driver.   var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Humidity error: ' + error_message.toString('utf8') +  \\n )\n});  All the drivers are configured using the message  DriverConfig  (see  driver.proto ).\nThis is what the message looks like if we omit the fields that are not used in this example.  message DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n  HumidityParams humidity = 9;\n}  The following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.  var configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_uv_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\nvar hum_params_msg = new matrixMalosBuilder.HumidityParams\nhum_params_msg.current_temperature = 23\nhum_params_msg.do_calibration = false\ndriverConfigProto.set_humidity(hum_params_msg)\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())  Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.Humidity.decode(buffer)\n  console.log(data)\n});  An empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 1))\nprocess.stdout.write( Sending pings every 5 seconds );\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/imu/", 
            "text": "Inertial Measurement Unit - IMU\n\n\nThe IMU driver reports values for:\n\n\n\n\nYaw Axis or normal axis\n\n\nPitch Axis or lateral axis\n\n\nRoll Axis or longitudinal axis\n\n\n\n\nThe driver follows the \nCORE protocol\n.\n\n\n0MQ Port\n\n\n20013\n\n\n\n\nProtocol buffers\n\n\nmessage Imu {\n  float yaw = 1;\n  float pitch = 2;\n  float roll = 3;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThe driver will send a serialized message of type\nIMU\n.\n\n\nmessage Imu {\n  float yaw = 1;\n  float pitch = 2;\n  float roll = 3;\n}\n\n\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_imu.js \nSending pings every 5 seconds\n{ yaw: 164.5285186767578,\n  pitch: -6.635251045227051,\n  roll: 3.231848955154419 }\n{ yaw: 163.763427734375,\n  pitch: -6.659839153289795,\n  roll: 2.655540943145752 }\n{ yaw: 164.1026153564453,\n  pitch: -6.485481262207031,\n  roll: 2.9403600692749023 }\n\n\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe IMU driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_imu_base_port = 20013\n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n)\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver. \n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: IMU error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\nThis is what the message looks like if we omit the fields that are not used in this example.\n\n\nmessage DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}\n\n\n\nThe following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.\n\n\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_imu_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n\n\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.IMU.decode(buffer)\n  console.log(data)\n});\n\n\n\n\nAn empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 1))\nprocess.stdout.write(\nSending pings every 5 seconds\n);\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "IMU"
        }, 
        {
            "location": "/matrix-core/reference/imu/#inertial-measurement-unit-imu", 
            "text": "The IMU driver reports values for:   Yaw Axis or normal axis  Pitch Axis or lateral axis  Roll Axis or longitudinal axis   The driver follows the  CORE protocol .", 
            "title": "Inertial Measurement Unit - IMU"
        }, 
        {
            "location": "/matrix-core/reference/imu/#0mq-port", 
            "text": "20013", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/imu/#protocol-buffers", 
            "text": "message Imu {\n  float yaw = 1;\n  float pitch = 2;\n  float roll = 3;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/imu/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/imu/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/imu/#read", 
            "text": "The driver will send a serialized message of type IMU .  message Imu {\n  float yaw = 1;\n  float pitch = 2;\n  float roll = 3;\n}  This is a sample output given by the example described below.  $ node test_imu.js \nSending pings every 5 seconds\n{ yaw: 164.5285186767578,\n  pitch: -6.635251045227051,\n  roll: 3.231848955154419 }\n{ yaw: 163.763427734375,\n  pitch: -6.659839153289795,\n  roll: 2.655540943145752 }\n{ yaw: 164.1026153564453,\n  pitch: -6.485481262207031,\n  roll: 2.9403600692749023 }", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/imu/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe IMU driver.  var creator_ip = '127.0.0.1'\nvar creator_imu_base_port = 20013  Load the protocol buffers used in the example.  var protoBuf = require( protobufjs )\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )  Subscribe to the errors reported by the driver.   var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: IMU error: ' + error_message.toString('utf8') +  \\n )\n});  All the drivers are configured using the message  DriverConfig  (see  driver.proto ).\nThis is what the message looks like if we omit the fields that are not used in this example.  message DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}  The following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.  var configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_imu_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())  Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.IMU.decode(buffer)\n  console.log(data)\n});  An empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 1))\nprocess.stdout.write( Sending pings every 5 seconds );\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/lirc/", 
            "text": "LIRC\n\n\nThe LIRC driver on current version supports:\n\n\n\n\nIR send commands type \nSEND_ONCE\n for example: \nSONY_XX BTN_MUTING\n\n\nMultiple LIRC remote configurations concatenated via proto message. \n\n\n\n\nThe driver follows the \nCORE protocol\n.\n\n\nLIRC driver software:\n\n\nActual CORE software layer use oficial LIRC \nraspbian\n package (0.9.0~pre1-1.2). The oficial documentation is for next version\nbut LIRC config files structure is the same. Please see it for details:\n\n\n\n\nhttp://www.lirc.org/html/configuration-guide.html\n)\n\n\n\n\n0MQ Port\n\n\n20041\n\n\n\n\nProtocol buffers\n\n\nmessage LircParams {\n  // IR remote device name\n  string device = 1;\n\n  // IR command\n  string command = 2;\n\n  //For transport of LIRC remote devices configuration.\n  string config = 3;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver NOT needs keep-alive messages \nas specified in the CORE protocol\n.\n\n\nErrors\n\n\nThis driver reports errors when an invalid configuration is sent.\n\n\nWrite\n\n\nThis driver need at last one LIRC remote configuration for send IR commands to any device. CORE LIRC driver support multiple remote controls in the same file and you can use a previous remote control recorded. You will can download this remotes config from MATRIX assets repository and then send it via \nconfig\n field of \nLircParams\n protobuf. For more details plese see JavaScript example described below.\n\n\nExample for SONY RM-AAU014\n:\n\nhttp://assets.admobilize.com/lirc-remotes/sony/RM-AAU014.lircd.conf\n\n\nRead\n\n\nThis driver doesn't any data using CORE protocol. It only executes commands and sets configurations.\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_ir_remote.js \n\ndownloading remote config..done.\nset remote to config..done.\nsending IR command: BTN_MUTING to SONY_RM device..done.\nsending IR command: BTN_MUTING to SONY_RM device..done.\nsending IR command: BTN_MUTING to SONY_RM device..done.\n\n\n\n\ntest_ir_remote\n code first downloading remote config example then set it in CORE layer and then send IR commands\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_pressure_base_port = 20013 + 28\n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n);\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver (optional)\n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_lirc_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nDownloading some remote control\n\n\nCORE Lirc driver support multiple remote controls in the same file. You can use a previous remote control recorded\nand downloading it from MATRIX assets repository like this:\n\n\nvar http = require('http');\nvar fs = require('fs');\n\nvar remote_url=\nhttp://assets.admobilize.com/lirc-remotes/sony/RM-AAU014.lircd.conf\n\nvar remote_output=\nRM-AAU014.lircd.conf\n\n\nfunction download (url, dest, cb) {\n  process.stdout.write('downloading remote config..')\n  var file = fs.createWriteStream(dest);\n  var request = http.get(url, function(response) {\n    response.pipe(file);\n    file.on('finish', function() {\n      console.log('done.')\n      file.close(cb(dest));\n    });\n  });\n}\ndownload(remote_url,remote_output,configRemote)\n\n\n\n\nConfig remote device on CORE layer\n\n\nAll the drivers are configured using the message \ndriverconfig\n (see \ndriver.proto\n).\n\n\nfunction configRemote(config){\n  process.stdout.write('set remote to config..')\n  // read previous config file downloaded\n  fs.readFile(config, 'utf8', function (err,data) {\n      if (err) { return console.log(err); }\n      // build proto message\n      var ir_cfg_cmd = new matrixMalosBuilder.LircParams\n      ir_cfg_cmd.set_config(data)\n      // send message in config proto\n      sendIRConfigProto(ir_cfg_cmd) \n      console.log('done.')\n  });\n}\n\n// Generic config proto function\nfunction sendIRConfigProto(ir_cfg){\n  var config = new matrixMalosBuilder.DriverConfig\n  config.set_lirc(ir_cfg)\n  configSocket.send(config.encode().toBuffer());\n}\n\n\n\n\nSend remote commands to target device\n\n\nYou can use similar flow for sending commands via DriverConfig proto.\n\n\nfunction sendIrCommand(device, command) {\n  // build LircParams proto message\n  var ir_cfg_cmd = new matrixMalosBuilder.LircParams\n  // set device target like SONY device\n  ir_cfg_cmd.set_device(device)\n  // set device command like BTN_MUTING\n  ir_cfg_cmd.set_command(command)\n  sendIRConfigProto(ir_cfg_cmd) \n}\n\n// Optional sending continous IR commands\nfunction continousSendRemoteCommand(){\n  setInterval(function() {\n    process.stdout.write('sending IR command: BTN_MUTING to SONY_RM device..')\n    sendIrCommand('SONY_RM-AAU014','BTN_MUTING') // check LED on MATRIX\n    console.log('done.')\n  }, 3000);\n}", 
            "title": "IR"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#lirc", 
            "text": "The LIRC driver on current version supports:   IR send commands type  SEND_ONCE  for example:  SONY_XX BTN_MUTING  Multiple LIRC remote configurations concatenated via proto message.    The driver follows the  CORE protocol .", 
            "title": "LIRC"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#lirc-driver-software", 
            "text": "Actual CORE software layer use oficial LIRC  raspbian  package (0.9.0~pre1-1.2). The oficial documentation is for next version\nbut LIRC config files structure is the same. Please see it for details:   http://www.lirc.org/html/configuration-guide.html )", 
            "title": "LIRC driver software:"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#0mq-port", 
            "text": "20041", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#protocol-buffers", 
            "text": "message LircParams {\n  // IR remote device name\n  string device = 1;\n\n  // IR command\n  string command = 2;\n\n  //For transport of LIRC remote devices configuration.\n  string config = 3;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#keep-alives", 
            "text": "This driver NOT needs keep-alive messages  as specified in the CORE protocol .", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#errors", 
            "text": "This driver reports errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#write", 
            "text": "This driver need at last one LIRC remote configuration for send IR commands to any device. CORE LIRC driver support multiple remote controls in the same file and you can use a previous remote control recorded. You will can download this remotes config from MATRIX assets repository and then send it via  config  field of  LircParams  protobuf. For more details plese see JavaScript example described below.  Example for SONY RM-AAU014 : http://assets.admobilize.com/lirc-remotes/sony/RM-AAU014.lircd.conf", 
            "title": "Write"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#read", 
            "text": "This driver doesn't any data using CORE protocol. It only executes commands and sets configurations.  This is a sample output given by the example described below.  $ node test_ir_remote.js \n\ndownloading remote config..done.\nset remote to config..done.\nsending IR command: BTN_MUTING to SONY_RM device..done.\nsending IR command: BTN_MUTING to SONY_RM device..done.\nsending IR command: BTN_MUTING to SONY_RM device..done.  test_ir_remote  code first downloading remote config example then set it in CORE layer and then send IR commands", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.  var creator_ip = '127.0.0.1'\nvar creator_pressure_base_port = 20013 + 28", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#load-the-protocol-buffers-used-in-the-example", 
            "text": "var protoBuf = require( protobufjs );\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )", 
            "title": "Load the protocol buffers used in the example."
        }, 
        {
            "location": "/matrix-core/reference/lirc/#subscribe-to-the-errors-reported-by-the-driver-optional", 
            "text": "var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_lirc_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') +  \\n )\n});", 
            "title": "Subscribe to the errors reported by the driver (optional)"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#downloading-some-remote-control", 
            "text": "CORE Lirc driver support multiple remote controls in the same file. You can use a previous remote control recorded\nand downloading it from MATRIX assets repository like this:  var http = require('http');\nvar fs = require('fs');\n\nvar remote_url= http://assets.admobilize.com/lirc-remotes/sony/RM-AAU014.lircd.conf \nvar remote_output= RM-AAU014.lircd.conf \n\nfunction download (url, dest, cb) {\n  process.stdout.write('downloading remote config..')\n  var file = fs.createWriteStream(dest);\n  var request = http.get(url, function(response) {\n    response.pipe(file);\n    file.on('finish', function() {\n      console.log('done.')\n      file.close(cb(dest));\n    });\n  });\n}\ndownload(remote_url,remote_output,configRemote)", 
            "title": "Downloading some remote control"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#config-remote-device-on-core-layer", 
            "text": "All the drivers are configured using the message  driverconfig  (see  driver.proto ).  function configRemote(config){\n  process.stdout.write('set remote to config..')\n  // read previous config file downloaded\n  fs.readFile(config, 'utf8', function (err,data) {\n      if (err) { return console.log(err); }\n      // build proto message\n      var ir_cfg_cmd = new matrixMalosBuilder.LircParams\n      ir_cfg_cmd.set_config(data)\n      // send message in config proto\n      sendIRConfigProto(ir_cfg_cmd) \n      console.log('done.')\n  });\n}\n\n// Generic config proto function\nfunction sendIRConfigProto(ir_cfg){\n  var config = new matrixMalosBuilder.DriverConfig\n  config.set_lirc(ir_cfg)\n  configSocket.send(config.encode().toBuffer());\n}", 
            "title": "Config remote device on CORE layer"
        }, 
        {
            "location": "/matrix-core/reference/lirc/#send-remote-commands-to-target-device", 
            "text": "You can use similar flow for sending commands via DriverConfig proto.  function sendIrCommand(device, command) {\n  // build LircParams proto message\n  var ir_cfg_cmd = new matrixMalosBuilder.LircParams\n  // set device target like SONY device\n  ir_cfg_cmd.set_device(device)\n  // set device command like BTN_MUTING\n  ir_cfg_cmd.set_command(command)\n  sendIRConfigProto(ir_cfg_cmd) \n}\n\n// Optional sending continous IR commands\nfunction continousSendRemoteCommand(){\n  setInterval(function() {\n    process.stdout.write('sending IR command: BTN_MUTING to SONY_RM device..')\n    sendIrCommand('SONY_RM-AAU014','BTN_MUTING') // check LED on MATRIX\n    console.log('done.')\n  }, 3000);\n}", 
            "title": "Send remote commands to target device"
        }, 
        {
            "location": "/matrix-core/reference/pressure/", 
            "text": "Pressure\n\n\nThe Pressure driver reports values for:\n\n\n\n\nPressure\n\n\nAltitude\n\n\nTemperature\n\n\n\n\nThe driver follows the \nMATRIX CORE protocol\n.\n\n\n0MQ Port\n\n\n20025\n\n\n\n\nProtocol buffers\n\n\nmessage Pressure {\n  float pressure = 1;\n  float altitude = 2;\n  float temperature = 3;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the MATRIX CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThe driver will send a serialized message of type \nPressure\n.\n\n\nmessage Pressure {\n  float pressure = 1;\n  float altitude = 2;\n  float temperature = 3;\n}\n\n\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_pressure.js \nSending pings every 5 seconds\n{ pressure: 74773.5, altitude: 2490.375, temperature: 35.9375 }\n{ pressure: 74776, altitude: 2490.3125, temperature: 35.9375 }\n\n\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by MATRIX CORE for\nthe Pressure driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_pressure_base_port = 20013 + (4 * 3)\n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n)\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse MATRIX matrix_CORE package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver. \n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\nThis is what the message looks like if we omit the fields that are not used in this example.\n\n\nmessage DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}\n\n\n\nThe following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.\n\n\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_pressure_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n\n\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.Pressure.decode(buffer)\n  console.log(data)\n});\n\n\n\n\nAn empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 1))\nprocess.stdout.write(\nSending pings every 5 seconds\n);\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#pressure", 
            "text": "The Pressure driver reports values for:   Pressure  Altitude  Temperature   The driver follows the  MATRIX CORE protocol .", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#0mq-port", 
            "text": "20025", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#protocol-buffers", 
            "text": "message Pressure {\n  float pressure = 1;\n  float altitude = 2;\n  float temperature = 3;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the MATRIX CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#read", 
            "text": "The driver will send a serialized message of type  Pressure .  message Pressure {\n  float pressure = 1;\n  float altitude = 2;\n  float temperature = 3;\n}  This is a sample output given by the example described below.  $ node test_pressure.js \nSending pings every 5 seconds\n{ pressure: 74773.5, altitude: 2490.375, temperature: 35.9375 }\n{ pressure: 74776, altitude: 2490.3125, temperature: 35.9375 }", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by MATRIX CORE for\nthe Pressure driver.  var creator_ip = '127.0.0.1'\nvar creator_pressure_base_port = 20013 + (4 * 3)  Load the protocol buffers used in the example.  var protoBuf = require( protobufjs )\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse MATRIX matrix_CORE package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )  Subscribe to the errors reported by the driver.   var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') +  \\n )\n});  All the drivers are configured using the message  DriverConfig  (see  driver.proto ).\nThis is what the message looks like if we omit the fields that are not used in this example.  message DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}  The following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.  var configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_pressure_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())  Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.Pressure.decode(buffer)\n  console.log(data)\n});  An empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 1))\nprocess.stdout.write( Sending pings every 5 seconds );\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/servo/", 
            "text": "GPIO\n\n\nThe Servo driver on current version supports:\n\n\n\n\n\nHandle Servo via GPIO pin output\n\n\nSet Servo angle (180\u00f8 servo for the moment)\n\n\n\n\nThe driver follows the \nCORE protocol\n.\n\n\nGPIO electrical characteristics\n\n\n\n\nGPIO voltage: 0.60-4.10 VDC (\ndetails\n)\n\n\ncurrent 10mA max\n\n\nall GPIO pins need pullups\n\n\nrequiere external source for servo\n\n\n\n\n\n\n0MQ Port\n\n\n20045\n\n\n\n\nProtocol buffers\n\n\n// Servo handler params\nmessage ServoParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // Servo mode\n  uint32 angle = 2; \n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nErrors\n\n\nThis driver reports errors when an invalid configuration is sent.\n\n\nWrite\n\n\nAll pins on matrix creator start as inputs. You need to change the default settings. (see Javascript example below)\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_servo.js \nangle: 0\nangle: 10\nangle: 20\nangle: 30\nangle: 40\n\n\n\n\n(The servo motor will change by the different angles)\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_servo_base_port = 20013 + 32\n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n);\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nConnection to servo driver\n\n\nvar zmq = require('zmq')\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_servo_base_port /* config */)\n\n\n\n\nConfigure Servo GPIO pin and send angle:\n\n\nAll the drivers are configured using the message \ndriverconfig\n (see \ndriver.proto\n).\n\n\nfunction sendServoCommand() {\n  // build servo params message\n  var servo_cfg_cmd = new matrixMalosBuilder.ServoParams;\n  // Servo attached on GPIO13 (for example)\n  servo_cfg_cmd.set_pin(13);\n\n  // change angle on each tick\n  process.nextTick(function() {count=count+10});\n  var angle=count%180;\n  console.log('angle:',angle);\n\n  // set servo angle\n  servo_cfg_cmd.set_angle(angle);\n\n  // build DriverConfig message\n  var config = new matrixMalosBuilder.DriverConfig;\n  config.set_servo(servo_cfg_cmd);\n  configSocket.send(config.encode().toBuffer());\n}\n\n\n\n\nSend continuous configuration:\n\n\nsendServoCommand()\nsetInterval(function() {\n  sendServoCommand()\n}, 3000);", 
            "title": "Servo"
        }, 
        {
            "location": "/matrix-core/reference/servo/#gpio", 
            "text": "The Servo driver on current version supports:   Handle Servo via GPIO pin output  Set Servo angle (180\u00f8 servo for the moment)   The driver follows the  CORE protocol .", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/reference/servo/#gpio-electrical-characteristics", 
            "text": "GPIO voltage: 0.60-4.10 VDC ( details )  current 10mA max  all GPIO pins need pullups  requiere external source for servo", 
            "title": "GPIO electrical characteristics"
        }, 
        {
            "location": "/matrix-core/reference/servo/#0mq-port", 
            "text": "20045", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/servo/#protocol-buffers", 
            "text": "// Servo handler params\nmessage ServoParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // Servo mode\n  uint32 angle = 2; \n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/servo/#errors", 
            "text": "This driver reports errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/servo/#write", 
            "text": "All pins on matrix creator start as inputs. You need to change the default settings. (see Javascript example below)  This is a sample output given by the example described below.  $ node test_servo.js \nangle: 0\nangle: 10\nangle: 20\nangle: 30\nangle: 40  (The servo motor will change by the different angles)", 
            "title": "Write"
        }, 
        {
            "location": "/matrix-core/reference/servo/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.  var creator_ip = '127.0.0.1'\nvar creator_servo_base_port = 20013 + 32", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/servo/#load-the-protocol-buffers-used-in-the-example", 
            "text": "var protoBuf = require( protobufjs );\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )", 
            "title": "Load the protocol buffers used in the example."
        }, 
        {
            "location": "/matrix-core/reference/servo/#connection-to-servo-driver", 
            "text": "var zmq = require('zmq')\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_servo_base_port /* config */)", 
            "title": "Connection to servo driver"
        }, 
        {
            "location": "/matrix-core/reference/servo/#configure-servo-gpio-pin-and-send-angle", 
            "text": "All the drivers are configured using the message  driverconfig  (see  driver.proto ).  function sendServoCommand() {\n  // build servo params message\n  var servo_cfg_cmd = new matrixMalosBuilder.ServoParams;\n  // Servo attached on GPIO13 (for example)\n  servo_cfg_cmd.set_pin(13);\n\n  // change angle on each tick\n  process.nextTick(function() {count=count+10});\n  var angle=count%180;\n  console.log('angle:',angle);\n\n  // set servo angle\n  servo_cfg_cmd.set_angle(angle);\n\n  // build DriverConfig message\n  var config = new matrixMalosBuilder.DriverConfig;\n  config.set_servo(servo_cfg_cmd);\n  configSocket.send(config.encode().toBuffer());\n}", 
            "title": "Configure Servo GPIO pin and send angle:"
        }, 
        {
            "location": "/matrix-core/reference/servo/#send-continuous-configuration", 
            "text": "sendServoCommand()\nsetInterval(function() {\n  sendServoCommand()\n}, 3000);", 
            "title": "Send continuous configuration:"
        }, 
        {
            "location": "/matrix-core/reference/uv/", 
            "text": "UV\n\n\nThe UV driver reports values for:\n\n\n\n\nUV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From \nUV Index Scale\n \n\n\nUV Risk scale established by World Health Organization. From \nUV Index Scale\n\n\n\n\nThe driver follows the \nCORE protocol\n.\n\n\n0MQ Port\n\n\n20029\n\n\n\n\nProtocol buffers\n\n\nmessage UV{\n  float uv_index = 1;\n  string oms_risk = 2;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThe driver will send a serialized message of type\nUV\n.\n\n\nmessage UV{\n  float uv_index = 1;\n  string oms_risk = 2;\n}\n\n\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_uv.js \nSending pings every 5 seconds\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n\n\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe UV driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_uv_base_port = 20013 + (4 * 4) \n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n)\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver. \n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: UV error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\nThis is what the message looks like if we omit the fields that are not used in this example.\n\n\nmessage DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}\n\n\n\nThe following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.\n\n\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_uv_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n\n\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.UV.decode(buffer)\n  console.log(data)\n});\n\n\n\n\nAn empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 1))\nprocess.stdout.write(\nSending pings every 5 seconds\n);\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/reference/uv/#uv", 
            "text": "The UV driver reports values for:   UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From  UV Index Scale    UV Risk scale established by World Health Organization. From  UV Index Scale   The driver follows the  CORE protocol .", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/reference/uv/#0mq-port", 
            "text": "20029", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/uv/#protocol-buffers", 
            "text": "message UV{\n  float uv_index = 1;\n  string oms_risk = 2;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/uv/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/uv/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/uv/#read", 
            "text": "The driver will send a serialized message of type UV .  message UV{\n  float uv_index = 1;\n  string oms_risk = 2;\n}  This is a sample output given by the example described below.  $ node test_uv.js \nSending pings every 5 seconds\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/uv/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe UV driver.  var creator_ip = '127.0.0.1'\nvar creator_uv_base_port = 20013 + (4 * 4)   Load the protocol buffers used in the example.  var protoBuf = require( protobufjs )\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )  Subscribe to the errors reported by the driver.   var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: UV error: ' + error_message.toString('utf8') +  \\n )\n});  All the drivers are configured using the message  DriverConfig  (see  driver.proto ).\nThis is what the message looks like if we omit the fields that are not used in this example.  message DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}  The following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.  var configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_uv_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())  Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.UV.decode(buffer)\n  console.log(data)\n});  An empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 1))\nprocess.stdout.write( Sending pings every 5 seconds );\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/troubleshooting/", 
            "text": "Check MATRIX CORE Services are Running\n\n\nRun the following command on your Raspberry Pi to confirm your MATRIX Services are running.\n\n\n$ ps aux | grep 'malos'\n\n\n\n\nThis should return something along the lines of:\n\n\nroot       445  0.0  0.6 126240  5964 ?        Ssl  16:51   0:00 /usr/bin/malos_eye\nroot       449  5.3  0.8 853204  8352 ?        Ssl  16:51   4:41 /usr/bin/malos\n\n\n\n\nRunning Services Manually\n\n\nIf your services are not listed as shown above, you can run them manually using the following terminal commands:\n\n\n# Running MATRIX CORE Sensors \n Comm. Services\n$ malos\n\n# Running MATRIX CORE Vision Services\n$ malos_eye\n\n\n\n\nStopping Services\n\n\n# Stopping the services altogether\n\n$ pkill -9 malos\n$ pkill -9 malos_eye\n\n\n\n\nSupport\n\n\n\n\nPost questions or comments on \ncommunity.matrix.one\n\n\nPost package issues on github under \nmatrix-io\n\n\nSubmit documentation issues or improvements at \nmatrix-io/matrix-documentation", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#check-matrix-core-services-are-running", 
            "text": "Run the following command on your Raspberry Pi to confirm your MATRIX Services are running.  $ ps aux | grep 'malos'  This should return something along the lines of:  root       445  0.0  0.6 126240  5964 ?        Ssl  16:51   0:00 /usr/bin/malos_eye\nroot       449  5.3  0.8 853204  8352 ?        Ssl  16:51   4:41 /usr/bin/malos", 
            "title": "Check MATRIX CORE Services are Running"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#running-services-manually", 
            "text": "If your services are not listed as shown above, you can run them manually using the following terminal commands:  # Running MATRIX CORE Sensors   Comm. Services\n$ malos\n\n# Running MATRIX CORE Vision Services\n$ malos_eye", 
            "title": "Running Services Manually"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#stopping-services", 
            "text": "# Stopping the services altogether\n\n$ pkill -9 malos\n$ pkill -9 malos_eye", 
            "title": "Stopping Services"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#support", 
            "text": "Post questions or comments on  community.matrix.one  Post package issues on github under  matrix-io  Submit documentation issues or improvements at  matrix-io/matrix-documentation", 
            "title": "Support"
        }, 
        {
            "location": "/matrix-hal/", 
            "text": "Overview\n\n\nHAL is the lowest-level abstraction for the MATRIX Creator drivers. You can interface directly with HAL, or use the higher level components like \nCORE\n, and \nMATRIX OS\n.\n\n\nTooling\n\n\n\n\nxc3sprog\n - To program the FPGA.\n\n\nOpenOCD\n - To program the microcontroller.\n\n\n\n\nBoards\n\n\n\n\nCreator\n\n\nVoice\n\n\n\n\nHardware Integrations\n\n\n\n\nFPGA\n\n\nHAL\n\n\nMicrophone\n\n\n\n\nExample Software Integrations\n\n\n\n\nMATRIX CORE\n\n\nMATRIX OS\n\n\n\n\nComponents\n\n\n\n\nPinout\n\n\nFPGA\n\n\nSAM3\n\n\nSAM3MCU\n\n\nMicrophone\n\n\nSPI", 
            "title": "MATRIX HAL"
        }, 
        {
            "location": "/matrix-hal/#overview", 
            "text": "HAL is the lowest-level abstraction for the MATRIX Creator drivers. You can interface directly with HAL, or use the higher level components like  CORE , and  MATRIX OS .", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/#tooling", 
            "text": "xc3sprog  - To program the FPGA.  OpenOCD  - To program the microcontroller.", 
            "title": "Tooling"
        }, 
        {
            "location": "/matrix-hal/#boards", 
            "text": "Creator  Voice", 
            "title": "Boards"
        }, 
        {
            "location": "/matrix-hal/#hardware-integrations", 
            "text": "FPGA  HAL  Microphone", 
            "title": "Hardware Integrations"
        }, 
        {
            "location": "/matrix-hal/#example-software-integrations", 
            "text": "MATRIX CORE  MATRIX OS", 
            "title": "Example Software Integrations"
        }, 
        {
            "location": "/matrix-hal/#components", 
            "text": "Pinout  FPGA  SAM3  SAM3MCU  Microphone  SPI", 
            "title": "Components"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/", 
            "text": "Installation\n\n\nsudo apt-get install cmake g++ git\ngit clone https://github.com/matrix-io/matrix-creator-hal.git\n\n\n\n\nBuild\n\n\nTo start working with HAL directly, you'll need to run \nsudo make install\n to get the build running. \n\n\n$ mkdir build\n$ cd build\n$ cmake ..\n$ make \n sudo make install\n[100%] Built target matrix_creator_hal\nInstall the project...\n-- Install configuration: \n\n-- Up-to-date: /usr/local/lib/libmatrix_creator_hal.a\n-- Installing: /usr/local/include/matrix_hal/creator_memory_map.h\n-- Installing: /usr/local/include/matrix_hal/everloop.h\n-- Installing: /usr/local/include/matrix_hal/humidity_data.h\n-- Installing: /usr/local/include/matrix_hal/imu_sensor.h\n-- Installing: /usr/local/include/matrix_hal/pressure_data.h\n-- Installing: /usr/local/include/matrix_hal/dummy_data.h\n-- Installing: /usr/local/include/matrix_hal/everloop_image.h\n-- Installing: /usr/local/include/matrix_hal/humidity_sensor.h\n-- Installing: /usr/local/include/matrix_hal/matrix_driver.h\n-- Installing: /usr/local/include/matrix_hal/pressure_sensor.h\n-- Installing: /usr/local/include/matrix_hal/dummy_sensor.h\n-- Installing: /usr/local/include/matrix_hal/gpio_control.h\n-- Installing: /usr/local/include/matrix_hal/imu_data.h\n-- Installing: /usr/local/include/matrix_hal/microphone_array.h\n-- Installing: /usr/local/include/matrix_hal/wishbone_bus.h\n\n\n\n\nContinue\n\n\n\n\nDo \nHello World\n\n\nTry out the \nhardware demos\n available inside the \ndemos\n directory.\n\n\nWrite and run your own HAL abstraction layer by using our \nComponent\n documentation.", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/#installation", 
            "text": "sudo apt-get install cmake g++ git\ngit clone https://github.com/matrix-io/matrix-creator-hal.git", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/#build", 
            "text": "To start working with HAL directly, you'll need to run  sudo make install  to get the build running.   $ mkdir build\n$ cd build\n$ cmake ..\n$ make   sudo make install\n[100%] Built target matrix_creator_hal\nInstall the project...\n-- Install configuration:  \n-- Up-to-date: /usr/local/lib/libmatrix_creator_hal.a\n-- Installing: /usr/local/include/matrix_hal/creator_memory_map.h\n-- Installing: /usr/local/include/matrix_hal/everloop.h\n-- Installing: /usr/local/include/matrix_hal/humidity_data.h\n-- Installing: /usr/local/include/matrix_hal/imu_sensor.h\n-- Installing: /usr/local/include/matrix_hal/pressure_data.h\n-- Installing: /usr/local/include/matrix_hal/dummy_data.h\n-- Installing: /usr/local/include/matrix_hal/everloop_image.h\n-- Installing: /usr/local/include/matrix_hal/humidity_sensor.h\n-- Installing: /usr/local/include/matrix_hal/matrix_driver.h\n-- Installing: /usr/local/include/matrix_hal/pressure_sensor.h\n-- Installing: /usr/local/include/matrix_hal/dummy_sensor.h\n-- Installing: /usr/local/include/matrix_hal/gpio_control.h\n-- Installing: /usr/local/include/matrix_hal/imu_data.h\n-- Installing: /usr/local/include/matrix_hal/microphone_array.h\n-- Installing: /usr/local/include/matrix_hal/wishbone_bus.h", 
            "title": "Build"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/#continue", 
            "text": "Do  Hello World  Try out the  hardware demos  available inside the  demos  directory.  Write and run your own HAL abstraction layer by using our  Component  documentation.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-hal/getting-started/hello-world/", 
            "text": "Basic Examples\n\n\nBasic examples can be found inside the \ndemo\n directory inside of the repository that you cloned during \ninstallation\n. Below we'll get you started with the Everloop demo which should turn the LEDs a \nblue\n color.\n\n\n# should already be in ~/matrix-creator-hal/build directory.\ncd demos\n\n# run the everloop demo\n./everloop_demo\n\n# see the rest of the examples\nls -l\n\n\n\n\nContinue\n\n\nMove onto the rest of the \nJavascript\n or \nPython\n examples.", 
            "title": "Hello World"
        }, 
        {
            "location": "/matrix-hal/getting-started/hello-world/#basic-examples", 
            "text": "Basic examples can be found inside the  demo  directory inside of the repository that you cloned during  installation . Below we'll get you started with the Everloop demo which should turn the LEDs a  blue  color.  # should already be in ~/matrix-creator-hal/build directory.\ncd demos\n\n# run the everloop demo\n./everloop_demo\n\n# see the rest of the examples\nls -l", 
            "title": "Basic Examples"
        }, 
        {
            "location": "/matrix-hal/getting-started/hello-world/#continue", 
            "text": "Move onto the rest of the  Javascript  or  Python  examples.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-hal/getting-started/next-steps/", 
            "text": "Next Steps\n\n\nShare your creation\n\n\nShow us know what you've made and we'll share it to our channels! \n\n\n\n\nMATRIX Community\n\n\nTutorials/Projects Pages\n\n\nVideos\n\n\nMATRIX Twitter", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-hal/getting-started/next-steps/#next-steps", 
            "text": "", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-hal/getting-started/next-steps/#share-your-creation", 
            "text": "Show us know what you've made and we'll share it to our channels!    MATRIX Community  Tutorials/Projects Pages  Videos  MATRIX Twitter", 
            "title": "Share your creation"
        }, 
        {
            "location": "/matrix-hal/datasheets/creator/", 
            "text": "MATRIX Creator\n\n\n\n\nTechnical Datasheets:\n\n\n\n\n\n\nAtmel 32 bits Cortex M3 SAM3S2\n\n\n\n\n\n\nXilinx Spartan 6S XC6SLX4 FPGA\n\n\n\n\n\n\n8 MEMS audio sensor digital microphones\n\n\n\n\n\n\nST LSM9DS1 3D accelerometer, 3D gyroscope, 3D magnetometer\n\n\n\n\n\n\nST HTS221 digital sensor for relative humidity and temperature\n\n\n\n\n\n\nNXP PN512 NFC reader\n\n\n\n\n\n\nNXP MPL3115A2 Altimeter\n\n\n\n\n\n\nVishay VEML6070 UV Light Sensor\n\n\n\n\n\n\nVishay INFRARED Receptor\n\n\n\n\n\n\nRGBW everloop LED", 
            "title": "Creator"
        }, 
        {
            "location": "/matrix-hal/datasheets/creator/#matrix-creator", 
            "text": "", 
            "title": "MATRIX Creator"
        }, 
        {
            "location": "/matrix-hal/datasheets/creator/#technical-datasheets", 
            "text": "Atmel 32 bits Cortex M3 SAM3S2    Xilinx Spartan 6S XC6SLX4 FPGA    8 MEMS audio sensor digital microphones    ST LSM9DS1 3D accelerometer, 3D gyroscope, 3D magnetometer    ST HTS221 digital sensor for relative humidity and temperature    NXP PN512 NFC reader    NXP MPL3115A2 Altimeter    Vishay VEML6070 UV Light Sensor    Vishay INFRARED Receptor    RGBW everloop LED", 
            "title": "Technical Datasheets:"
        }, 
        {
            "location": "/matrix-hal/datasheets/voice/", 
            "text": "MATRIX Voice\n\n\nMATRIX Voice is an open-source VOICE RECOGNITION platform consisting of a 3.14-inches in diameter dev board, with a radial array of 8 MEMS microphones connected to a Xilinx Spartan 6 FPGA \n 64 Mbit Flash, a 512Mbit SDRAM and 18 RGBW LED\u2019s.\n\n\nTop View\n\n\n\n\nBottom View\n\n\n\n\nSystem Architecture\n\n\n\n\nVoice Engine Integrations\n\n\n\n\nAlexa\n\n\n\n\nTechnical Datasheets\n\n\n\n\nXilinx Spartan 6 FPGA - XC6SLX9-2FTG256C\n\n\n8 MEMS audio sensor digital microphones - MP34DB02\n\n\nSerial Flash 64MBIT - MX25L6406E\n\n\nDDR2 SDRAM 512MBIT - MT47H32M16\n\n\n3W Stereo Class-D Audio Amplifier and Class-AB Headphone Driver - PAM8019\n\n\nRGBW LED - SK6812RGBW\n\n\nESP32-WROOM", 
            "title": "Voice"
        }, 
        {
            "location": "/matrix-hal/datasheets/voice/#matrix-voice", 
            "text": "MATRIX Voice is an open-source VOICE RECOGNITION platform consisting of a 3.14-inches in diameter dev board, with a radial array of 8 MEMS microphones connected to a Xilinx Spartan 6 FPGA   64 Mbit Flash, a 512Mbit SDRAM and 18 RGBW LED\u2019s.", 
            "title": "MATRIX Voice"
        }, 
        {
            "location": "/matrix-hal/datasheets/voice/#top-view", 
            "text": "", 
            "title": "Top View"
        }, 
        {
            "location": "/matrix-hal/datasheets/voice/#bottom-view", 
            "text": "", 
            "title": "Bottom View"
        }, 
        {
            "location": "/matrix-hal/datasheets/voice/#system-architecture", 
            "text": "", 
            "title": "System Architecture"
        }, 
        {
            "location": "/matrix-hal/datasheets/voice/#voice-engine-integrations", 
            "text": "Alexa", 
            "title": "Voice Engine Integrations"
        }, 
        {
            "location": "/matrix-hal/datasheets/voice/#technical-datasheets", 
            "text": "Xilinx Spartan 6 FPGA - XC6SLX9-2FTG256C  8 MEMS audio sensor digital microphones - MP34DB02  Serial Flash 64MBIT - MX25L6406E  DDR2 SDRAM 512MBIT - MT47H32M16  3W Stereo Class-D Audio Amplifier and Class-AB Headphone Driver - PAM8019  RGBW LED - SK6812RGBW  ESP32-WROOM", 
            "title": "Technical Datasheets"
        }, 
        {
            "location": "/matrix-hal/components/", 
            "text": "Components\n\n\n\n\nPinout\n\n\nFPGA\n\n\nSAM3\n\n\nSAM3MCU\n\n\nMicrophone\n\n\nSPI", 
            "title": "Components"
        }, 
        {
            "location": "/matrix-hal/components/#components", 
            "text": "Pinout  FPGA  SAM3  SAM3MCU  Microphone  SPI", 
            "title": "Components"
        }, 
        {
            "location": "/matrix-hal/components/fpga/", 
            "text": "FPGA\n\n\nOnce you have installed the \nrequired software\n you can program the FPGA. This will allow you to play with the everloop LED array.\n\n\nFirst, get the firmware.\n\n\nwget http://packages.matrix.one/matrix-creator-firmware/firmware-0.8.tar.gz\ntar xzvf firmware-0.8.tar.gz\n\n\n\nThen flash the firmware using the \nxc3sprog\n program that should be installed on the Raspberry.\n\n\nsudo xc3sprog -c matrix_pi firmware-0.8/blob/system.bit -p 1\n\n\n\nSample result:\n\n\n$ sudo xc3sprog -c matrix_pi firmware-0.8/blob/system.bit -p 1\nXC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n    http://sourceforge.net/mail/?group_id=170565 \nCheck Sourceforge for updates:\n    http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0x39c620e4bfe15bfd\n\n\n\nQuestions? Post them on \nraspberrypi.stackexchange.com\n! Use the tag #matrix-creator", 
            "title": "FPGA"
        }, 
        {
            "location": "/matrix-hal/components/fpga/#fpga", 
            "text": "Once you have installed the  required software  you can program the FPGA. This will allow you to play with the everloop LED array.  First, get the firmware.  wget http://packages.matrix.one/matrix-creator-firmware/firmware-0.8.tar.gz\ntar xzvf firmware-0.8.tar.gz  Then flash the firmware using the  xc3sprog  program that should be installed on the Raspberry.  sudo xc3sprog -c matrix_pi firmware-0.8/blob/system.bit -p 1  Sample result:  $ sudo xc3sprog -c matrix_pi firmware-0.8/blob/system.bit -p 1\nXC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux\nFree software: If you contribute nothing, expect nothing!\nFeedback on success/failure/enhancement requests:\n    http://sourceforge.net/mail/?group_id=170565 \nCheck Sourceforge for updates:\n    http://sourceforge.net/projects/xc3sprog/develop\n\nDNA is 0x39c620e4bfe15bfd  Questions? Post them on  raspberrypi.stackexchange.com ! Use the tag #matrix-creator", 
            "title": "FPGA"
        }, 
        {
            "location": "/matrix-hal/components/microphone/", 
            "text": "Microphone\n\n\n1. Mic Array on MATRIX Creator\n\n\n\n\nPosition [x,y] of each mic in the array:\n\n\n\n\n\n\n\n\nMic\n\n\nX\n\n\nY\n\n\n\n\n\n\n\n\n\n\nM1\n\n\n20.0908795\n\n\n-48.5036755\n\n\n\n\n\n\nM2\n\n\n-20.0908795\n\n\n-48.5036755\n\n\n\n\n\n\nM3\n\n\n-48.5036755\n\n\n-20.0908795\n\n\n\n\n\n\nM4\n\n\n-48.5036755\n\n\n20.0908795\n\n\n\n\n\n\nM5\n\n\n-20.0908795\n\n\n48.5036755\n\n\n\n\n\n\nM6\n\n\n20.0908795\n\n\n48.5036755\n\n\n\n\n\n\nM7\n\n\n48.5036755\n\n\n20.0908795\n\n\n\n\n\n\nM8\n\n\n48.5036755\n\n\n-20.0908795\n\n\n\n\n\n\n\n\nConnection to the FPGA\n\n\nfrom the \ncreator.ucf\n :\n\n\n\n\n\n\n\n\nMic\n\n\nFPGA pin\n\n\nPDM_Data\n\n\n\n\n\n\n\n\n\n\nM1\n\n\nP45\n\n\npdm_data\n0\n\n\n\n\n\n\nM2\n\n\nP46\n\n\npdm_data\n1\n\n\n\n\n\n\nM3\n\n\nP47\n\n\npdm_data\n2\n\n\n\n\n\n\nM4\n\n\nP58\n\n\npdm_data\n3\n\n\n\n\n\n\nM5\n\n\nP59\n\n\npdm_data\n4\n\n\n\n\n\n\nM6\n\n\nP64\n\n\npdm_data\n5\n\n\n\n\n\n\nM7\n\n\nP65\n\n\npdm_data\n6\n\n\n\n\n\n\nM8\n\n\nP44\n\n\npdm_data\n7\n\n\n\n\n\n\nCLK\n\n\nP47\n\n\npdm_clk\n\n\n\n\n\n\n\n\nAudio specs:\n\n\nSample Rate: 16 kHz\nBit Depth: 16 bit\n\n\nNote\n: An option for setting higher sample rates will be released soon.  Please keep in touch in the community announcements channel http://community.matrix.one/c/announcements.\n\n\nMicrophones Datasheet:\n\n\nMP34DB02 - MEMS audio sensor omnidirectional digital microphone\n \n\n\n2. How to get microphone data from C++\n\n\nYou can use our lower software layer in C++ called HAL () (Hardware Abstraction Layer) to read data from the microphones.\n\n\nGetting and Compiling HAL\n\n\ngit clone https://github.com/matrix-io/matrix-creator-hal.git\ncd matrix-creator-hal \nmkdir build \n cd build\ncmake ..\nmake\n\n\n\nExample code\n\n\nThe following example gets samples from all channels (mics) collected by the fpga.  \n\n\n... \nint main() {\n    hal::WishboneBus bus;\n    bus.SpiInit();\n    hal::MicrophoneArray mics;\n    mics.Setup(\nbus);\n    std::valarray\nfloat\n magnitude(mics.Channels());\n\n    mics.SetGain(8);\n    std::cout \n \"M1\\t\" \n \"M2\\t\" \n \"M3\\t\" \n \"M4\\t\" \n \"M5\\t\" \n \"M6\\t\" \n \"M7\\t\" \n \"M8\\t\" \n std::endl;\n\n    while (true) {\n        mics.Read();\n        magnitude = 0.0;\n        for (unsigned int s = 0; s \n mics.NumberOfSamples(); s++) {\n            for (unsigned int c = 0; c \n mics.Channels(); c++) {\n              magnitude[c] = mics.At(s, c);\n              std::cout \n  magnitude[c] \n \"\\t\";\n            }\n            std::cout \n std::endl;\n        }\n    }\n    return 0;\n}\n\n\n\n3. Example demo apps for mics\n\n\nThe demo apps are in the folder \nmatrix-creator-hal/demos/\n . They are built with HAL. To run them go to the demo folder :\n\n\ncd build/demos\n./mic_demo\n\n\n\nnote: You can play with the demos to learn how to use HAL, and them use them as starting points for your own apps.\n\n\nmic_demo\n\n\nThis demo maps each mic audio input to one specific led on the Everloop. You can make sounds close to the MATRIX Creator and see how the LEDs turn green when a sound is detected. Also the demo prints in the terminal the audio as numbers, e.g.:\n\n\ncd build/demos\n./mic_demo\n0   0   0   0   0   0   0   0   \n0   0   0   0   0   0   0   0   \n6   6   6   6   6   4   5   6   \n3   6   4   4   2   2   2   2   \n0   0   0   0   0   0   0   0   \n0   0   0   0   0   0   0   0   \n0   0   0   0   0   0   0   0   \n3   5   5   4   4   4   5   4   \n5   6   6   6   6   5   6   5   \n1   0   1   2   2   1   1   1   \n0   1   1   1   1   1   1   1   \n0   1   1   0   1   0   0   0   \n...\n\n\n\nmic_energy\n\n\nThis demo is similar but instead of mapping the mic's audio individually takes all channels and maps the average of all mics. It maps at the same time in all LEDs and creates a very voice responsive red light. This demos does not print anything on the terminal.\n\n\ncd build/demos\n./mic_energy\n\n\n\nmicarray_recorder\n\n\nThis demo records audio from all 8 channels (0-7) and the beamforming channel (channel 8) to raw files located in the same folder. After you launching the demo you will have these files:\n\n\ncd build/demos\n./micarray_recorder\n\n\n\nThe default example records audio to raw files for 10 seconds and then stops. After recording the files are on the same folder \n/demos\n :\n\n\ncd build/demos\nls | grep raw\nmic_16000_s16le_channel_0.raw\nmic_16000_s16le_channel_1.raw\nmic_16000_s16le_channel_2.raw\nmic_16000_s16le_channel_3.raw\nmic_16000_s16le_channel_4.raw\nmic_16000_s16le_channel_5.raw\nmic_16000_s16le_channel_6.raw\nmic_16000_s16le_channel_7.raw\nmic_16000_s16le_channel_8.raw\n\n\n\nnote: The data in the raw files is written in \nint16_t\n. \n\n\ndirection_of_arrival_demo\n\n\nThis demo shows a first implementation of direction of arrival detection. It shows the direction of arrival using the LEDs and also prints the result angle in the terminal. To test it run the demo and make sounds from different directions to the MATRIX Creator board to see how. \n\n\n./direction_of_arrival_demo\nazimutal angle = 0, polar angle = 0, mic = 0\nazimutal angle = 0, polar angle = 0, mic = 0\nazimutal angle = -157.5, polar angle = 18, mic = 2\nazimutal angle = -157.5, polar angle = 18, mic = 2\nazimutal angle = -157.5, polar angle = 18, mic = 2\nazimutal angle = 22.5, polar angle = 36, mic = 6\nazimutal angle = -157.5, polar angle = 54, mic = 2\nazimutal angle = -157.5, polar angle = 72, mic = 2\nazimutal angle = -157.5, polar angle = 72, mic = 2\n\n\n\nRecord, Convert and Play sounds.\n\n\nUpdate and upgrade Raspbian\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\nInstall \nAlsa tools\n and the \nsox\n utility\n\n\nsudo apt-get install sox alsa-utils\n\n\n\nRun the volume control\n\n\nalsamixer\n\n\n\nRun capture and check the recorded files\n\n\ncd demos\n./micarray_recorder\nls -1 *raw\n\n\n\nConvert the audio\n\n\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_0.raw channel_0.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_1.raw channel_1.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_2.raw channel_2.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_3.raw channel_3.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_4.raw channel_4.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_5.raw channel_5.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_6.raw channel_6.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_7.raw channel_7.wav\n\n\n\nPlay the wav file (i.e. audio from channel 0)\n\n\naplay channel_0.wav", 
            "title": "Microphone"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#microphone", 
            "text": "", 
            "title": "Microphone"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#1-mic-array-on-matrix-creator", 
            "text": "", 
            "title": "1. Mic Array on MATRIX Creator"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#position-xy-of-each-mic-in-the-array", 
            "text": "Mic  X  Y      M1  20.0908795  -48.5036755    M2  -20.0908795  -48.5036755    M3  -48.5036755  -20.0908795    M4  -48.5036755  20.0908795    M5  -20.0908795  48.5036755    M6  20.0908795  48.5036755    M7  48.5036755  20.0908795    M8  48.5036755  -20.0908795", 
            "title": "Position [x,y] of each mic in the array:"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#connection-to-the-fpga", 
            "text": "from the  creator.ucf  :     Mic  FPGA pin  PDM_Data      M1  P45  pdm_data 0    M2  P46  pdm_data 1    M3  P47  pdm_data 2    M4  P58  pdm_data 3    M5  P59  pdm_data 4    M6  P64  pdm_data 5    M7  P65  pdm_data 6    M8  P44  pdm_data 7    CLK  P47  pdm_clk", 
            "title": "Connection to the FPGA"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#audio-specs", 
            "text": "Sample Rate: 16 kHz\nBit Depth: 16 bit  Note : An option for setting higher sample rates will be released soon.  Please keep in touch in the community announcements channel http://community.matrix.one/c/announcements.", 
            "title": "Audio specs:"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#microphones-datasheet", 
            "text": "MP34DB02 - MEMS audio sensor omnidirectional digital microphone", 
            "title": "Microphones Datasheet:"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#2-how-to-get-microphone-data-from-c", 
            "text": "You can use our lower software layer in C++ called HAL () (Hardware Abstraction Layer) to read data from the microphones.", 
            "title": "2. How to get microphone data from C++"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#getting-and-compiling-hal", 
            "text": "git clone https://github.com/matrix-io/matrix-creator-hal.git\ncd matrix-creator-hal \nmkdir build   cd build\ncmake ..\nmake", 
            "title": "Getting and Compiling HAL"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#example-code", 
            "text": "The following example gets samples from all channels (mics) collected by the fpga.    ... \nint main() {\n    hal::WishboneBus bus;\n    bus.SpiInit();\n    hal::MicrophoneArray mics;\n    mics.Setup( bus);\n    std::valarray float  magnitude(mics.Channels());\n\n    mics.SetGain(8);\n    std::cout   \"M1\\t\"   \"M2\\t\"   \"M3\\t\"   \"M4\\t\"   \"M5\\t\"   \"M6\\t\"   \"M7\\t\"   \"M8\\t\"   std::endl;\n\n    while (true) {\n        mics.Read();\n        magnitude = 0.0;\n        for (unsigned int s = 0; s   mics.NumberOfSamples(); s++) {\n            for (unsigned int c = 0; c   mics.Channels(); c++) {\n              magnitude[c] = mics.At(s, c);\n              std::cout    magnitude[c]   \"\\t\";\n            }\n            std::cout   std::endl;\n        }\n    }\n    return 0;\n}", 
            "title": "Example code"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#3-example-demo-apps-for-mics", 
            "text": "The demo apps are in the folder  matrix-creator-hal/demos/  . They are built with HAL. To run them go to the demo folder :  cd build/demos\n./mic_demo  note: You can play with the demos to learn how to use HAL, and them use them as starting points for your own apps.", 
            "title": "3. Example demo apps for mics"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#mic_demo", 
            "text": "This demo maps each mic audio input to one specific led on the Everloop. You can make sounds close to the MATRIX Creator and see how the LEDs turn green when a sound is detected. Also the demo prints in the terminal the audio as numbers, e.g.:  cd build/demos\n./mic_demo\n0   0   0   0   0   0   0   0   \n0   0   0   0   0   0   0   0   \n6   6   6   6   6   4   5   6   \n3   6   4   4   2   2   2   2   \n0   0   0   0   0   0   0   0   \n0   0   0   0   0   0   0   0   \n0   0   0   0   0   0   0   0   \n3   5   5   4   4   4   5   4   \n5   6   6   6   6   5   6   5   \n1   0   1   2   2   1   1   1   \n0   1   1   1   1   1   1   1   \n0   1   1   0   1   0   0   0   \n...", 
            "title": "mic_demo"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#mic_energy", 
            "text": "This demo is similar but instead of mapping the mic's audio individually takes all channels and maps the average of all mics. It maps at the same time in all LEDs and creates a very voice responsive red light. This demos does not print anything on the terminal.  cd build/demos\n./mic_energy", 
            "title": "mic_energy"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#micarray_recorder", 
            "text": "This demo records audio from all 8 channels (0-7) and the beamforming channel (channel 8) to raw files located in the same folder. After you launching the demo you will have these files:  cd build/demos\n./micarray_recorder  The default example records audio to raw files for 10 seconds and then stops. After recording the files are on the same folder  /demos  :  cd build/demos\nls | grep raw\nmic_16000_s16le_channel_0.raw\nmic_16000_s16le_channel_1.raw\nmic_16000_s16le_channel_2.raw\nmic_16000_s16le_channel_3.raw\nmic_16000_s16le_channel_4.raw\nmic_16000_s16le_channel_5.raw\nmic_16000_s16le_channel_6.raw\nmic_16000_s16le_channel_7.raw\nmic_16000_s16le_channel_8.raw  note: The data in the raw files is written in  int16_t .", 
            "title": "micarray_recorder"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#direction_of_arrival_demo", 
            "text": "This demo shows a first implementation of direction of arrival detection. It shows the direction of arrival using the LEDs and also prints the result angle in the terminal. To test it run the demo and make sounds from different directions to the MATRIX Creator board to see how.   ./direction_of_arrival_demo\nazimutal angle = 0, polar angle = 0, mic = 0\nazimutal angle = 0, polar angle = 0, mic = 0\nazimutal angle = -157.5, polar angle = 18, mic = 2\nazimutal angle = -157.5, polar angle = 18, mic = 2\nazimutal angle = -157.5, polar angle = 18, mic = 2\nazimutal angle = 22.5, polar angle = 36, mic = 6\nazimutal angle = -157.5, polar angle = 54, mic = 2\nazimutal angle = -157.5, polar angle = 72, mic = 2\nazimutal angle = -157.5, polar angle = 72, mic = 2", 
            "title": "direction_of_arrival_demo"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#record-convert-and-play-sounds", 
            "text": "", 
            "title": "Record, Convert and Play sounds."
        }, 
        {
            "location": "/matrix-hal/components/microphone/#update-and-upgrade-raspbian", 
            "text": "sudo apt-get update\nsudo apt-get upgrade", 
            "title": "Update and upgrade Raspbian"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#install-alsa-tools-and-the-sox-utility", 
            "text": "sudo apt-get install sox alsa-utils", 
            "title": "Install Alsa tools and the sox utility"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#run-the-volume-control", 
            "text": "alsamixer", 
            "title": "Run the volume control"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#run-capture-and-check-the-recorded-files", 
            "text": "cd demos\n./micarray_recorder\nls -1 *raw", 
            "title": "Run capture and check the recorded files"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#convert-the-audio", 
            "text": "sox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_0.raw channel_0.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_1.raw channel_1.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_2.raw channel_2.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_3.raw channel_3.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_4.raw channel_4.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_5.raw channel_5.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_6.raw channel_6.wav\nsox -r 16000 -c 1 -e signed -c 1 -e signed -b 16 mic_16000_s16le_channel_7.raw channel_7.wav", 
            "title": "Convert the audio"
        }, 
        {
            "location": "/matrix-hal/components/microphone/#play-the-wav-file-ie-audio-from-channel-0", 
            "text": "aplay channel_0.wav", 
            "title": "Play the wav file (i.e. audio from channel 0)"
        }, 
        {
            "location": "/matrix-hal/components/Sam3/", 
            "text": "SAM3 Firmware Flash\n\n\nThis firmware is used to read the sensors. You can build it in your host machine, and then copy the resulting binary to the Raspberry Pi.\n\n\nFirst, you need to compile the firmware. You can do it in the Rasbperry Pi (if you have enough space available) or in your host machine if you want to do it faster.\n\n\napt-get install gcc-arm-none-eabi\ngit clone https://github.com/matrix-io/matrix-creator-mcu\ncd  matrix-creator-mcu/creator \n make\n\n\n\n\nNow copy build/ch.bin to the Rasbperry Pi (if you didn't build there) and \nflash it\n. In order to flash it you need to replace the file blob/ch.bin (or edit the cfg/sam3s.cfg configuration file).\n\n\nAnd only then you can flash the SAM3 firmware.\n\n\nsudo openocd -f cfg/sam3s.cfg\n\n\n\n\nQuestions? Post them on \nhttp://raspberrypi.stackexchange.com\n! Use the tag #matrix-creator", 
            "title": "SAM3"
        }, 
        {
            "location": "/matrix-hal/components/Sam3/#sam3-firmware-flash", 
            "text": "This firmware is used to read the sensors. You can build it in your host machine, and then copy the resulting binary to the Raspberry Pi.  First, you need to compile the firmware. You can do it in the Rasbperry Pi (if you have enough space available) or in your host machine if you want to do it faster.  apt-get install gcc-arm-none-eabi\ngit clone https://github.com/matrix-io/matrix-creator-mcu\ncd  matrix-creator-mcu/creator   make  Now copy build/ch.bin to the Rasbperry Pi (if you didn't build there) and  flash it . In order to flash it you need to replace the file blob/ch.bin (or edit the cfg/sam3s.cfg configuration file).  And only then you can flash the SAM3 firmware.  sudo openocd -f cfg/sam3s.cfg  Questions? Post them on  http://raspberrypi.stackexchange.com ! Use the tag #matrix-creator", 
            "title": "SAM3 Firmware Flash"
        }, 
        {
            "location": "/matrix-hal/components/Sam3mcu/", 
            "text": "Sam3 MCU Programming\n\n\nOnce you have installed the \nrequired software\n you can program the SAM3 MCU. The MCU is used to read the sensors.\n\n\nThis firmware is free software and \nyou can compile it yourself\n. Here we describe the process of compiling the shipped firmware.\n\n\nFirst, get the firmware.\n\n\nwget http://packages.matrix.one/matrix-creator-firmware/firmware-0.8.tar.gz\ntar xzvf firmware-0.8.tar.gz\n\n\n\nThen flash the firmware using the \nopenocd\n program that should be installed on the Raspberry (with the package matrix-creator-openocd).\n\n\nThen execute the following commands as root.\n\n\necho 18 \n /sys/class/gpio/export\necho out \n /sys/class/gpio/gpio18/direction\necho 1 \n /sys/class/gpio/gpio18/value\necho 0 \n /sys/class/gpio/gpio18/value\necho 1 \n /sys/class/gpio/gpio18/value\n\n\n\nNow you can program the firmware.\n\n\ncd firmware-0.8\nsudo openocd -f cfg/sam3s.cfg\n\n\n\nExample output:\n\n\n$ sudo openocd -f cfg/sam3s.cfg\nOpen On-Chip Debugger 0.10.0-dev-00283-g7223cae-dirty (2016-07-15-08:36)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.org/doc/doxygen/bugs.html\nBCM2835 GPIO config: tck = 17, tms = 4, tdi = 22, tdo = 27\nBCM2835 GPIO config: trst = 18\ntrst_only separate trst_push_pull\nadapter speed: 512 kHz\nWarn : em357.bs: nonstandard IR value\nWarn : Specify TAP 'sam3n.cpu.cpu' by name, not number 3\nInfo : BCM2835 GPIO JTAG/SWD bitbang driver\nInfo : JTAG only mode enabled (specify swclk and swdio gpio to add SWD mode)\nInfo : clock speed 512 kHz\nInfo : JTAG tap: em357.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3)\nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)\nInfo : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2)\nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4)\nError: xc6sxl4.fpga.fpga: IR capture error; saw 0x35 not 0x11\nWarn : Bypassing JTAG setup events due to errors\nInfo : sam3n.cpu: hardware has 6 breakpoints, 4 watchpoints\nsam3n.cpu: target state: halted\ntarget halted due to debug-request, current mode: Thread\nxPSR: 0x61000000 pc: 0x00402560 psp: 0x20000800\n#0 : at91sam3 at 0x00400000, size 0x00020000, buswidth 0, chipwidth 0\n    #  0: 0x00000000 (0x4000 16kB) not protected\n    #  1: 0x00004000 (0x4000 16kB) not protected\n    #  2: 0x00008000 (0x4000 16kB) not protected\n    #  3: 0x0000c000 (0x4000 16kB) not protected\n    #  4: 0x00010000 (0x4000 16kB) not protected\n    #  5: 0x00014000 (0x4000 16kB) not protected\n    #  6: 0x00018000 (0x4000 16kB) not protected\n    #  7: 0x0001c000 (0x4000 16kB) not protected\nflash 'at91sam3' found at 0x00400000\nError: Invalid ACK (6) in DAP response\nError: Failed to read memory at 0x400e0a0c\nError: SAM3: Error performing Erase \n Write page @ phys address 0x00400800\nwrote 38620 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 1.256279s (30.021 KiB/s)\nInfo : JTAG tap: em357.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3)\nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)\nInfo : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2)\nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4)\nError: xc6sxl4.fpga.fpga: IR capture error; saw 0x35 not 0x11\nWarn : Bypassing JTAG setup events due to errors\nWarn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure     hardware srst support.\nshutdown command invoked\n\n\n\nFlashing succeeded if you get the line \"wrote 38620 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 1.256279s (30.021 KiB/s)\" in the previous output. A small LED next to the SAM3 MCU should start flashing once per second.\n\n\nIf flashing fails, please retry the flashing command.\n\n\nSample video\n\n\nQuestions? Post them on raspberrypi.stackexchange.com! Use the tag #matrix-creator", 
            "title": "SAM3MCU"
        }, 
        {
            "location": "/matrix-hal/components/Sam3mcu/#sam3-mcu-programming", 
            "text": "Once you have installed the  required software  you can program the SAM3 MCU. The MCU is used to read the sensors.  This firmware is free software and  you can compile it yourself . Here we describe the process of compiling the shipped firmware.  First, get the firmware.  wget http://packages.matrix.one/matrix-creator-firmware/firmware-0.8.tar.gz\ntar xzvf firmware-0.8.tar.gz  Then flash the firmware using the  openocd  program that should be installed on the Raspberry (with the package matrix-creator-openocd).  Then execute the following commands as root.  echo 18   /sys/class/gpio/export\necho out   /sys/class/gpio/gpio18/direction\necho 1   /sys/class/gpio/gpio18/value\necho 0   /sys/class/gpio/gpio18/value\necho 1   /sys/class/gpio/gpio18/value  Now you can program the firmware.  cd firmware-0.8\nsudo openocd -f cfg/sam3s.cfg  Example output:  $ sudo openocd -f cfg/sam3s.cfg\nOpen On-Chip Debugger 0.10.0-dev-00283-g7223cae-dirty (2016-07-15-08:36)\nLicensed under GNU GPL v2\nFor bug reports, read\n    http://openocd.org/doc/doxygen/bugs.html\nBCM2835 GPIO config: tck = 17, tms = 4, tdi = 22, tdo = 27\nBCM2835 GPIO config: trst = 18\ntrst_only separate trst_push_pull\nadapter speed: 512 kHz\nWarn : em357.bs: nonstandard IR value\nWarn : Specify TAP 'sam3n.cpu.cpu' by name, not number 3\nInfo : BCM2835 GPIO JTAG/SWD bitbang driver\nInfo : JTAG only mode enabled (specify swclk and swdio gpio to add SWD mode)\nInfo : clock speed 512 kHz\nInfo : JTAG tap: em357.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3)\nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)\nInfo : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2)\nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4)\nError: xc6sxl4.fpga.fpga: IR capture error; saw 0x35 not 0x11\nWarn : Bypassing JTAG setup events due to errors\nInfo : sam3n.cpu: hardware has 6 breakpoints, 4 watchpoints\nsam3n.cpu: target state: halted\ntarget halted due to debug-request, current mode: Thread\nxPSR: 0x61000000 pc: 0x00402560 psp: 0x20000800\n#0 : at91sam3 at 0x00400000, size 0x00020000, buswidth 0, chipwidth 0\n    #  0: 0x00000000 (0x4000 16kB) not protected\n    #  1: 0x00004000 (0x4000 16kB) not protected\n    #  2: 0x00008000 (0x4000 16kB) not protected\n    #  3: 0x0000c000 (0x4000 16kB) not protected\n    #  4: 0x00010000 (0x4000 16kB) not protected\n    #  5: 0x00014000 (0x4000 16kB) not protected\n    #  6: 0x00018000 (0x4000 16kB) not protected\n    #  7: 0x0001c000 (0x4000 16kB) not protected\nflash 'at91sam3' found at 0x00400000\nError: Invalid ACK (6) in DAP response\nError: Failed to read memory at 0x400e0a0c\nError: SAM3: Error performing Erase   Write page @ phys address 0x00400800\nwrote 38620 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 1.256279s (30.021 KiB/s)\nInfo : JTAG tap: em357.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3)\nInfo : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)\nInfo : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2)\nInfo : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4)\nError: xc6sxl4.fpga.fpga: IR capture error; saw 0x35 not 0x11\nWarn : Bypassing JTAG setup events due to errors\nWarn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure     hardware srst support.\nshutdown command invoked  Flashing succeeded if you get the line \"wrote 38620 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 1.256279s (30.021 KiB/s)\" in the previous output. A small LED next to the SAM3 MCU should start flashing once per second.  If flashing fails, please retry the flashing command.  Sample video  Questions? Post them on raspberrypi.stackexchange.com! Use the tag #matrix-creator", 
            "title": "Sam3 MCU Programming"
        }, 
        {
            "location": "/matrix-hal/components/pinout/", 
            "text": "Creator V1 Pinout Rev 2\n\n\n\n\nCreator V1 Pinout - For Reference\n\n\nExpansion pinout\n\n\n\n\nExpansion location\n\n\n\n\nFPGA's UCF definition\n\n\nNET \nDF\n16\n LOC=\nP106\n;\nNET \nDF\n15\n LOC=\nP102\n;\nNET \nDF\n14\n LOC=\nP101\n;\nNET \nDF\n13\n LOC=\nP99\n;\nNET \nDF\n12\n LOC=\nP98\n;\nNET \nDF\n11\n LOC=\nP95\n;\nNET \nDF\n10\n LOC=\nP94\n;\nNET \nDF\n9\n LOC=\nP93\n;\nNET \nDF\n8\n LOC=\nP92\n;\nNET \nDF\n7\n LOC=\nP88\n;\nNET \nDF\n6\n LOC=\nP85\n;\nNET \nDF\n5\n LOC=\nP83\n;\nNET \nDF\n4\n LOC=\nP82\n;\nNET \nDF\n3\n LOC=\nP81\n;\nNET \nDF\n2\n LOC=\nP80\n;\nNET \nDF\n1\n LOC=\nP79\n;\nNET \nDF\n0\n LOC=\nP78\n;", 
            "title": "Pinout"
        }, 
        {
            "location": "/matrix-hal/components/pinout/#creator-v1-pinout-rev-2", 
            "text": "", 
            "title": "Creator V1 Pinout Rev 2"
        }, 
        {
            "location": "/matrix-hal/components/pinout/#creator-v1-pinout-for-reference", 
            "text": "", 
            "title": "Creator V1 Pinout - For Reference"
        }, 
        {
            "location": "/matrix-hal/components/pinout/#expansion-pinout", 
            "text": "", 
            "title": "Expansion pinout"
        }, 
        {
            "location": "/matrix-hal/components/pinout/#expansion-location", 
            "text": "", 
            "title": "Expansion location"
        }, 
        {
            "location": "/matrix-hal/components/pinout/#fpgas-ucf-definition", 
            "text": "NET  DF 16  LOC= P106 ;\nNET  DF 15  LOC= P102 ;\nNET  DF 14  LOC= P101 ;\nNET  DF 13  LOC= P99 ;\nNET  DF 12  LOC= P98 ;\nNET  DF 11  LOC= P95 ;\nNET  DF 10  LOC= P94 ;\nNET  DF 9  LOC= P93 ;\nNET  DF 8  LOC= P92 ;\nNET  DF 7  LOC= P88 ;\nNET  DF 6  LOC= P85 ;\nNET  DF 5  LOC= P83 ;\nNET  DF 4  LOC= P82 ;\nNET  DF 3  LOC= P81 ;\nNET  DF 2  LOC= P80 ;\nNET  DF 1  LOC= P79 ;\nNET  DF 0  LOC= P78 ;", 
            "title": "FPGA's UCF definition"
        }, 
        {
            "location": "/matrix-hal/components/SPI/", 
            "text": "SPI\n\n\nThe SPI bus is not enabled by default by Raspbian. To enable it you can follow the next steps.\n\n\nFirst, open raspi-config.\n\n\nsudo raspi-config\n\n\n\n\n\nThen navigate the interface to activate the SPI bus. Go to advanced options.\n\n\n\n\nSelect SPI.\n\n\n\n\nEnable SPI.\n\n\n\n\nVerify that SPI has been enabled.\n\n\n\n\nNow you can exit raspi-config and SPI will be permanently enabled.", 
            "title": "SPI"
        }, 
        {
            "location": "/matrix-hal/components/SPI/#spi", 
            "text": "The SPI bus is not enabled by default by Raspbian. To enable it you can follow the next steps.  First, open raspi-config.  sudo raspi-config   Then navigate the interface to activate the SPI bus. Go to advanced options.   Select SPI.   Enable SPI.   Verify that SPI has been enabled.   Now you can exit raspi-config and SPI will be permanently enabled.", 
            "title": "SPI"
        }, 
        {
            "location": "/matrix-hal/tools/", 
            "text": "Tools\n\n\nxc3sprog\n\n\nhttps://github.com/matrix-io/xc3sprog\n - xc3sprog for programming the FPGA\n\n\nOpenOCD\n\n\nhttps://github.com/matrix-io/matrix-creator-openocd\n - OpenOCD for programming the microcontroller", 
            "title": "OpenOCD"
        }, 
        {
            "location": "/matrix-hal/tools/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/matrix-hal/tools/#xc3sprog", 
            "text": "https://github.com/matrix-io/xc3sprog  - xc3sprog for programming the FPGA", 
            "title": "xc3sprog"
        }, 
        {
            "location": "/matrix-hal/tools/#openocd", 
            "text": "https://github.com/matrix-io/matrix-creator-openocd  - OpenOCD for programming the microcontroller", 
            "title": "OpenOCD"
        }, 
        {
            "location": "/matrix-hal/tools/", 
            "text": "Tools\n\n\nxc3sprog\n\n\nhttps://github.com/matrix-io/xc3sprog\n - xc3sprog for programming the FPGA\n\n\nOpenOCD\n\n\nhttps://github.com/matrix-io/matrix-creator-openocd\n - OpenOCD for programming the microcontroller", 
            "title": "xc3sprog"
        }, 
        {
            "location": "/matrix-hal/tools/#tools", 
            "text": "", 
            "title": "Tools"
        }, 
        {
            "location": "/matrix-hal/tools/#xc3sprog", 
            "text": "https://github.com/matrix-io/xc3sprog  - xc3sprog for programming the FPGA", 
            "title": "xc3sprog"
        }, 
        {
            "location": "/matrix-hal/tools/#openocd", 
            "text": "https://github.com/matrix-io/matrix-creator-openocd  - OpenOCD for programming the microcontroller", 
            "title": "OpenOCD"
        }, 
        {
            "location": "/matrix-hal/examples/alexa/", 
            "text": "Overview\n\n\n\n\nThis guide provides step-by-step instructions for setting up AVS on a \nRaspberry Pi\n with a \nMATRIX Creator\n. It demonstrates how to access and test AVS using our Java sample app (running on a Raspberry Pi), a Node.js server, and a third-party wake word engine using MATRIX mic array. You will use the Node.js server to obtain a Login with Amazon (LWA) authorization code by visiting a website using your Raspberry Pi's web browser.\n\n\nRequired hardware\n\n\nBefore you get started, let's review what you'll need.\n\n\n\n\nRaspberry Pi 3\n (Recommended) or \nPi 2 Model B\n (Supported)  - Buy at Amazon - \nPi 3\n or \nPi 2\n.\n\n\nMATRIX Creator\n - Raspberry Pi does not have a built-in microphone, the MATRIX Creator has an 8 mic array for Alexa - \nBuy MATRIX Creator\n\n\nMicro-USB power cable\n for Raspberry Pi.\n\n\nMicro SD Card\n (Minimum 8 GB) - You need an operating system to get started. NOOBS (New Out of the Box Software) is an easy-to-use operating system install manager for Raspberry Pi. The simplest way to get NOOBS is to buy an SD card with NOOBS pre-installed - \nRaspberry Pi 8GB Preloaded (NOOBS) Micro SD Card\n. Alternatively, you can download and install it on your SD card.\n\n\nExternal Speaker\n with 3.5mm audio cable - \nBuy on Amazon\n\n\nA \nUSB Keyboard \n Mouse\n, and an external \nHDMI Monitor\n - we also recommend having a USB keyboard and mouse as well as an HDMI monitor handy if you're unable to \nremote(SSH)\n into your Pi.\n\n\nInternet connection (Ethernet or WiFi)\n\n\n(Optional) WiFi Wireless Adapter for Pi 2 (\nBuy on Amazon\n).\n   \nNote:\n Pi 3 has built-in WiFi.\n\n\n\n\nFor extra credit, enable \nremote(SSH)\n into your device, eliminating the need for a monitor, keyboard and mouse - and learn how to tail logs for troubleshooting.\n\n\n\n\nLet's get started\n\n\nThe original Alexa on a Pi project required manual download of libraries/dependencies and updating configuration files, which is prone to human error. To make the process faster and easier, we've included an install script with the project that will take care of all the heavy lifting. Not only does this reduce setup time to less than an hour on a Raspberry Pi 3, it only requires developers to adjust three variables in a single install script.\n\n\nStep 1: Setting up your Pi\n\n\nConfigure your RaspberryPi like a original Alexa documentation, for this please completing steps: \n1,2,3,4,5 and 6\n from original documentation: \nRaspberry Pi\n\n\n\n\nStep 2: Override ALSA configuration\n\n\nMATRIX Creator has 8 physical microphone channels and an additional virtual beam formed channel that combines the physical ones. Utilize a microphone channel by placing the following in \n/home/pi/.asoundrc\n.\n\n\npcm.!default\n{\n  type asym\n  playback.pcm {\n    type hw\n    card 0\n    device 0\n  }\n  capture.pcm {\n    type file\n    file \n/tmp/matrix_micarray_channel_0\n\n    infile \n/tmp/matrix_micarray_channel_0\n\n    format \nraw\n\n    slave {\n        pcm sc\n    }\n  }\n}\n\n\n\n\n\n\nStep 3: Install MATRIX software and reboot\n\n\necho \ndeb http://packages.matrix.one/matrix-creator/ ./\n | sudo tee --append /etc/apt/sources.list;\nsudo apt-get update;\nsudo apt-get upgrade;\nsudo apt-get install libzmq3-dev xc3sprog matrix-creator-openocd wiringpi cmake g++ git;\nsudo apt-get install matrix-creator-init matrix-creator-malos\nsudo reboot\n\n\n\n\n\n\nStep 4: Run your web service, sample app and wake word engine\n\n\nReturn to \nRaspberry Pi\n documentation and execute \nStep 7\n but in the last terminal select the \nsensory\n wake word engine with:\n\n\ncd ~/Desktop/alexa-avs-sample-app/samples\ncd wakeWordAgent/src \n ./wakeWordAgent -e sensory\n\n\n\n\n\n\nStep 5: Talk to Alexa\n\n\nYou can now talk to Alexa by simply using the wake word \"Alexa\". Try the following -\n\n\nSay \"Alexa\", then wait for the beep. Now say \"what's the time?\"\n\n\nSay \"Alexa\", then wait for the beep. Now say \"what's the weather in Seattle?\"\n\n\nIf you prefer, you can also click on the \"Listen\" button, instead of using the wake word. Click the \"Listen\" button and wait for the audio cue before beginning to speak. It may take a second or two before you hear the audio cue.", 
            "title": "Alexa"
        }, 
        {
            "location": "/matrix-hal/examples/alexa/#overview", 
            "text": "This guide provides step-by-step instructions for setting up AVS on a  Raspberry Pi  with a  MATRIX Creator . It demonstrates how to access and test AVS using our Java sample app (running on a Raspberry Pi), a Node.js server, and a third-party wake word engine using MATRIX mic array. You will use the Node.js server to obtain a Login with Amazon (LWA) authorization code by visiting a website using your Raspberry Pi's web browser.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/examples/alexa/#required-hardware", 
            "text": "Before you get started, let's review what you'll need.   Raspberry Pi 3  (Recommended) or  Pi 2 Model B  (Supported)  - Buy at Amazon -  Pi 3  or  Pi 2 .  MATRIX Creator  - Raspberry Pi does not have a built-in microphone, the MATRIX Creator has an 8 mic array for Alexa -  Buy MATRIX Creator  Micro-USB power cable  for Raspberry Pi.  Micro SD Card  (Minimum 8 GB) - You need an operating system to get started. NOOBS (New Out of the Box Software) is an easy-to-use operating system install manager for Raspberry Pi. The simplest way to get NOOBS is to buy an SD card with NOOBS pre-installed -  Raspberry Pi 8GB Preloaded (NOOBS) Micro SD Card . Alternatively, you can download and install it on your SD card.  External Speaker  with 3.5mm audio cable -  Buy on Amazon  A  USB Keyboard   Mouse , and an external  HDMI Monitor  - we also recommend having a USB keyboard and mouse as well as an HDMI monitor handy if you're unable to  remote(SSH)  into your Pi.  Internet connection (Ethernet or WiFi)  (Optional) WiFi Wireless Adapter for Pi 2 ( Buy on Amazon ).\n    Note:  Pi 3 has built-in WiFi.   For extra credit, enable  remote(SSH)  into your device, eliminating the need for a monitor, keyboard and mouse - and learn how to tail logs for troubleshooting.", 
            "title": "Required hardware"
        }, 
        {
            "location": "/matrix-hal/examples/alexa/#lets-get-started", 
            "text": "The original Alexa on a Pi project required manual download of libraries/dependencies and updating configuration files, which is prone to human error. To make the process faster and easier, we've included an install script with the project that will take care of all the heavy lifting. Not only does this reduce setup time to less than an hour on a Raspberry Pi 3, it only requires developers to adjust three variables in a single install script.", 
            "title": "Let's get started"
        }, 
        {
            "location": "/matrix-hal/examples/alexa/#step-1-setting-up-your-pi", 
            "text": "Configure your RaspberryPi like a original Alexa documentation, for this please completing steps:  1,2,3,4,5 and 6  from original documentation:  Raspberry Pi", 
            "title": "Step 1: Setting up your Pi"
        }, 
        {
            "location": "/matrix-hal/examples/alexa/#step-2-override-alsa-configuration", 
            "text": "MATRIX Creator has 8 physical microphone channels and an additional virtual beam formed channel that combines the physical ones. Utilize a microphone channel by placing the following in  /home/pi/.asoundrc .  pcm.!default\n{\n  type asym\n  playback.pcm {\n    type hw\n    card 0\n    device 0\n  }\n  capture.pcm {\n    type file\n    file  /tmp/matrix_micarray_channel_0 \n    infile  /tmp/matrix_micarray_channel_0 \n    format  raw \n    slave {\n        pcm sc\n    }\n  }\n}", 
            "title": "Step 2: Override ALSA configuration"
        }, 
        {
            "location": "/matrix-hal/examples/alexa/#step-3-install-matrix-software-and-reboot", 
            "text": "echo  deb http://packages.matrix.one/matrix-creator/ ./  | sudo tee --append /etc/apt/sources.list;\nsudo apt-get update;\nsudo apt-get upgrade;\nsudo apt-get install libzmq3-dev xc3sprog matrix-creator-openocd wiringpi cmake g++ git;\nsudo apt-get install matrix-creator-init matrix-creator-malos\nsudo reboot", 
            "title": "Step 3: Install MATRIX software and reboot"
        }, 
        {
            "location": "/matrix-hal/examples/alexa/#step-4-run-your-web-service-sample-app-and-wake-word-engine", 
            "text": "Return to  Raspberry Pi  documentation and execute  Step 7  but in the last terminal select the  sensory  wake word engine with:  cd ~/Desktop/alexa-avs-sample-app/samples\ncd wakeWordAgent/src   ./wakeWordAgent -e sensory", 
            "title": "Step 4: Run your web service, sample app and wake word engine"
        }, 
        {
            "location": "/matrix-hal/examples/alexa/#step-5-talk-to-alexa", 
            "text": "You can now talk to Alexa by simply using the wake word \"Alexa\". Try the following -  Say \"Alexa\", then wait for the beep. Now say \"what's the time?\"  Say \"Alexa\", then wait for the beep. Now say \"what's the weather in Seattle?\"  If you prefer, you can also click on the \"Listen\" button, instead of using the wake word. Click the \"Listen\" button and wait for the audio cue before beginning to speak. It may take a second or two before you hear the audio cue.", 
            "title": "Step 5: Talk to Alexa"
        }, 
        {
            "location": "/matrix-hal/examples/hardware-demos/", 
            "text": "Sensor Tests\n\n\nWith the following instructions you will be able to run demos for the Everloop LED Array and for the IMU. These demos make use of the \nhardware abstraction layer\n. If you followed the \ngetting started\n steps the \nFPGA\n and the \nSAM3 MCU\n should be programmed and ready. Also, \nSPI should be enabled\n.\n\n\nThus you can get the required source code and build it:\n\n\ngit clone https://github.com/matrix-io/matrix-creator-hal.git\ncd matrix-creator-hal\nmkdir build \n cd build\ncmake .. \n make\n\n\n\nIf the project built with no issues you can run the demos. The demos run for ever, you can terminate them with Control+C.\n\n\nSpinning leds ( \nvideo\n ):\n\n\ndemos/everloop_demo\n\n\n\nArc demo ( \nvideo\n ) :\n\n\ndemos/arc_demo\n\n\n\nCompass demo:\n\n\ndemos/compass_demo\n\nyaw = -116.006  roll = 3.19588  pitch = 0.370596\nyaw = -116.577  roll = 3.61794  pitch = 0.210613\nyaw = -115.649  roll = 3.64227  pitch = 0.334733\nyaw = -115.468  roll = 3.34762  pitch = 0.42658\nyaw = -116.423  roll = 3.49536  pitch = 0.566351\n\n\n\nMicrophones:\n\n\ndemos/mic_demo\n\n52  29  54  74  74  49  39  60\n60  31  52  46  41  55  68  70\n60  44  55  43  53  68  62  62\n45  17  69  54  18  38  74  67\n\n(You get one value for each microphone)\n\n\n\nQuestions? Post them on \nraspberrypi.stackexchange.com\n! Use the tag #matrix-creator", 
            "title": "Sensor Tests"
        }, 
        {
            "location": "/matrix-hal/examples/hardware-demos/#sensor-tests", 
            "text": "With the following instructions you will be able to run demos for the Everloop LED Array and for the IMU. These demos make use of the  hardware abstraction layer . If you followed the  getting started  steps the  FPGA  and the  SAM3 MCU  should be programmed and ready. Also,  SPI should be enabled .  Thus you can get the required source code and build it:  git clone https://github.com/matrix-io/matrix-creator-hal.git\ncd matrix-creator-hal\nmkdir build   cd build\ncmake ..   make  If the project built with no issues you can run the demos. The demos run for ever, you can terminate them with Control+C.  Spinning leds (  video  ):  demos/everloop_demo  Arc demo (  video  ) :  demos/arc_demo  Compass demo:  demos/compass_demo\n\nyaw = -116.006  roll = 3.19588  pitch = 0.370596\nyaw = -116.577  roll = 3.61794  pitch = 0.210613\nyaw = -115.649  roll = 3.64227  pitch = 0.334733\nyaw = -115.468  roll = 3.34762  pitch = 0.42658\nyaw = -116.423  roll = 3.49536  pitch = 0.566351  Microphones:  demos/mic_demo\n\n52  29  54  74  74  49  39  60\n60  31  52  46  41  55  68  70\n60  44  55  43  53  68  62  62\n45  17  69  54  18  38  74  67\n\n(You get one value for each microphone)  Questions? Post them on  raspberrypi.stackexchange.com ! Use the tag #matrix-creator", 
            "title": "Sensor Tests"
        }, 
        {
            "location": "/matrix-hal/troubleshooting/", 
            "text": "Troubleshooting\n\n\nDrop your questions by the \ncommunity forum\n.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-hal/troubleshooting/#troubleshooting", 
            "text": "Drop your questions by the  community forum .", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/help/", 
            "text": "Support\n\n\n\n\nPost questions or comments on \ncommunity.matrix.one\n\n\nPost package issues on github under \nmatrix-io\n\n\nSubmit documentation issues or improvements at \nmatrix-io/matrix-documentation", 
            "title": "Support"
        }, 
        {
            "location": "/help/#support", 
            "text": "Post questions or comments on  community.matrix.one  Post package issues on github under  matrix-io  Submit documentation issues or improvements at  matrix-io/matrix-documentation", 
            "title": "Support"
        }
    ]
}