{
    "docs": [
        {
            "location": "/", 
            "text": "MATRIX Ecosystem Overview\n\n\nObjective: Hardware shouldn't be hard\n\nThe MATRIX Ecosystem was created to make powerful hardware projects very approachable for software developers. The pillars of MATRIX, computer vision, hardware interfaces, distributed internet communication, and data-driven end-user clients, are all programming disciplines which require years for an individual to master, or for a team to build a solution around.\n\n\n\n\nProgramming Layers\n\n\nThe MATRIX platform adds powerful capabilities to your Raspberry Pi, depending on your background and the kind of application you want to write, you may need to decide on which layer best fits your need. The documentation is organized according to these layers:\n\n\n\n\nMATRIX Open System (MOS)\n\n\n\nLanguage:\n Javascript\n\n\nHighest level of abstraction integrating with MATRIX hardware via \nMATRIX CORE\n. This layer requires an online connection and offers an integrated IoT environment that's easy to use.\n\n\n\n\nRemote App Deployment\n\n\nMobile Interface\n\n\nOnline Dashboard\n\n\nApp Store\n\n\n\n\nRead more about MATRIX OS\n\n\nMATRIX CORE\n\n\n\nLanguages:\n Over 40 (Examples in Javascript \n Python)\n\n\nAbstraction layer for \nMATRIX HAL\n. Hosts a ZeroMQ + Protobuf communication layer which makes device information accessible via high-level interfaces. Supports 40+ different languages through Protocol Buffers: C++, Python, Ruby, PHP, Java, etc.\n\n\nRead more about MATRIX CORE\n\n\nMATRIX HAL\n\n\n\nLanguage:\n C++\n\n\nInteracts with the kernel modules by using C++ drivers, enabling it to access available sensors and components on your device.\n\n\nRead more about MATRIX HAL\n\n\n\n\nDevices\n\n\n\n\nEach programming layer in the MATRIX platform is compatible with each MATRIX product, excluding specific components on the boards.\n\n\n\n\nMATRIX Creator\n\n\n\n\n\n\nA fully-featured development board for the Raspberry Pi with various sensors and communication protocols such as a 3D Gyroscope, Accelerometer, an 8 Microphone Array, zigbee, Z-Wave, and more!\n\n\nRead more about the MATRIX Creator\n\n\nMATRIX Voice\n\n\n\n\n\n\nA voice and audio focused development board with an 8 microphone array that enables you to create your own audio driven applications or use voice assistants such as \n\nAmazon Alexa\n, \n\nGoogle Assistant\n, \nPocketSphinx, etc.\n\n\nRead more about the MATRIX Voice\n\n\n\n\nSupport\n\n\n\n\nPost questions or comments on \ncommunity.matrix.one\n\n\nAlert issues on our \nGitHub\n under the corresponding repository\n\n\nSubmit documentation issues or improvements to the \nMATRIX Documentation Repository", 
            "title": "Overview"
        }, 
        {
            "location": "/#matrix-ecosystem-overview", 
            "text": "", 
            "title": "MATRIX Ecosystem Overview"
        }, 
        {
            "location": "/#programming-layers", 
            "text": "The MATRIX platform adds powerful capabilities to your Raspberry Pi, depending on your background and the kind of application you want to write, you may need to decide on which layer best fits your need. The documentation is organized according to these layers:", 
            "title": "Programming Layers"
        }, 
        {
            "location": "/#devices", 
            "text": "Each programming layer in the MATRIX platform is compatible with each MATRIX product, excluding specific components on the boards.", 
            "title": "Devices"
        }, 
        {
            "location": "/#support", 
            "text": "Post questions or comments on  community.matrix.one  Alert issues on our  GitHub  under the corresponding repository  Submit documentation issues or improvements to the  MATRIX Documentation Repository", 
            "title": "Support"
        }, 
        {
            "location": "/matrix-creator/overview/", 
            "text": "MATRIX Creator\n\n\n\n\nThe MATRIX Creator is a fully-featured development board, including sensors, wireless communications, and an FPGA. MATRIX Creator was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) app creation.\n\n\nOverview\n\n\nDevice Setup\n\nHow to get started with your MATRIX Creator\n\n\nResources\n\n\n\nView and download helpful information about the MATRIX Creator", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-creator/overview/#matrix-creator", 
            "text": "The MATRIX Creator is a fully-featured development board, including sensors, wireless communications, and an FPGA. MATRIX Creator was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) app creation.", 
            "title": "MATRIX Creator"
        }, 
        {
            "location": "/matrix-creator/overview/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-creator/device-setup/", 
            "text": "Hardware Prerequisites\n\n\n\n\nMATRIX Creator\n\n\nCompatible Raspberry Pi:\n\n\n3 Model B+\n\n\n3 Model B\n\n\n2 Model B\n\n\n1 Model B+\n\n\nZero\n\n\nZero W\n\n\n\n\n\n\n5V 2.5A Micro USB Power Supply\n\n\nMicroSD Card With \nRaspbian Stretch\n Lite or Desktop Installed\n\n\nWe recommend using \nEtcher.io\n for easy flashing\n\n\n\n\n\n\n\n\nDevice Installation\n\n\n\n\nSteps\n\n\n\n\nInsert flashed microSD card into Raspberry Pi\n\n\nAttach MATRIX Creator onto Raspberry Pi GPIO pins\n\n\nPower Raspberry Pi with micro USB power supply\n\n\n\n\nChoosing A Programming Environment\n\n\nAfter your MATRIX Creator is setup, visit \nEcosystem Overview\n for information about the three programming environments available to you in the MATRIX platform.", 
            "title": "Device Setup"
        }, 
        {
            "location": "/matrix-creator/device-setup/#hardware-prerequisites", 
            "text": "MATRIX Creator  Compatible Raspberry Pi:  3 Model B+  3 Model B  2 Model B  1 Model B+  Zero  Zero W    5V 2.5A Micro USB Power Supply  MicroSD Card With  Raspbian Stretch  Lite or Desktop Installed  We recommend using  Etcher.io  for easy flashing", 
            "title": "Hardware Prerequisites"
        }, 
        {
            "location": "/matrix-creator/device-setup/#device-installation", 
            "text": "", 
            "title": "Device Installation"
        }, 
        {
            "location": "/matrix-creator/device-setup/#choosing-a-programming-environment", 
            "text": "After your MATRIX Creator is setup, visit  Ecosystem Overview  for information about the three programming environments available to you in the MATRIX platform.", 
            "title": "Choosing A Programming Environment"
        }, 
        {
            "location": "/matrix-creator/resources/overview/", 
            "text": "Resources\n\n\nPinout\n\n\n\nLists and labels of the MATRIX Creator's Pinouts\n\n\nMicrophone\n\n\n\nMicrophone sample rate and board position\n\n\nReference Models\n\n\n\nDownload or view the Matrix Creator's 3D models and case\n\n\nSystem Architecture\n\n\n\nView a technical diagram of the MATRIX Creator architecture.\n\n\nTechnical Datasheets\n\n\n\nPDFs of MATRIX Creator Components", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-creator/resources/overview/#resources", 
            "text": "", 
            "title": "Resources"
        }, 
        {
            "location": "/matrix-creator/resources/pinout/", 
            "text": "Expansion GPIO\n\n\n\n\n\n\nRev 1 Boards do not include pin 25 \n 26. Rev 2 boards can be identified if there is a QR code sticker on the MATRIX Creator's face.\n\n\n\n\nRaspberry Pi GPIO\n\n\n\n\nGPIO Locations", 
            "title": "Pinout"
        }, 
        {
            "location": "/matrix-creator/resources/pinout/#expansion-gpio", 
            "text": "Rev 1 Boards do not include pin 25   26. Rev 2 boards can be identified if there is a QR code sticker on the MATRIX Creator's face.", 
            "title": "Expansion GPIO"
        }, 
        {
            "location": "/matrix-creator/resources/pinout/#raspberry-pi-gpio", 
            "text": "", 
            "title": "Raspberry Pi GPIO"
        }, 
        {
            "location": "/matrix-creator/resources/pinout/#gpio-locations", 
            "text": "", 
            "title": "GPIO Locations"
        }, 
        {
            "location": "/matrix-creator/resources/microphone/", 
            "text": "Microphone Array on MATRIX Creator\n\n\n\n\nAudio Specifications:\n\n\nSample Rate: 8 to 96 kHz\nBit Depth: Signed 16 bit\n\n\n\n\n\nPosition [x,y] of each mic in the array (mm):\n\n\n\n\n\n\n\n\n\nMic\n\n\nX\n\n\nY\n\n\n\n\n\n\n\n\n\n\nM1\n\n\n20.0908795\n\n\n-48.5036755\n\n\n\n\n\n\nM2\n\n\n-20.0908795\n\n\n-48.5036755\n\n\n\n\n\n\nM3\n\n\n-48.5036755\n\n\n-20.0908795\n\n\n\n\n\n\nM4\n\n\n-48.5036755\n\n\n20.0908795\n\n\n\n\n\n\nM5\n\n\n-20.0908795\n\n\n48.5036755\n\n\n\n\n\n\nM6\n\n\n20.0908795\n\n\n48.5036755\n\n\n\n\n\n\nM7\n\n\n48.5036755\n\n\n20.0908795\n\n\n\n\n\n\nM8\n\n\n48.5036755\n\n\n-20.0908795\n\n\n\n\n\n\n\n\nConnection to the FPGA:\n\n\n\nYou can check the physical connection between the FPGA and other components in \n\ncreator.ucf\n\n\n\n\n\n\n\n\nMic\n\n\nFPGA pin\n\n\nPDM_Data\n\n\n\n\n\n\n\n\n\n\nM1\n\n\nP45\n\n\npdm_data\n0\n\n\n\n\n\n\nM2\n\n\nP46\n\n\npdm_data\n1\n\n\n\n\n\n\nM3\n\n\nP47\n\n\npdm_data\n2\n\n\n\n\n\n\nM4\n\n\nP58\n\n\npdm_data\n3\n\n\n\n\n\n\nM5\n\n\nP59\n\n\npdm_data\n4\n\n\n\n\n\n\nM6\n\n\nP64\n\n\npdm_data\n5\n\n\n\n\n\n\nM7\n\n\nP65\n\n\npdm_data\n6\n\n\n\n\n\n\nM8\n\n\nP44\n\n\npdm_data\n7\n\n\n\n\n\n\nCLK\n\n\nP47\n\n\npdm_clk", 
            "title": "Microphone"
        }, 
        {
            "location": "/matrix-creator/resources/microphone/#microphone-array-on-matrix-creator", 
            "text": "", 
            "title": "Microphone Array on MATRIX Creator"
        }, 
        {
            "location": "/matrix-creator/resources/microphone/#audio-specifications", 
            "text": "Sample Rate: 8 to 96 kHz\nBit Depth: Signed 16 bit", 
            "title": "Audio Specifications:"
        }, 
        {
            "location": "/matrix-creator/resources/reference-models/", 
            "text": "Board Model\n\n\nTop View\n\n\n\n\nBottom View\n\n\n\n\n\nModel Download\n\n\n\nAccess to 3D models \nhere\n. Also, you can take a look online \n\nhere\n.\n\n\nCase Model\n\n\nPrinted Case\n\n\n\n\nModel Download\n\n\n\nAccess to 3D case models \nhere\n.", 
            "title": "Reference Models"
        }, 
        {
            "location": "/matrix-creator/resources/reference-models/#board-model", 
            "text": "", 
            "title": "Board Model"
        }, 
        {
            "location": "/matrix-creator/resources/reference-models/#case-model", 
            "text": "", 
            "title": "Case Model"
        }, 
        {
            "location": "/matrix-creator/resources/system-architecture/", 
            "text": "System Architecture", 
            "title": "System Architecture"
        }, 
        {
            "location": "/matrix-creator/resources/system-architecture/#system-architecture", 
            "text": "", 
            "title": "System Architecture"
        }, 
        {
            "location": "/matrix-creator/resources/technical-datasheets/", 
            "text": "Datasheets:\n\n\n\n\n\n\nAtmel 32 bits Cortex M3 SAM3S2\n\n\n\n\n\n\nXilinx Spartan 6S XC6SLX4 FPGA\n\n\n\n\n\n\n8 MEMS audio sensor digital microphones\n\n\n\n\n\n\nST LSM9DS1 3D accelerometer, 3D gyroscope, 3D magnetometer\n\n\n\n\n\n\nST HTS221 digital sensor for relative humidity and temperature\n\n\n\n\n\n\nNXP PN512 NFC reader\n\n\n\n\n\n\nNXP MPL3115A2 Altimeter\n\n\n\n\n\n\nVishay VEML6070 UV Light Sensor\n\n\n\n\n\n\nVishay INFRARED Receptor\n\n\n\n\n\n\nRGBW everloop LED", 
            "title": "Technical Datasheets"
        }, 
        {
            "location": "/matrix-creator/resources/technical-datasheets/#datasheets", 
            "text": "Atmel 32 bits Cortex M3 SAM3S2    Xilinx Spartan 6S XC6SLX4 FPGA    8 MEMS audio sensor digital microphones    ST LSM9DS1 3D accelerometer, 3D gyroscope, 3D magnetometer    ST HTS221 digital sensor for relative humidity and temperature    NXP PN512 NFC reader    NXP MPL3115A2 Altimeter    Vishay VEML6070 UV Light Sensor    Vishay INFRARED Receptor    RGBW everloop LED", 
            "title": "Datasheets:"
        }, 
        {
            "location": "/matrix-voice/overview/", 
            "text": "MATRIX Voice\n\n\n\n\nThe MATRIX Voice is a development board for building sound driven behaviors and interfaces. MATRIX Voice was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) voice app creation.\n\n\nOverview\n\n\nDevice Setup\n\n\n\nHow to get started with your MATRIX Voice \n MATRIX Voice ESP32 version\n\n\nESP32\n\n\n\nInstructions to setup your ESP32 module\n\n\nResources\n\n\n\nView and download helpful information about the MATRIX Voice\n\n\nBoard Versions\n\n\nBoth versions of these boards run the same on a Raspberry Pi, however, the MATRIX Voice ESP32 version has the option to run standalone by programming the ESP32 module.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-voice/overview/#matrix-voice", 
            "text": "The MATRIX Voice is a development board for building sound driven behaviors and interfaces. MATRIX Voice was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) voice app creation.", 
            "title": "MATRIX Voice"
        }, 
        {
            "location": "/matrix-voice/overview/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-voice/overview/#board-versions", 
            "text": "Both versions of these boards run the same on a Raspberry Pi, however, the MATRIX Voice ESP32 version has the option to run standalone by programming the ESP32 module.", 
            "title": "Board Versions"
        }, 
        {
            "location": "/matrix-voice/device-setup/", 
            "text": "Hardware Prerequisites\n\n\n\n\nMATRIX Voice\n\n\nCompatible Raspberry Pi:\n\n\n3 Model B+\n\n\n3 Model B\n\n\n2 Model B\n\n\n1 Model B+\n\n\nZero\n\n\nZero W\n\n\n\n\n\n\n5V 2.5A Micro USB Power Supply\n\n\nMicroSD Card With \nRaspbian Stretch\n Lite or Desktop Installed\n\n\nWe recommend using \nEtcher.io\n for easy flashing\n\n\n\n\n\n\n\n\nDevice Installation\n\n\n\n\nSteps\n\n\n\n\nInsert flashed microSD card into Raspberry Pi\n\n\nAttach MATRIX Voice onto Raspberry Pi GPIO pins\n\n\nPower Raspberry Pi with micro USB power supply\n\n\n\n\n\n\nThe yellow startup LED sequence (with 1 LED off) will be removed when a programming environment is installed.\n\n\n\n\nChoosing A Programming Environment\n\n\nAfter your MATRIX Voice is setup, visit \nEcosystem Overview\n for information about the three programming environments available to you in the MATRIX platform.\n\n\n\n\nAll 3 programming environments are compatible with the MATRIX Voice \n MATRIX Voice ESP32 version on a Raspberry Pi.  \n\n\n\n\nESP32 Setup\n\n\nUsers with a MATRIX Voice ESP32 version can also follow this \nguide\n on how to program their ESP32 module.", 
            "title": "Device Setup"
        }, 
        {
            "location": "/matrix-voice/device-setup/#hardware-prerequisites", 
            "text": "MATRIX Voice  Compatible Raspberry Pi:  3 Model B+  3 Model B  2 Model B  1 Model B+  Zero  Zero W    5V 2.5A Micro USB Power Supply  MicroSD Card With  Raspbian Stretch  Lite or Desktop Installed  We recommend using  Etcher.io  for easy flashing", 
            "title": "Hardware Prerequisites"
        }, 
        {
            "location": "/matrix-voice/device-setup/#device-installation", 
            "text": "", 
            "title": "Device Installation"
        }, 
        {
            "location": "/matrix-voice/device-setup/#choosing-a-programming-environment", 
            "text": "After your MATRIX Voice is setup, visit  Ecosystem Overview  for information about the three programming environments available to you in the MATRIX platform.   All 3 programming environments are compatible with the MATRIX Voice   MATRIX Voice ESP32 version on a Raspberry Pi.", 
            "title": "Choosing A Programming Environment"
        }, 
        {
            "location": "/matrix-voice/device-setup/#esp32-setup", 
            "text": "Users with a MATRIX Voice ESP32 version can also follow this  guide  on how to program their ESP32 module.", 
            "title": "ESP32 Setup"
        }, 
        {
            "location": "/matrix-voice/esp32/", 
            "text": "ESP32 Setup\n\n\nThis guide will show you how to get started with the ESP32 module on the MATRIX Voice ESP32 version.\n\n\nStep 1: Raspberry Pi Setup\n\n\nRun the following commands inside your Raspberry Pi terminal to install the MATRIX Voice Software. This will keep the FPGA firmware updated and install few tools to flash the ESP-WROOM-32.\n\n\n# Add repo and key\ncurl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add -\necho \ndeb https://apt.matrix.one/raspbian $(lsb_release -sc) main\n | sudo tee /etc/apt/sources.list.d/matrixlabs.list\n# Update packages and install\nsudo apt-get update\nsudo apt-get upgrade\n# Installation\nsudo apt install matrixio-creator-init\n\n\n\n\nReboot your Raspberry Pi to make sure all the required services are running.\n\n\nStep 2: Personal Computer Setup\n\n\nHere we're installing the requirements needed to allow your pc to develop and compile ESP32 projects.\n\n\nInstall Git:\n\n\n\n\nhttps://git-scm.com/downloads\n\n\n\n\nInstall ESP32 toolchain:\n\n\n\n\nLinux: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/linux-setup.html\n\n\nMac: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/macos-setup.html\n\n\nWindows: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/windows-setup.html\n(currently not functioning)\n\n\nStop Following when you reach \"Next Steps\"\n\n\n\n\nSetup ESP-IDF development framework:\n\n\n\n\nDownload ESP-IDF: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/index.html#get-esp-idf\n\n\nSet ESP-IDF Path: \nhttps://esp-idf.readthedocs.io/en/latest/get-started/add-idf_path-to-profile.html\n\n\n\n\nClone MATRIX Voice ESP32 repository\n\n\nThis repository contains the necessary libraries to control the MATRIX Voice's components.\n\n\n# windows must be using MINGw32 terminal from toolchain step\ngit clone https://github.com/matrix-io/matrixio_hal_esp32.git\n\n\n\n\nStep 3: Build and Deploy\n\n\nHere we will be deploying and running one of the example apps in the Repository we just downloaded.\n\n\nConfiguring IDF (one time setup):\n\n\ncd matrixio_hal_esp32/examples/mic_energy/\nmake menuconfig\n\n\n\n\n\n\nYou will now be taken to the IDF Configuration screen, as shown above. Once there, select the \n option to save default configuration.\n\n\nRunning example project:\n\n\nTo finish running the example, all that's left is to make and deploy the code to the Raspberry Pi. This requires the Pi's IP address and you will be prompted to insert the Pi's password as well.\n\n\nexport RPI_HOST=pi@RASPBERRY_IP_ADDRESS\nmake deploy\n\n\n\n\nStep 4: Finishing Up\n\n\n\n\nYour MATRIX Voice ESP32 should now be running the deployed example. With the program properly flashed in the ESP32, the Voice can now run without the Pi if you choose to do so. Ensure the MATRIX Voice and Pi are not powered before connecting or disconnecting.", 
            "title": "ESP32"
        }, 
        {
            "location": "/matrix-voice/esp32/#esp32-setup", 
            "text": "This guide will show you how to get started with the ESP32 module on the MATRIX Voice ESP32 version.", 
            "title": "ESP32 Setup"
        }, 
        {
            "location": "/matrix-voice/esp32/#step-1-raspberry-pi-setup", 
            "text": "Run the following commands inside your Raspberry Pi terminal to install the MATRIX Voice Software. This will keep the FPGA firmware updated and install few tools to flash the ESP-WROOM-32.  # Add repo and key\ncurl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add -\necho  deb https://apt.matrix.one/raspbian $(lsb_release -sc) main  | sudo tee /etc/apt/sources.list.d/matrixlabs.list\n# Update packages and install\nsudo apt-get update\nsudo apt-get upgrade\n# Installation\nsudo apt install matrixio-creator-init  Reboot your Raspberry Pi to make sure all the required services are running.", 
            "title": "Step 1: Raspberry Pi Setup"
        }, 
        {
            "location": "/matrix-voice/esp32/#step-2-personal-computer-setup", 
            "text": "Here we're installing the requirements needed to allow your pc to develop and compile ESP32 projects.  Install Git:   https://git-scm.com/downloads   Install ESP32 toolchain:   Linux:  https://esp-idf.readthedocs.io/en/latest/get-started/linux-setup.html  Mac:  https://esp-idf.readthedocs.io/en/latest/get-started/macos-setup.html  Windows:  https://esp-idf.readthedocs.io/en/latest/get-started/windows-setup.html (currently not functioning)  Stop Following when you reach \"Next Steps\"   Setup ESP-IDF development framework:   Download ESP-IDF:  https://esp-idf.readthedocs.io/en/latest/get-started/index.html#get-esp-idf  Set ESP-IDF Path:  https://esp-idf.readthedocs.io/en/latest/get-started/add-idf_path-to-profile.html   Clone MATRIX Voice ESP32 repository  This repository contains the necessary libraries to control the MATRIX Voice's components.  # windows must be using MINGw32 terminal from toolchain step\ngit clone https://github.com/matrix-io/matrixio_hal_esp32.git", 
            "title": "Step 2: Personal Computer Setup"
        }, 
        {
            "location": "/matrix-voice/esp32/#step-3-build-and-deploy", 
            "text": "Here we will be deploying and running one of the example apps in the Repository we just downloaded.  Configuring IDF (one time setup):  cd matrixio_hal_esp32/examples/mic_energy/\nmake menuconfig   You will now be taken to the IDF Configuration screen, as shown above. Once there, select the   option to save default configuration.  Running example project:  To finish running the example, all that's left is to make and deploy the code to the Raspberry Pi. This requires the Pi's IP address and you will be prompted to insert the Pi's password as well.  export RPI_HOST=pi@RASPBERRY_IP_ADDRESS\nmake deploy", 
            "title": "Step 3: Build and Deploy"
        }, 
        {
            "location": "/matrix-voice/esp32/#step-4-finishing-up", 
            "text": "Your MATRIX Voice ESP32 should now be running the deployed example. With the program properly flashed in the ESP32, the Voice can now run without the Pi if you choose to do so. Ensure the MATRIX Voice and Pi are not powered before connecting or disconnecting.", 
            "title": "Step 4: Finishing Up"
        }, 
        {
            "location": "/matrix-voice/resources/overview/", 
            "text": "Resources\n\n\nPinout\n\n\n\nLists and labels of the MATRIX Voice's Pinouts\n\n\nMicrophone\n\n\n\nMicrophone sample rate and board position\n\n\nReference Models\n\n\n\nDownload or view the Matrix Voice's 3D models\n\n\nSystem Architecture\n\n\n\nView a technical diagram of the MATRIX Voice architecture\n\n\nTechnical Datasheets\n\n\n\nPDFs of MATRIX Creator Components", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-voice/resources/overview/#resources", 
            "text": "", 
            "title": "Resources"
        }, 
        {
            "location": "/matrix-voice/resources/pinout/", 
            "text": "Expansion GPIO\n\n\n\n\nRaspberry Pi GPIO\n\n\n\n\nGPIO Locations", 
            "title": "Pinout"
        }, 
        {
            "location": "/matrix-voice/resources/pinout/#expansion-gpio", 
            "text": "", 
            "title": "Expansion GPIO"
        }, 
        {
            "location": "/matrix-voice/resources/pinout/#raspberry-pi-gpio", 
            "text": "", 
            "title": "Raspberry Pi GPIO"
        }, 
        {
            "location": "/matrix-voice/resources/pinout/#gpio-locations", 
            "text": "", 
            "title": "GPIO Locations"
        }, 
        {
            "location": "/matrix-voice/resources/microphone/", 
            "text": "Microphone Array on MATRIX Voice\n\n\n\n\nAudio specs:\n\n\nSample Rate: 8 to 96 kHz\nBit Depth: Signed 16 bit\n\n\nPosition [x,y] of each mic in the array (mm):\n\n\n\n\n\n\n\n\n\nMic\n\n\nX\n\n\nY\n\n\n\n\n\n\n\n\n\n\nM1\n\n\n00.00\n\n\n0.00\n\n\n\n\n\n\nM2\n\n\n-38.13\n\n\n3.58\n\n\n\n\n\n\nM3\n\n\n-20.98\n\n\n32.04\n\n\n\n\n\n\nM4\n\n\n11.97\n\n\n36.38\n\n\n\n\n\n\nM5\n\n\n35.91\n\n\n13.32\n\n\n\n\n\n\nM6\n\n\n32.81\n\n\n-19.77\n\n\n\n\n\n\nM7\n\n\n5.00\n\n\n-37.97\n\n\n\n\n\n\nM8\n\n\n-26.57\n\n\n-27.58\n\n\n\n\n\n\n\n\nConnection to the FPGA:\n\n\n\n\n\n\n\n\n\nMic\n\n\nFPGA pin\n\n\nPDM_Data\n\n\n\n\n\n\n\n\n\n\nM1\n\n\nE6\n\n\npdm_data\n0\n\n\n\n\n\n\nM2\n\n\nB8\n\n\npdm_data\n1\n\n\n\n\n\n\nM3\n\n\nA8\n\n\npdm_data\n2\n\n\n\n\n\n\nM4\n\n\nC7\n\n\npdm_data\n3\n\n\n\n\n\n\nM5\n\n\nA7\n\n\npdm_data\n4\n\n\n\n\n\n\nM6\n\n\nA6\n\n\npdm_data\n5\n\n\n\n\n\n\nM7\n\n\nB6\n\n\npdm_data\n6\n\n\n\n\n\n\nM8\n\n\nA5\n\n\npdm_data\n7\n\n\n\n\n\n\nCLK\n\n\nB5\n\n\npdm_clk", 
            "title": "Microphone"
        }, 
        {
            "location": "/matrix-voice/resources/microphone/#microphone-array-on-matrix-voice", 
            "text": "", 
            "title": "Microphone Array on MATRIX Voice"
        }, 
        {
            "location": "/matrix-voice/resources/microphone/#audio-specs", 
            "text": "Sample Rate: 8 to 96 kHz\nBit Depth: Signed 16 bit", 
            "title": "Audio specs:"
        }, 
        {
            "location": "/matrix-voice/resources/reference-models/", 
            "text": "Board Model\n\n\nTop View\n\n\n\n\nBottom View\n\n\n\n\n\nModel Download\n\n\n\nAccess to 3D models \nhere\n. Also, you can take a look online \n\nhere\n.", 
            "title": "Reference Models"
        }, 
        {
            "location": "/matrix-voice/resources/reference-models/#board-model", 
            "text": "", 
            "title": "Board Model"
        }, 
        {
            "location": "/matrix-voice/resources/system-architecture/", 
            "text": "System Architecture", 
            "title": "System Architecture"
        }, 
        {
            "location": "/matrix-voice/resources/system-architecture/#system-architecture", 
            "text": "", 
            "title": "System Architecture"
        }, 
        {
            "location": "/matrix-voice/resources/technical-datasheets/", 
            "text": "Datasheets:\n\n\n\n\n\n\nXilinx Spartan 6 FPGA - XC6SLX9-2FTG256C\n\n\n\n\n\n\n8 MEMS audio sensor digital microphones - MP34DB02\n\n\n\n\n\n\nSerial Flash 64MBIT - MX25L6406E\n\n\n\n\n\n\nDDR2 SDRAM 512MBIT - MT47H32M16\n\n\n\n\n\n\n3W Stereo Class-D Audio Amplifier and Class-AB Headphone Driver - PAM8019\n\n\n\n\n\n\nRGBW LED - SK6812RGBW\n\n\n\n\n\n\nESP32-WROOM", 
            "title": "Technical Datasheets"
        }, 
        {
            "location": "/matrix-voice/resources/technical-datasheets/#datasheets", 
            "text": "Xilinx Spartan 6 FPGA - XC6SLX9-2FTG256C    8 MEMS audio sensor digital microphones - MP34DB02    Serial Flash 64MBIT - MX25L6406E    DDR2 SDRAM 512MBIT - MT47H32M16    3W Stereo Class-D Audio Amplifier and Class-AB Headphone Driver - PAM8019    RGBW LED - SK6812RGBW    ESP32-WROOM", 
            "title": "Datasheets:"
        }, 
        {
            "location": "/matrix-os/overview/", 
            "text": "MATRIX Open System\n\n\n\nMATRIX Open System (MOS) is open source software for hosting IoT applications. MATRIX Open System runs on node.js, and initially, applications will be written in JavaScript. The current workflow of this platform it to deploy and install apps into your MATRIX device, from a separate computer, anywhere in the world.\n\n\nGetting Started\n\n\nLearn how to install MOS on your creator and create applications for your MATRIX device.\n\n\nReference\n\n\nLook over the MATRIX Open System SDK to see the current libraries and features we have to offer. This includes CLI tool commands, sensors/component references, dashboard, and many other vital configurations needed to take full advantage of MOS.\n\n\nExamples\n\n\nTake a look at the example to show you how you can create a simple dashboard setup for your MOS application.\n\n\nMobile Applications\n\n\nAccess and manage your MATRIX devices with the mobile apps\n\n\n\n\n\n\nApple Store\n\n\n\n\n\n\n\n\nPlay Store\n\n\n\n\nTroubleshooting\n\n\nLook at common debugging solutions for any issues you encounter.", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-os/overview/#getting-started", 
            "text": "Learn how to install MOS on your creator and create applications for your MATRIX device.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/matrix-os/overview/#reference", 
            "text": "Look over the MATRIX Open System SDK to see the current libraries and features we have to offer. This includes CLI tool commands, sensors/component references, dashboard, and many other vital configurations needed to take full advantage of MOS.", 
            "title": "Reference"
        }, 
        {
            "location": "/matrix-os/overview/#examples", 
            "text": "Take a look at the example to show you how you can create a simple dashboard setup for your MOS application.", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-os/overview/#mobile-applications", 
            "text": "Access and manage your MATRIX devices with the mobile apps    Apple Store     Play Store", 
            "title": "Mobile Applications"
        }, 
        {
            "location": "/matrix-os/overview/#troubleshooting", 
            "text": "Look at common debugging solutions for any issues you encounter.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-os/getting-started/", 
            "text": "Getting Started\n\n\nInstallation\n\n\n\n\n\nLearn how to install MOS and the MATRIX CLI tool.\n\n\nApplications\n\n\n\n\n\nCreate and deploy a sample app for your MATRIX device.\n\n\nPublishing Apps\n\n\n\n\n\nFreely publish MATRIX applications to the MATRIX App store.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-os/getting-started/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/", 
            "text": "Installing MOS\n\n\n\nPrerequisites\n\n\n\n\nMake sure you have setup your \n\nMATRIX Creator\n or \n\nMATRIX Voice\n before continuing.\n\n\n\n\nSoftware\n\n\n\n\n\nNode.js\n\n\nCommand Line Interface:\n\n\nmacOS: Terminal\n\n\nWindows: \nPuTTY\n\n\nLinux: Terminal\n\n\n\n\n\n\n\n\nComputer Installation \n Account Registration\n\n\n\n\nWe recommend running the following commands on your Desktop/Laptop and not on your Raspberry Pi.\n\n\n\n\nMOS contains a CLI (Command Line Interface) tool for controlling and managing your MATRIX devices. To install the tool, execute the following command in your personal computer's terminal.\n\n\nnpm install -g matrix-cli\n\n\n\n\nOnce installed, the CLI tool needs to be configured by registering and then logging into a MATRIX Labs account.\n\n\nmatrix register\nmatrix login\n\n\n\n\nWith an account logged into the CLI tool, you can now register your MATRIX device. This will prompt you to enter a name and description for the device.\n\n\nmatrix register device\n\n\n\n\nAfter the device is created, a set of unique login credentials will be generated for you. Save these credentials because they are necessary to link your MATRIX Labs account to your MATRIX device. Below is an example of the generated credentials.\n\n\nexport MATRIX_DEVICE_ID=dc7a1a71be2d\nexport MATRIX_DEVICE_SECRET=08629018e9d77h15i5n0t4r3alz0f06cd4f7e5544272b\n\n\n\n\n\n\nRaspberry Pi Setup\n\n\nAccess the terminal of your Raspberry Pi via an \nSSH-session\n or connect a screen, mouse, and keyboard. Then run the following commands to go into your home directory and install MOS on the Raspberry Pi. A reboot will occur when the installation is finished.\n\n\ncd ~/\ncurl https://raw.githubusercontent.com/matrix-io/matrix-creator-quickstart/master/install.sh | sh\n\n\n\n\nLinking Device To MATRIX Labs Account\n\n\n\nTo properly link your MATRIX device to your MATRIX Labs account, you need to create a file named \n.envrc\n in the home directory of the Raspberry Pi and then populate it with the device credentials you saved earlier. To create the \n.envrc\n file and add the device credentials, use the nano command below and paste your device credentials within the terminal editor. When you\u2019re done, press \nCtrl+X\n.\n\n\nnano ~/.envrc\n\n\n\n\nWith the \n.envrc\n file created, you need to make the credentials within visible to the shell by running the command below. MOS will then be able to read it and properly register your MATRIX device.\n\n\nsource ~/.envrc\n\n\n\n\nStart MOS with the following command!\n\n\nnode ~/matrix-os/index.js\n\n\n\n\n\n\nStarting MOS on boot is not yet implemented.\n\n\n\n\n\n\nCheck if everything works\n\n\nOpen the terminal on your Desktop/Laptop and type the following command with the device name or ID. This selects the MATRIX device you want to interact with.\n\n\nmatrix use YOUR_DEVICE_NAME_OR_ID\n\n\n\n\nOnce your device is selected, run these commands to verify that everything has installed properly. This installs and runs the HelloWorld app from the \nMATRIX App Store\n.\n\n\nmatrix install HelloWorld\nmatrix start HelloWorld\n\n\n\n\n\n\nYou should now see a rainbow LED sequence, like the one above, on your MATRIX Device. \n\n\nUse the following command to stop the app.\n\n\nmatrix stop HelloWorld\n\n\n\n\n\n\nWhen an app is stopped, the LEDs will keep the last color they were set to until set to a different color.\n\n\n\n\n\n\nNext Steps\n\n\nNow that everything is properly installed, learn how to create your own MATRIX app \nhere\n.", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#prerequisites", 
            "text": "Make sure you have setup your  MATRIX Creator  or  MATRIX Voice  before continuing.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#computer-installation-account-registration", 
            "text": "We recommend running the following commands on your Desktop/Laptop and not on your Raspberry Pi.   MOS contains a CLI (Command Line Interface) tool for controlling and managing your MATRIX devices. To install the tool, execute the following command in your personal computer's terminal.  npm install -g matrix-cli  Once installed, the CLI tool needs to be configured by registering and then logging into a MATRIX Labs account.  matrix register\nmatrix login  With an account logged into the CLI tool, you can now register your MATRIX device. This will prompt you to enter a name and description for the device.  matrix register device  After the device is created, a set of unique login credentials will be generated for you. Save these credentials because they are necessary to link your MATRIX Labs account to your MATRIX device. Below is an example of the generated credentials.  export MATRIX_DEVICE_ID=dc7a1a71be2d\nexport MATRIX_DEVICE_SECRET=08629018e9d77h15i5n0t4r3alz0f06cd4f7e5544272b", 
            "title": "Computer Installation &amp; Account Registration"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#raspberry-pi-setup", 
            "text": "Access the terminal of your Raspberry Pi via an  SSH-session  or connect a screen, mouse, and keyboard. Then run the following commands to go into your home directory and install MOS on the Raspberry Pi. A reboot will occur when the installation is finished.  cd ~/\ncurl https://raw.githubusercontent.com/matrix-io/matrix-creator-quickstart/master/install.sh | sh", 
            "title": "Raspberry Pi Setup"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#check-if-everything-works", 
            "text": "Open the terminal on your Desktop/Laptop and type the following command with the device name or ID. This selects the MATRIX device you want to interact with.  matrix use YOUR_DEVICE_NAME_OR_ID  Once your device is selected, run these commands to verify that everything has installed properly. This installs and runs the HelloWorld app from the  MATRIX App Store .  matrix install HelloWorld\nmatrix start HelloWorld   You should now see a rainbow LED sequence, like the one above, on your MATRIX Device.   Use the following command to stop the app.  matrix stop HelloWorld   When an app is stopped, the LEDs will keep the last color they were set to until set to a different color.", 
            "title": "Check if everything works"
        }, 
        {
            "location": "/matrix-os/getting-started/installation/#next-steps", 
            "text": "Now that everything is properly installed, learn how to create your own MATRIX app  here .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-os/getting-started/applications/", 
            "text": "Creating An Application\n\n\n\nIntroduction\n\n\nMOS applications allow you to easily utilize the components and sensors of your MATRIX device through Javascript. This IoT platform enables you to create applications and integrate them with any third party API to expand the functionality of your MATRIX device.\n\n\n\n\nInitial Setup\n\n\nMOS apps are designed to be developed outside your MATRIX device and deployed when you want to run your app. All that's required from your Raspberry Pi is to have MOS running.\n\n\n\n\nThe following commands will be entered in the terminal that you installed the MATRIX CLI tool in.\n\n\n\n\nUse the command below to create a MOS app which will generate a folder with the necessary files. You will be prompted to enter a quick description and optional keywords to describe this app.\n\n\nmatrix create YOUR_APP_NAME_HERE\n\n\n\n\nThe file structure will look like this:\n\n\nYOUR_APP_FOLDER\n    * app.js (Where you write your code)\n    * config.yaml (Configuration file for application)\n    * index.js (Imports MATRIX libraries for use in app.js)\n    * package.json (Defines npm modules to install on your MATRIX Device)\n    * README.MD (Readme file for MATRIX App Store)\n\n\n\n\nOpen the app.js file and paste the code below with any text editor.\n\n\nmatrix.led('green').render();//turn all LEDs green\n\n\n\n\n\n\nDeploying Your App\n\n\nWith your MOS app completed, all that's left to do is run the following commands to deploy and then start the app on your MATRIX device.\n\n\nmatrix deploy PATH_TO_YOUR_APP_HERE\nmatrix start YOUR_APP_NAME_HERE\n\n\n\n\nPreview\n\n\n\nThe interactive video below will show you the terminal outputs to expect from following this guide.\n\n\n\nResults\n\nWhen the MOS app runs, your MATRIX device should look like the image below.\n\n\n\n\n\n\nNext Steps\n\n\nView our \nreference page\n to see what you can with the MATRIX OS SDK or learn how to publish a MATRIX app \nhere\n.", 
            "title": "Applications"
        }, 
        {
            "location": "/matrix-os/getting-started/applications/#introduction", 
            "text": "MOS applications allow you to easily utilize the components and sensors of your MATRIX device through Javascript. This IoT platform enables you to create applications and integrate them with any third party API to expand the functionality of your MATRIX device.", 
            "title": "Introduction"
        }, 
        {
            "location": "/matrix-os/getting-started/applications/#initial-setup", 
            "text": "MOS apps are designed to be developed outside your MATRIX device and deployed when you want to run your app. All that's required from your Raspberry Pi is to have MOS running.   The following commands will be entered in the terminal that you installed the MATRIX CLI tool in.   Use the command below to create a MOS app which will generate a folder with the necessary files. You will be prompted to enter a quick description and optional keywords to describe this app.  matrix create YOUR_APP_NAME_HERE  The file structure will look like this:  YOUR_APP_FOLDER\n    * app.js (Where you write your code)\n    * config.yaml (Configuration file for application)\n    * index.js (Imports MATRIX libraries for use in app.js)\n    * package.json (Defines npm modules to install on your MATRIX Device)\n    * README.MD (Readme file for MATRIX App Store)  Open the app.js file and paste the code below with any text editor.  matrix.led('green').render();//turn all LEDs green", 
            "title": "Initial Setup"
        }, 
        {
            "location": "/matrix-os/getting-started/applications/#deploying-your-app", 
            "text": "With your MOS app completed, all that's left to do is run the following commands to deploy and then start the app on your MATRIX device.  matrix deploy PATH_TO_YOUR_APP_HERE\nmatrix start YOUR_APP_NAME_HERE", 
            "title": "Deploying Your App"
        }, 
        {
            "location": "/matrix-os/getting-started/applications/#next-steps", 
            "text": "View our  reference page  to see what you can with the MATRIX OS SDK or learn how to publish a MATRIX app  here .", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-os/getting-started/publishing/", 
            "text": "Publishing your Application\n\n\n\n\n\nMATRIX App Store is in \nearly development\n. All applications may be reviewed and are subject to removal at any time.\n\n\n\n\nMATRIX applications can be published to the \nMATRIX App Store\n for users to share their IoT creations with the community.\n\n\n\n\n\n\nBefore publishing an application.\n\n\nEnsure Meta Information is Accurate\n\n\n\nThe following information goes into your MATRIX application's \nconfig.yaml\n. The contents of your app's \nREADME.md\n will be shown on its detail page, along with any images provided.\n\n\nRequired Meta Information\n\n\n\n\n\n\nname\n - The CLI command \nmatrix install\n will use this to find your app.\n\n\n\n\n\n\ndescription\n - Mini description shown in app preview.\n\n\n\n\n\n\ndisplayName\n - Name shown on the app store.\n\n\n\n\n\n\nOptional Meta Information:\n\n\n\n\n\n\nimageUrls\n - will be used on the detail page\n\n\n\n\n\n\ngalleryUrl\n - will be used on the main App Store page, or the first item in \nimageUrls\n will be used\n\n\n\n\n\n\nkeywords\n - are used to tag your application and will be used to return your application on searches for these keywords.\n\n\n\n\n\n\ncategories\n - are not yet formalized, but will divide the store listings. Submitting proposed app categories will inform this process.\n\n\n\n\n\n\n#example config.yaml\n\nname: example-app\ndisplayName: The Example App\ndescription: An example application config.yaml.\n\nimageUrls:\n  - http://image.com/1\n  - http://image.com/2\n\ngalleryUrl: http://image.com/3\n\nkeywords:\n  - example\n  - configuration\n\ncategories:\n  - entertainment\n  - development\n\n\n\n\nEnsure Components are Setup\n\n\n\nAll applications, which use events and sensors, must register these in the config file..\n\n\nEvents\n\n\n\nevents:\n  - face-recognized\n  - locked-door\n\n\n\n\nSensors\n\n\n\nsensors:\n  - temperature\n  - uv\n\n\n\n\nA user will be required to grant an application permissions before installing. A user may install an app with any or all permissions enabled.\n\n\n\n\nUploading An Application\n\n\nYour application must do only what it claims to do with the name, description and README.md.\n\n\nAll sensors, integrations, and services must be registered in the \nconfig.yaml\n. User's will give consent for each after installing your app.\n\n\nTo upload the your application, use the following \nMATRIX CLI\n command and point it to your app folder.\n\n\nmatrix publish YOUR_APP_FOLDER", 
            "title": "Publishing Apps"
        }, 
        {
            "location": "/matrix-os/getting-started/publishing/#before-publishing-an-application", 
            "text": "", 
            "title": "Before publishing an application."
        }, 
        {
            "location": "/matrix-os/getting-started/publishing/#uploading-an-application", 
            "text": "Your application must do only what it claims to do with the name, description and README.md.  All sensors, integrations, and services must be registered in the  config.yaml . User's will give consent for each after installing your app.  To upload the your application, use the following  MATRIX CLI  command and point it to your app folder.  matrix publish YOUR_APP_FOLDER", 
            "title": "Uploading An Application"
        }, 
        {
            "location": "/matrix-os/reference/", 
            "text": "MATRIX OS SDK\n\n\nSensors\n\nSensor interfaces and data structures\n\nEverloop\n\nLED interface\n\n\n\n\n\n\n\n\n\n\n\nConfiguration\n\n\nConfig.yaml\n\nOverview of the MOS app config.yaml file.\n\nCLI Tool\n\nMOS command-line interface.\n\nDashboard\n\nExplore data representation and input with a live dashboard.\n\nWidgets\n\nReference for all dashboard widgets.\n\nCross Talk\n\nExchange information between apps and devices.\n\nData Types\n\nconfig.yaml data types overview.\n\nSystem Methods\n\nFor application defaults or end-user configurable variables.", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-os/reference/#matrix-os-sdk", 
            "text": "", 
            "title": "MATRIX OS SDK"
        }, 
        {
            "location": "/matrix-os/reference/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/sensors/", 
            "text": "Sensors\n\n\n\nDevice Compatibility\n\n\n\n\nAvailable Sensors\n\n\ntemperature\n, \nhumidity\n, \npressure\n, \nuv\n, \ngyroscope\n, \naccelerometer\n\n\nConfiguration\n\n\n\n\nYou should have familiarity with \nConfiguration Files\n before exploring further. \n\n\n\n\nWhen downloading an app from the \nMATRIX App Store\n, End users must explicitly authorize MOS applications to utilize\u00a0hardware sensors.\n\n\nThis requires that each application to identify the sensors it requires in \nconfig.yaml\n. Sensors will not work unless this is specified. Below is an example for an app that requires the temperature and humidity sensor.\n\n\nsensors:\n  - temperature\n  - humidity\n\n\n\n\nReading Sensors\n\n\nAll sensors are initialized using the \nsensor\n method. This method should only be used once per sensor. Once called, your can use a \n.then\n promise to initiate a callback.\n\n\nmatrix.sensor(sensorType, options);\n\n\n\n\n\n\nsensorType\n: Type of sensor you are initializing \n\n\noptions\n: The options for that sensor. All sensors support a \nrefresh\n and \ntimeout\n property.\n\n\n\n\n// Example\nvar temperatureValue = 0; // global variable to hold sensor value\nvar humidityValue = 0; // global variable to hold humidity value\n\n// Sensor options\nvar options = {\n  refresh: 1000, // milliseconds between data points\n  timeout: 10000 // how long before stopping this sensor\n};\n\n// Begin calling temperature sensor\nmatrix.sensor('temperature', options).then(data =\n {\n  temperatureValue = data.value; // update global variable\n  console.log(temperatureValue); // print new temperature value\n});\n\n// Begin calling humidity sensor\nmatrix.sensor('humidity', options).then(data =\n {\n  humidityValue = data.value; // update global variable\n  console.log(humidityValue); // print new humidity value\n});\n\n\n\n\nOutputs\n\n\nBelow are all the possible data formats for each sensor.\n\nTemperature\n\nOutput for \ntemperature\n (in \n).\n\n\n{\n  value: 36.95899963378906,\n  type: 'temperature'\n}\n\n\n\n\nHumidity\n\n\n\nOutput for \nhumidity\n.\n\n\n{\n  value: 30.409704208374023,\n  type: 'humidity'\n}\n\n\n\n\nPressure\n\n\n\nOutput for \npressure\n (in mbars).\n\n\n{\n  value: 101692,\n  type: 'pressure'\n}\n\n\n\n\nUV\n\n\n\nOutput for \nUV\n.\n\n\n{\n   value: 0.0053547522984445095,\n   risk: 'Low'\n}\n\n\n\n\nGyroscope\n\n\n\nOutput for \ngyroscope\n.\n\n\n{\n  yaw: 144.78964233398438,\n  pitch: 2.112252950668335,\n  roll: -92.0414810180664,\n  x: -10.78155517578125,\n  y: 1.8841552734375,\n  z: 0.441131591796875,\n  type: 'gyroscope'\n}\n\n\n\n\n\nAccelerometer\n\n\n\nOutput for \naccelerometer\n\n\n{\n  x: 0.1,\n  y: 0.23,\n  z: 0.224,\n  type: 'accelerometer'\n}\n\n\n\n\nMagnetometer\n\n\n\nOutput for \nmagnetometer\n\n\n{\n  x: 0.51,\n  y: 0.53,\n  z: -0.124,\n  type: 'magnetometer'\n}", 
            "title": "Sensors"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#device-compatibility", 
            "text": "", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#available-sensors", 
            "text": "temperature ,  humidity ,  pressure ,  uv ,  gyroscope ,  accelerometer", 
            "title": "Available Sensors"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#configuration", 
            "text": "You should have familiarity with  Configuration Files  before exploring further.    When downloading an app from the  MATRIX App Store , End users must explicitly authorize MOS applications to utilize\u00a0hardware sensors.  This requires that each application to identify the sensors it requires in  config.yaml . Sensors will not work unless this is specified. Below is an example for an app that requires the temperature and humidity sensor.  sensors:\n  - temperature\n  - humidity", 
            "title": "Configuration"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#reading-sensors", 
            "text": "All sensors are initialized using the  sensor  method. This method should only be used once per sensor. Once called, your can use a  .then  promise to initiate a callback.  matrix.sensor(sensorType, options);   sensorType : Type of sensor you are initializing   options : The options for that sensor. All sensors support a  refresh  and  timeout  property.   // Example\nvar temperatureValue = 0; // global variable to hold sensor value\nvar humidityValue = 0; // global variable to hold humidity value\n\n// Sensor options\nvar options = {\n  refresh: 1000, // milliseconds between data points\n  timeout: 10000 // how long before stopping this sensor\n};\n\n// Begin calling temperature sensor\nmatrix.sensor('temperature', options).then(data =  {\n  temperatureValue = data.value; // update global variable\n  console.log(temperatureValue); // print new temperature value\n});\n\n// Begin calling humidity sensor\nmatrix.sensor('humidity', options).then(data =  {\n  humidityValue = data.value; // update global variable\n  console.log(humidityValue); // print new humidity value\n});", 
            "title": "Reading Sensors"
        }, 
        {
            "location": "/matrix-os/reference/sensors/#outputs", 
            "text": "Below are all the possible data formats for each sensor.", 
            "title": "Outputs"
        }, 
        {
            "location": "/matrix-os/reference/leds/", 
            "text": "Everloop\n\n\n\nDevice Compatibility\n\n\n\n\n\n\nThe Everloop is a powerful tool for visually communicating through LEDs. Click the video below to learn more.\n\n\n\n\n\n\nmatrix.darken()\n and \nmatrix.brighten()\n have not been implemented.\n\n\n\n\nString Notation \n Render\n\n\nYou can use any CSS color property (color-name, rgb, and hex). Darker colors on the Everloop generally display with more precision then lighter colors, which tend to get washed out. The code below shows how to set the entire Everloop to green with each CSS property.\n\n\n\n\nThe \n.render()\n method must be included at the end of the \nmatrix.led()\n method to update your MATRIX device's LEDs.\n\n\n\n\n// String\nmatrix.led('green').render();\n// Hexadecimal\nmatrix.led('#00ff00').render();\n// RGB\nmatrix.led('rgb(0,255,0)').render();\n\n\n\n\n\n\nPlease avoid using \nrgba\n. Alpha values do not render correctly.\n\n\n\n\nCreating Shapes\n\n\n\n\nCurrently, shape manipulation on the MATRIX Voice does not render properly. Fix in progress!\n\n\n\n\nShape objects are methods of manipulating multiple LEDs in the Everloop at once.  Shape creation is simple, you define the shape you want to make as an object and pass it into \nmatrix.led()\n like the example below\n\n\nmatrix.led({\n  arc: 90, //arc shape that takes up 90\u00b0 of Everloop \n  color: green, //turn shape green\n  start: 0 //start shape at 0\u00b0 of Everloop\n}).render();\n\n\n\n\nAvailable Shapes\n\n\n\nInclude one of these \nshape\n properties in your shape.\n\n\narc: 90 //number of degrees to draw an arc, supports negative values\nangle: 45 //degree number to draw a single point\n\n\n\n\nShape Properties\n\n\n\nEvery Shape object must include the \ncolor\n property to render.\n\n\ncolor: 'red' //color strings, as specified above\nspin: 230 //rotate color hue ( 0 - 360 )\nstart: 0  //degree at which shape begins, arc shape only\n\n\n\n\nRotation Operation\n\n\n\nThese operate on the shapes and colors defined in the \nled\n object.\n\n\n.rotate(angle); //rotates whole shape by number of degrees \n\n\n\n\nmatrix.led({\n    arc: 45,\n    color: 'blue',\n    start: 50\n}).rotate(90).render();\n\n\n\n\nMultiple Shapes\n\n\n\nUse an array in the \nmatrix.led()\n method to include multiple shapes.\n\n\n// make a smiley face\nmatrix.led([\n  //left eye angle\n  {\n    angle: 45,\n    color: 'yellow'\n  },\n  //right eye angle\n  {\n    angle: 135,\n    color: 'yellow'\n  },\n  //smile arc\n  {\n    arc: 90,\n    color: 'yellow',\n    start: 225\n  }\n]).render();\n\n\n\n\nDirect LED Manipulation\n\n\n\nArray index indicates the LED to change. The index of an LED is labeled directly above the LED on your MATRIX device (D1, D2, D3, D4, etc..). Use 0 to turn off the LED.\n\n\nmatrix.led([0, 0, 0, 0, 'yellow', 0,\n0, 0, 0, 0, 0, 0, 0, 'yellow', 0, 0,\n0, 0, 0, 0, 0, 0, 'yellow', 'yellow',\n'yellow', 'yellow', 'yellow', 'yellow',\n'yellow', 'yellow', 'yellow']).render();\n\n\n\n\nLED Animation\n\n\nBy using a \nsetInterval()\n method, you can animate the LEDs on the Everloop. Below is an example of an active clock that demonstrates this. \n\n\nsetInterval(function(){\n  var time = new Date();\n  var h = time.getHours();\n  var m = time.getMinutes();\n  var s = time.getSeconds();\n\n  var hourLED = {\n    // translate hours (12) to angle (360)\n    arc: h * 3,\n    color: 'blue'\n  };\n\n  var minuteLED = {\n    // translate minutes ( 60 ) to angle ( 360 )\n    angle: m * 6,\n    color: 'green'\n  };\n\n  var secondLED = {\n    // translate seconds (60) to angle (360)\n    angle: s * 6,\n    color: 'yellow',\n  };\n\n  // will draw all three\n  matrix.led([hourLED, minuteLED, secondLED]).render();\n\n}, 1000);\n\n\n\n\nAdvanced Use\n\n\nEnable \nSUN_MODE=true\n as a flag, when launching MATRIX OS, to turn on the white LEDs (and the luminence calculations). Wear sunglasses or use another mode of protecting your eyes when using this while developing. It is intended for use behind coverings.\n\n\nSUN_MODE=true node index", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-os/reference/leds/#device-compatibility", 
            "text": "The Everloop is a powerful tool for visually communicating through LEDs. Click the video below to learn more.    matrix.darken()  and  matrix.brighten()  have not been implemented.", 
            "title": "Device Compatibility"
        }, 
        {
            "location": "/matrix-os/reference/leds/#string-notation-render", 
            "text": "You can use any CSS color property (color-name, rgb, and hex). Darker colors on the Everloop generally display with more precision then lighter colors, which tend to get washed out. The code below shows how to set the entire Everloop to green with each CSS property.   The  .render()  method must be included at the end of the  matrix.led()  method to update your MATRIX device's LEDs.   // String\nmatrix.led('green').render();\n// Hexadecimal\nmatrix.led('#00ff00').render();\n// RGB\nmatrix.led('rgb(0,255,0)').render();   Please avoid using  rgba . Alpha values do not render correctly.", 
            "title": "String Notation &amp; Render"
        }, 
        {
            "location": "/matrix-os/reference/leds/#creating-shapes", 
            "text": "Currently, shape manipulation on the MATRIX Voice does not render properly. Fix in progress!   Shape objects are methods of manipulating multiple LEDs in the Everloop at once.  Shape creation is simple, you define the shape you want to make as an object and pass it into  matrix.led()  like the example below  matrix.led({\n  arc: 90, //arc shape that takes up 90\u00b0 of Everloop \n  color: green, //turn shape green\n  start: 0 //start shape at 0\u00b0 of Everloop\n}).render();", 
            "title": "Creating Shapes"
        }, 
        {
            "location": "/matrix-os/reference/leds/#led-animation", 
            "text": "By using a  setInterval()  method, you can animate the LEDs on the Everloop. Below is an example of an active clock that demonstrates this.   setInterval(function(){\n  var time = new Date();\n  var h = time.getHours();\n  var m = time.getMinutes();\n  var s = time.getSeconds();\n\n  var hourLED = {\n    // translate hours (12) to angle (360)\n    arc: h * 3,\n    color: 'blue'\n  };\n\n  var minuteLED = {\n    // translate minutes ( 60 ) to angle ( 360 )\n    angle: m * 6,\n    color: 'green'\n  };\n\n  var secondLED = {\n    // translate seconds (60) to angle (360)\n    angle: s * 6,\n    color: 'yellow',\n  };\n\n  // will draw all three\n  matrix.led([hourLED, minuteLED, secondLED]).render();\n\n}, 1000);", 
            "title": "LED Animation"
        }, 
        {
            "location": "/matrix-os/reference/leds/#advanced-use", 
            "text": "Enable  SUN_MODE=true  as a flag, when launching MATRIX OS, to turn on the white LEDs (and the luminence calculations). Wear sunglasses or use another mode of protecting your eyes when using this while developing. It is intended for use behind coverings.  SUN_MODE=true node index", 
            "title": "Advanced Use"
        }, 
        {
            "location": "/matrix-os/reference/configuration/", 
            "text": "Configuration\n\n\n\nEach MOS application has a configuration file \nconfig.yaml\n that's required to have, in order to run.\n\n\nWhat this file does:\n\n\n\n\nSets meta information for the application, which is used in the \nMATRIX App Store\n.\n\n\nDefines a schema for \nsending data\n from the device.\n\n\nIdentifies which \nsensors\n, services\n, \nevents\n and \nintegrations\n an application utilizes.\n\n\nDefines dynamic \nsettings\n variables, which are available to the application and end-user modifiable.\n\n\nDefines the \nwidgets\n and their layout in the \ndashboard\n\n\nGenerates a policy on install, asking the user for specific access to their device.\n\n\n\n\nConfiguration Options\n\n\n\n\nname\n - Name of the application that appears as part of the application store when viewing it.\n\n\ndescription\n - Short description that appears as part of the application when deploying or pushing to App Store.\n\n\nkeywords\n - a few values about the application. ex: \nface, door, unlock\n\n\nversion\n - this field will be updated by the CLI on publish.\n\n\nconfigVersion\n - This field defines what version is the configuration. don't touch this. \n\n\nsettings\n - runtime variables for MOS applications\n\n\ndataTypes\n - schema for structured data from an application\n\n\nsensors\n - which sensors to activate for this application\n\n\nintegrations\n - which external integrations does this application support ie. \nifttt\n\n\nevents\n - which events this application has listeners for \n\n\nscreens\n - layout for widgets. see \nLayout\n\n\nwidgets\n - widget definitions. see \nWidgets\n\n\nservices\n - service definitions. \n\n\n\n\n#example config.yaml\n\nname: example-app\ndisplayName: The Example App\ndescription: An example application config.yaml.\n\nimageUrls:\n  - http://image.com/1\n\nkeywords:\n  - example\n  - configuration\n\ncategories:\n  - entertainment\n\nsensors:\n  - temperature\n  - gyroscope\n\n\n\n\nUsage Notes\n\n\nThe \nconfig.yaml\n is standardized before installation, which will modify it somewhat, especially in the widget definations. Do not be alarmed if your installed \nconfig.yaml\n does not match the original, this is normal.\n\n\nMore info\n\n\nSee the helper library with examples at: \nhttps://github.com/matrix-io/matrix-app-config-helper", 
            "title": "Config.yaml"
        }, 
        {
            "location": "/matrix-os/reference/configuration/#configuration-options", 
            "text": "name  - Name of the application that appears as part of the application store when viewing it.  description  - Short description that appears as part of the application when deploying or pushing to App Store.  keywords  - a few values about the application. ex:  face, door, unlock  version  - this field will be updated by the CLI on publish.  configVersion  - This field defines what version is the configuration. don't touch this.   settings  - runtime variables for MOS applications  dataTypes  - schema for structured data from an application  sensors  - which sensors to activate for this application  integrations  - which external integrations does this application support ie.  ifttt  events  - which events this application has listeners for   screens  - layout for widgets. see  Layout  widgets  - widget definitions. see  Widgets  services  - service definitions.    #example config.yaml\n\nname: example-app\ndisplayName: The Example App\ndescription: An example application config.yaml.\n\nimageUrls:\n  - http://image.com/1\n\nkeywords:\n  - example\n  - configuration\n\ncategories:\n  - entertainment\n\nsensors:\n  - temperature\n  - gyroscope", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/matrix-os/reference/configuration/#usage-notes", 
            "text": "The  config.yaml  is standardized before installation, which will modify it somewhat, especially in the widget definations. Do not be alarmed if your installed  config.yaml  does not match the original, this is normal.", 
            "title": "Usage Notes"
        }, 
        {
            "location": "/matrix-os/reference/configuration/#more-info", 
            "text": "See the helper library with examples at:  https://github.com/matrix-io/matrix-app-config-helper", 
            "title": "More info"
        }, 
        {
            "location": "/matrix-os/reference/cli-tool/", 
            "text": "Command Line Interface (CLI)\n\n\n\nThe MATRIX CLI tool is a terminal interface for managing your MATRIX devices and applications. This includes deploying, downloading, and publishing applications.\n\n\n\n\nMATRIX CLI requires \nNode.js\n on your personal computer.\n\n\n\n\n\n\nInstallation\n\n\nTo install the MATRIX CLI, execute the following command in your personal computer's terminal.\n\n\nnpm install -g matrix-cli\n\n\n\n\n\n\nCommand list\n\n\nTyping \nmatrix\n lists all the available MATRIX CLI commands. Each command for the CLI tool must begin with \nmatrix\n.\n\n\nSetup\n\n\n\n\n\n\nmatrix register\n - Register for a MATRIX Labs account.\n\n\n\u21b3 \nmatrix register device\n - Registers a MATRIX device to your account.\n\n\n\n\n\n\nmatrix account\n - View MATRIX Labs account details.\n\n\n\u21b3 \nmatrix account profile\n - Edit account details.\n\n\n\n\n\n\nmatrix remove YOUR_DEVICE_NAME_OR_ID\n - Removes a MATRIX device from your account.\n\n\n\n\n\n\nmatrix login\n - Sign into MATRIX Labs account.\n\n\n\n\n\n\nmatrix logout\n - Sign out of MATRIX Labs account.\n\n\n\n\n\n\nmatrix upgrade\n - Update current MATRIX CLI tool version.\n\n\n\n\n\n\nmatrix use YOUR_DEVICE_NAME_OR_ID\n - Select MATRIX device to use.\n\n\n\n\n\n\nmatrix set\n - Set environment or locale.\n\n\n\u21b3   \nmatrix set env DESIRED_ENV\n - Switch between \ndev\n, \nrc\n, and \nproduction\n environments. Recommended to stay in \nrc\n.\n\n\n\u21b3   \nmatrix set locale DESIRED_LOCALE\n - Switch between \nes\n (spanish) and \nen\n (english) locale for the MATRIX CLI tool.\n\n\n\n\n\n\nManagement\n\n\n\n\n\n\nmatrix list\n - Lists all MATRIX devices or apps.\n\n\n\u21b3 \nmatrix list devices\n - Lists all registered devices.\n\n\n\u21b3 \nmatrix list apps\n - Lists all installed MATRIX apps for the current device.\n\n\n\n\n\n\nApps\n\n\n\n\n\n\nmatrix search APP_NAME\n - Check if a MATRIX app is listed in the app store\n\n\n\n\n\n\nmatrix install APP_NAME\n - Install MATRIX app to your MATRIX device.\n\n\n\n\n\n\nmatrix uninstall APP_NAME\n - Uninstall MATRIX app from your MATRIX device.\n\n\n\n\n\n\nmatrix config APP_NAME\n - Check configuration of an installed MATRIX app.\n\n\n\n\n\n\nmatrix start APP_NAME\n - Starts an installed MATRIX app.\n\n\n\n\n\n\nmatrix stop APP_NAME\n - Stops an installed MATRIX app.\n\n\n\n\n\n\nmatrix restarts APP_NAME\n - Restarts an installed MATRIX app.\n\n\n\n\n\n\nDevelopment\n\n\n\n\n\n\nmatrix create APP_NAME\n - Creates folder with the necessary files for a MATRIX app.\n\n\n\n\n\n\nmatrix deploy APP_FOLDER\n - Installs MATRIX app to your MATRIX device.\n\n\n\n\n\n\nmatrix publish APP_FOLDER\n - Upload MATRIX app to the app store.\n\n\n\n\n\n\nmatrix unPublish APP_NAME\n - Remove MATRIX app from the app store.\n\n\n\n\n\n\nmatrix trigger EVENT_TO_EMIT\n - Emits a \nCross-talk\n event to each MATRIX device.\n\n\n\n\n\n\nmatrix ping\n - Flashes the lights on MATRIX device currently selected.\n\n\n\n\n\n\nmatrix log\n - Shows all console.log() outputs from your MATRIX device.\n\n\n\n\n\n\n\n\nmatrix ping\n has a known \nissue\n where it will output an error, but still ping the device.", 
            "title": "CLI Tool"
        }, 
        {
            "location": "/matrix-os/reference/cli-tool/#installation", 
            "text": "To install the MATRIX CLI, execute the following command in your personal computer's terminal.  npm install -g matrix-cli", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-os/reference/cli-tool/#command-list", 
            "text": "Typing  matrix  lists all the available MATRIX CLI commands. Each command for the CLI tool must begin with  matrix .", 
            "title": "Command list"
        }, 
        {
            "location": "/matrix-os/reference/cli-tool/#setup", 
            "text": "matrix register  - Register for a MATRIX Labs account.  \u21b3  matrix register device  - Registers a MATRIX device to your account.    matrix account  - View MATRIX Labs account details.  \u21b3  matrix account profile  - Edit account details.    matrix remove YOUR_DEVICE_NAME_OR_ID  - Removes a MATRIX device from your account.    matrix login  - Sign into MATRIX Labs account.    matrix logout  - Sign out of MATRIX Labs account.    matrix upgrade  - Update current MATRIX CLI tool version.    matrix use YOUR_DEVICE_NAME_OR_ID  - Select MATRIX device to use.    matrix set  - Set environment or locale.  \u21b3    matrix set env DESIRED_ENV  - Switch between  dev ,  rc , and  production  environments. Recommended to stay in  rc .  \u21b3    matrix set locale DESIRED_LOCALE  - Switch between  es  (spanish) and  en  (english) locale for the MATRIX CLI tool.", 
            "title": "Setup"
        }, 
        {
            "location": "/matrix-os/reference/cli-tool/#management", 
            "text": "matrix list  - Lists all MATRIX devices or apps.  \u21b3  matrix list devices  - Lists all registered devices.  \u21b3  matrix list apps  - Lists all installed MATRIX apps for the current device.", 
            "title": "Management"
        }, 
        {
            "location": "/matrix-os/reference/cli-tool/#apps", 
            "text": "matrix search APP_NAME  - Check if a MATRIX app is listed in the app store    matrix install APP_NAME  - Install MATRIX app to your MATRIX device.    matrix uninstall APP_NAME  - Uninstall MATRIX app from your MATRIX device.    matrix config APP_NAME  - Check configuration of an installed MATRIX app.    matrix start APP_NAME  - Starts an installed MATRIX app.    matrix stop APP_NAME  - Stops an installed MATRIX app.    matrix restarts APP_NAME  - Restarts an installed MATRIX app.", 
            "title": "Apps"
        }, 
        {
            "location": "/matrix-os/reference/cli-tool/#development", 
            "text": "matrix create APP_NAME  - Creates folder with the necessary files for a MATRIX app.    matrix deploy APP_FOLDER  - Installs MATRIX app to your MATRIX device.    matrix publish APP_FOLDER  - Upload MATRIX app to the app store.    matrix unPublish APP_NAME  - Remove MATRIX app from the app store.    matrix trigger EVENT_TO_EMIT  - Emits a  Cross-talk  event to each MATRIX device.    matrix ping  - Flashes the lights on MATRIX device currently selected.    matrix log  - Shows all console.log() outputs from your MATRIX device.     matrix ping  has a known  issue  where it will output an error, but still ping the device.", 
            "title": "Development"
        }, 
        {
            "location": "/matrix-os/reference/dashboard/", 
            "text": "Dashboard\n\n\n\n\n\nYou should have familiarity with \nConfiguration Files\n before exploring further. \n\n\n\n\nThe MATRIX Dashboard is an online interface that can manage each of your MATRIX devices and applications. The dashboard itself consists of \nwidgets\n which are defined in the \nconfiguration file\n, \nconfig.yaml\n. Widgets provide representation for data coming from a MATRIX application and they can provide controls for users to modify how a MATRIX application operates. Each application can have its own dashboard view.\n\n\nView your Dashboard \nhere\n.\n\n\nScreens\n\n\nScreens are where we define the placement of \nwidgets\n on the dashboard (consists of rows and columns). Adding \nscreens\n to your \nconfig.yaml\n file will require you to specify your widget names and dashboard placements. Below are some examples of how to defines your screens.\n\n\n\n\n--\n New row.\n\n\n-\n New column.\n\n\n\n\nscreens:\n  #Row 1 has 2 Columns\n  - - myTopLeftWidget\n    - myTopRightWidget\n\n\n\n\nscreens:\n  #Row 1 has 2 Columns\n  - - myTopLeftWidget\n    - myTopRightWidget\n  #Row 2 has 3 Columns\n  - - myBottomLeftWidget\n    - myBottomMiddleWidget\n    - myBottomRightWidget\n\n\n\n\nEach \nscreens\n item looks for a \nwidgets\n item with the same name to show on the dashboard. The following example shows how to properly define these.\n\n\n\n\nscreens:\n  - - startButton\n    - readDeviceSensors\n\nwidgets:\n  startButton:\n    control: button\n    event: buttonInfo\n    value: START\n    label: Turn LEDs On\n  readDeviceSensors:\n    control: switch\n    event: sensorsEnabled\n    value: Sensors Enabled\n    label: Send Sensor Data\n\n\n\n\n\n\nWidgets\n\n\nNow that you know how to display widgets, learn which \nwidgets\n are available in the dashboard and how to configure them \nhere\n.", 
            "title": "Dashboard"
        }, 
        {
            "location": "/matrix-os/reference/dashboard/#screens", 
            "text": "Screens are where we define the placement of  widgets  on the dashboard (consists of rows and columns). Adding  screens  to your  config.yaml  file will require you to specify your widget names and dashboard placements. Below are some examples of how to defines your screens.   --  New row.  -  New column.   screens:\n  #Row 1 has 2 Columns\n  - - myTopLeftWidget\n    - myTopRightWidget  screens:\n  #Row 1 has 2 Columns\n  - - myTopLeftWidget\n    - myTopRightWidget\n  #Row 2 has 3 Columns\n  - - myBottomLeftWidget\n    - myBottomMiddleWidget\n    - myBottomRightWidget  Each  screens  item looks for a  widgets  item with the same name to show on the dashboard. The following example shows how to properly define these.   screens:\n  - - startButton\n    - readDeviceSensors\n\nwidgets:\n  startButton:\n    control: button\n    event: buttonInfo\n    value: START\n    label: Turn LEDs On\n  readDeviceSensors:\n    control: switch\n    event: sensorsEnabled\n    value: Sensors Enabled\n    label: Send Sensor Data", 
            "title": "Screens"
        }, 
        {
            "location": "/matrix-os/reference/dashboard/#widgets", 
            "text": "Now that you know how to display widgets, learn which  widgets  are available in the dashboard and how to configure them  here .", 
            "title": "Widgets"
        }, 
        {
            "location": "/matrix-os/reference/widgets/", 
            "text": "Widgets\n\n\n\n\n\nYou should have familiarity with \nData Types\n, \nCross Talk\n and \nDashboard\n before exploring further. \n\n\n\n\nWidgets are what allow you to visualize and or control your MATRIX applications through the MATRIX Dashboard.\n\n\n\n\nWidget Configuration\n\n\nEach widget requires certain options to be defined before they can properly show on the dashboard. The list below will go through each available option for \nwidgets\n.\n\nWidget Types\n\n\n\n\nDisplay Widgets\n - Displays data from an application.\n\n\nControl Widgets\n - Sends real-time events to an application.\n\n\n\n\nAll Widget Options\n\n\n\n\n\nlabel\n - Optional display title for widget.\n\n\nsize\n - Optional percentage value for a widget's width (\n25\n, \n50\n, \n75\n, etc..).\n\n\n\n\n\n\nwidgets\n can only have either a \ndisplay\n or \ncontrol\n option when choosing a widget type.\n\n\n\n\nDisplay Widget Options\n\n\n\nDisplay widgets, like tables, charts and value outputs are only concerned with what data to display and how to display it.\n\n\ndisplay\n - Which display widget to load\n\n\n\n\ntype\n - Select type from a defined data type (see \nSending Data\n ).\n\n\nkey\n/\nkeys\n - Select key or keys being used from  \ntype\n.\n\n\nformat\n - Filter the data. choose from \ncount\n, \nsum\n, \navg\n, \npercent\n, \nmax\n, \nmin\n, \nfixed\n, \nround\n.\n\n\nrealtime\n - Defaults to \ntrue\n. Use the \nrefresh\n option for manual updates.\n\n\nrefresh\n - How many seconds between data refresh. use with \nrealtime\n set to \nfalse\n. \n\n\n\n\nInteractive Widget Options\n\n\n\nInteractive widgets, like buttons, switches, and controllers are meant to send data from the MATRIX Dashboard to your MATRIX app.\n\n\ncontrol\n - Which control widget option load\n\n\n\n\ntrigger\n - The event to listen for in your application ( see \nReference \n Crosstalk\n)\n\n\nvalue\n - On button widgets, what text should be in the button\n\n\nmap\n - On button widgets, a collection of \nvalue: trigger\n where value is the button text, and trigger is the event fired\n\n\n\n\n\n\nDisplay widgets\n\n\nIndicated via a \ndisplay\n option.\n\n\nEach example will show how to configure their respective widget. \nscreens\n and \ndataTypes\n will be left up to you to configure.\n\n\n\n\n\n\n\nbar\n - bar chart\n\n\n\n\n#config.yaml\nwidgets:\n  barChartTest:\n    display: bar\n    type: monitor\n    keys: cpu, memory\n    format: avg\n    realtime: false\n    refresh: 60\n    label: Bar Chart\n\n\n\n\n//send data through app.js\nmatrix.type('monitor').send({\n  'cpu': 7.03,\n  'memory': 2.30 \n});  \n\n\n\n\n\n\n\n\n\n\n\ndigit\n - numerical\n\n\n\n\n#config.yaml\nwidgets:\n  digitTest:\n    display: digit\n    type: monitor\n    key: cpu\n    format: round\n    label: cpu\n\n\n\n\n//send data through app.js\nmatrix.type('monitor').send({\n  'cpu': 2.4,\n  'memory': 5.4 \n});  \n\n\n\n\n\n\n\n\n\n\n\nradar\n - radar chart\n\n\n\n\n#config.yaml\nwidgets:\n  radarTest:\n    display: radar\n    type: emotions\n    keys: happy,sad,disgust,surprised,confused,calm,angry\n    label: Emotions\n\n\n\n\n//send data through app.js\nmatrix.type('emotions').send({\n  'happy': 67,\n  'sad': 50,\n  'disgust': 78,\n  'surprised': 56,\n  'confused': 86,\n  'calm': 70,\n  'angry': 60 \n});  \n\n\n\n\n\n\n\n\n\n\n\nline\n - line chart\n\n\n\n\n#config.yaml\nwidgets:\n  lineChartTest:\n    display: line\n    type: monitor\n    format: avg\n    keys: cpu, memory\n    realtime: true\n    label: Line Chart\n\n\n\n\n//send data through app.js\nmatrix.type('monitor').send({\n  'cpu': 7.03,\n  'memory': 2.30 \n});  \n\n\n\n\n\n\n\n\n\n\n\nlist\n - data table\n\n\n\n\n#config.yaml\nwidgets:\n  listTest:\n    display: list\n    type: device\n    keys: Hostname,Type,Platform,Arch\n    label: Secret Information\n\n\n\n\n//send data through app.js\nmatrix.type('device').send({\n  'Hostname': 'h7n.domain',\n  'Type': 'Darwin',\n  'Platform': 'darwin',\n  'Arch': 'x64'\n});  \n\n\n\n\n\n\n\n\n\n\n\nlist-group\n - grouped data table\n\n\nSimple Group\n\n\n\n\n#config.yaml\nwidgets:\n  info:\n    display: list-group\n    type: vehicleDetection\n    keys: count\n    format: count\n    label: Total\n\n\n\n\n//send data through app.js\nmatrix.type('vehicleDetection').send({\n  'zoneId': 'zone1',\n  'count': '4',\n  'speed': '56'\n});  \n\n\n\n\nGroup By Key\n\n\n\n\n#config.yaml\nwidgets:\n  info:\n    display: list-group\n    type: device\n    keys: zone, count\n    format: count\n    groupby: zone\n    label: Total\n\n\n\n\n//send data through app.js\nmatrix.type('vehicleDetection').send({\n  'zoneId': 'zone1',\n  'count': '4',\n  'speed': '56'\n});  \n\n\n\n\n\n\n\n\n\n\n\npie-chart\n - pie chart\n\n\n\n\n#config.yaml\nwidgets:\n  pieChartTest:\n    display: pie-chart\n    type: gender\n    keys: women,men\n    label: Gender\n\n\n\n\n//send data through app.js\nmatrix.type('gender').send({\n  'women': 76,\n  'men': 45 \n});  \n\n\n\n\n\n\n\n\n\n\n\npolar\n - polar area chart\n\n\n\n\n#config.yaml\nwidgets:\n  polarTest:\n    display: polar\n    type: emotions\n    keys: happy,sad,disgust,surprised,confused,calm,angry\n    label: Emotions\n\n\n\n\n//send data through app.js\nmatrix.type('emotions').send({\n  'happy': 67,\n  'sad': 50,\n  'disgust': 78,\n  'surprised': 56,\n  'confused': 86,\n  'calm': 70,\n  'angry': 60 \n});  \n\n\n\n\n\n\n\n\n\n\n\nlabel\n - string display\n\n\n\n\n#config.yaml\nwidgets:\n  labelTest:\n    display: label\n    type: uv\n    key: risk\n    label: UV Risk\n\n\n\n\n//send data through app.js\nmatrix.type('uv').send({\n  'value': 0.56773,\n  'risk': 'Low' \n});  \n\n\n\n\n\n\n\n\n\n\n\ngauge\n - gauge \n\n\n\n\n#config.yaml\nwidgets:\n  gaugeTest:\n    display: gauge\n    type: detection\n    keys: views\n    min: 0\n    max: 100\n    label: 'Views'\n\n\n\n\n//send data through app.js\nmatrix.type('detection').send({\n  'views': 60,\n  'impressions': 100 \n});  \n\n\n\n\n\n\n\n\n\n\n\nindicator\n -  light indicator on/off\n\n\n\n\n#config.yaml\nwidgets:\n  indicatorTest:\n    display: indicator\n    type: system\n    keys: isOn\n    label: 'Indicator Test'\n\n\n\n\n//send data through app.js\nmatrix.type('system').send({\n  'isOn': true\n});  \n\n\n\n\n\n\n\n\n\n\n\nmap\n - google maps\n\n\n\n\nwidgets:\n  mapTest:\n    display: map\n    type: location\n    label: 'Map Test'\n\n\n\n\n//send data through app.js\nmatrix.type('location').send({\n  'latitude': 25.791632,\n  'longitude': -80.1414447,\n  'label': 'Admobilize'\n});  \n\n\n\n\n\n\n\n\n\n\n\nlink\n - link to a destination (URL)\n\n\n\n\nwidgets:\n  link:\n    display: link\n    label: \nLink display\n\n    title: \nGoogle\n\n    url: \nhttps://www.google.com\n\n\n\n\n\n\n\n\n\nControl Widgets\n\n\nIndicated via a \ncontrol\n option.\n\n\nEach example will show how to configure their respective widget. \nscreens\n and \ndataTypes\n will be left up to you to configure.\n\n\n\n\n\n\n\ninput\n - input field, single or multiple\n\n\nSingle Inputs\n\n\n\n\n#config.yaml\nwidgets:\n  inputTest:\n    control: input\n    event: testInput\n    value: 'type text'\n    label: 'Test Input'\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('testInput', function(p){\n var text = p.value;\n})\n\n\n\n\nMultiple Inputs\n\n\n\n\n#config.yaml\n  inputMapTest:\n    control: input\n    map:\n      - event: testInput1\n        value: first type text\n      - event: testInput2\n        value: second type text\n    label: Test Input Map\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('testInput1', function(p){\n var text = p.value;\n})\n\nmatrix.on('testInput2', function(p){\n var text = p.value;\n})\n\n\n\n\n\n\n\n\n\n\n\nbutton\n - button, single or multiple\n\n\nSingle Buttons\n\n\n\n\n#config.yaml\nwidgets:\n  buttonTest:\n    control: button\n    event: buttonInfo\n    value: Get Secret Information\n    label: Hacking Buttons\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('buttonInfo', function(){\n  // ...\n});\n\n\n\n\nMultiple Buttons\n\n\n\n\n#config.yaml\nwidgets:\n  buttonMapTest:\n    control: button\n    map:\n      - event: buttonUp\n        value: amps+\n      - event: buttonDown\n        value: amps-\n      - event: buttonStart\n        value: begin\n      - event: buttonStop\n        value: end\n      - event: buttonCapture\n        value: capture\n      - event: buttonSlow\n        value: refresh+\n      - event: buttonFast\n        value: refresh-\n    label: Matrix Activation Buttons\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('buttonUp', function(){\n  // ...\n})\n\nmatrix.on('buttonDown', function(){\n  // ...\n})\n\nmatrix.on('buttonStart', function(){\n  // ...\n})\n\nmatrix.on('buttonStop', function(){\n  // ...\n})\n\nmatrix.on('buttonCapture', function(){\n  // ...\n})\n\nmatrix.on('buttonSlow', function(){\n  // ...\n})\n\nmatrix.on('buttonFast', function(){\n  // ...\n})\n\n\n\n\n\n\n\n\n\n\n\nswitch\n - switch, single or multiple\n\n\nSingle Switch\n\n\n\n\n#config.yaml\nwidgets:\n  switchTest:\n    control: switch\n    event: ledEnabledChanged\n    value: Leds enabled\n    label: Switch Test\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('ledEnabledChanged', function(p){\n var isOn = p.value;\n})\n\n\n\n\nMultiple Switches\n\n\n\n\n#config.yaml\nwidgets:\n  switchMapTest:\n    control: switch\n    map:\n      - event: ledEnabledChanged\n        value: Leds enabled\n      - event: detectionEnabledChanged\n        value: Detection Enabled\n    label: Switch Map Test\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('ledEnabledChanged', function(p){\n var isOn = p.value;\n});\n\nmatrix.on('detectionEnabledChanged', function(p){\n var isOn = p.value;\n});\n\n\n\n\n\n\n\n\n\n\n\nradio\n - radio, single or multiple\n\n\n\n\n#config.yaml\nwidgets:\n  radioTest:\n    control: radio\n    map:\n      - event: optionOneSelected\n        value: Option One\n      - event: optionTwoSelected\n        value: Option Two\n    label: Radio Test\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('optionOneSelected', function(p){\n  // ...\n})\n\nmatrix.on('optionTwoSelected', function(p){\n  // ...\n})\n\n\n\n\n\n\n\n\n\n\n\ndropdown\n - dropdown menu\n\n\n\n\n#config.yaml\nwidgets:\n  dropDownTest:\n    control: dropdown\n    map:\n      - event: optionOneSelected\n        value: Option One\n      - event: optionTwoSelected\n        value: Option Two\n    label: Dropdown Test\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('optionOneSelected', function(){\n //...\n})\n\nmatrix.on('optionTwoSelected', function(){\n //...\n})\n\n\n\n\n\n\n\n\n\n\n\nrange\n - range slider\n\n\n\n\n#config.yaml\nwidgets:\n  rangeTest:\n    control: range\n    event: rangeChanged\n    min: 0\n    max: 35\n    label: Range Test\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('rangeChanged', function(p){\n var value = p.value;\n});\n\n\n\n\n\n\n\n\n\n\n\nxy\n - track pad\n\n\n\n\n#config.yaml\nwidgets:\n  xyTest:\n    control: xy\n    event: xyChanging\n    value: 'xy'\n    xMax: 100\n    yMax: 50\n    label: Test XY\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('xyChanging', function(p){\n var x = p.value.x;\n var y = p.value.y;\n});\n\n\n\n\n\n\n\n\n\n\n\nradial\n - joystick, single or multiple\n\n\nSingle Radial\n\n\n\n\n#config.yaml\nwidgets:\n  radial:\n    control: radial\n    event: radialChanging\n    label: Radial Test\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('radialChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n})\n\n\n\n\nMultiple Radials\n\n\n\n\n#config.yam\nwidgets:\n  radialMap:\n    control: radial\n    map:\n    - event: radialRChanging\n      value: right\n    - event: radialLChanging\n      value: left\n    label: Radial Map Test\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('radialRChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n});\n\nmatrix.on('radialLChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n});\n\n\n\n\n\n\n\n\n\n\n\ncolor\n - color picker\n\n\n \n \n\n\n#config.yaml\nwidgets:\n  color:\n    control: color\n    event: colorChange\n    value: 'color'\n    label: 'Change MATRIX color'\n\n\n\n\n//Cross-Talk event from dashboard\nmatrix.on('colorChange', function(color){\n  color = color.value;\n  matrix.led(color).render();\n});", 
            "title": "Widgets"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#widget-configuration", 
            "text": "Each widget requires certain options to be defined before they can properly show on the dashboard. The list below will go through each available option for  widgets .", 
            "title": "Widget Configuration"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#display-widgets", 
            "text": "Indicated via a  display  option.  Each example will show how to configure their respective widget.  screens  and  dataTypes  will be left up to you to configure.    bar  - bar chart   #config.yaml\nwidgets:\n  barChartTest:\n    display: bar\n    type: monitor\n    keys: cpu, memory\n    format: avg\n    realtime: false\n    refresh: 60\n    label: Bar Chart  //send data through app.js\nmatrix.type('monitor').send({\n  'cpu': 7.03,\n  'memory': 2.30 \n});       digit  - numerical   #config.yaml\nwidgets:\n  digitTest:\n    display: digit\n    type: monitor\n    key: cpu\n    format: round\n    label: cpu  //send data through app.js\nmatrix.type('monitor').send({\n  'cpu': 2.4,\n  'memory': 5.4 \n});       radar  - radar chart   #config.yaml\nwidgets:\n  radarTest:\n    display: radar\n    type: emotions\n    keys: happy,sad,disgust,surprised,confused,calm,angry\n    label: Emotions  //send data through app.js\nmatrix.type('emotions').send({\n  'happy': 67,\n  'sad': 50,\n  'disgust': 78,\n  'surprised': 56,\n  'confused': 86,\n  'calm': 70,\n  'angry': 60 \n});       line  - line chart   #config.yaml\nwidgets:\n  lineChartTest:\n    display: line\n    type: monitor\n    format: avg\n    keys: cpu, memory\n    realtime: true\n    label: Line Chart  //send data through app.js\nmatrix.type('monitor').send({\n  'cpu': 7.03,\n  'memory': 2.30 \n});       list  - data table   #config.yaml\nwidgets:\n  listTest:\n    display: list\n    type: device\n    keys: Hostname,Type,Platform,Arch\n    label: Secret Information  //send data through app.js\nmatrix.type('device').send({\n  'Hostname': 'h7n.domain',\n  'Type': 'Darwin',\n  'Platform': 'darwin',\n  'Arch': 'x64'\n});       list-group  - grouped data table  Simple Group   #config.yaml\nwidgets:\n  info:\n    display: list-group\n    type: vehicleDetection\n    keys: count\n    format: count\n    label: Total  //send data through app.js\nmatrix.type('vehicleDetection').send({\n  'zoneId': 'zone1',\n  'count': '4',\n  'speed': '56'\n});    Group By Key   #config.yaml\nwidgets:\n  info:\n    display: list-group\n    type: device\n    keys: zone, count\n    format: count\n    groupby: zone\n    label: Total  //send data through app.js\nmatrix.type('vehicleDetection').send({\n  'zoneId': 'zone1',\n  'count': '4',\n  'speed': '56'\n});       pie-chart  - pie chart   #config.yaml\nwidgets:\n  pieChartTest:\n    display: pie-chart\n    type: gender\n    keys: women,men\n    label: Gender  //send data through app.js\nmatrix.type('gender').send({\n  'women': 76,\n  'men': 45 \n});       polar  - polar area chart   #config.yaml\nwidgets:\n  polarTest:\n    display: polar\n    type: emotions\n    keys: happy,sad,disgust,surprised,confused,calm,angry\n    label: Emotions  //send data through app.js\nmatrix.type('emotions').send({\n  'happy': 67,\n  'sad': 50,\n  'disgust': 78,\n  'surprised': 56,\n  'confused': 86,\n  'calm': 70,\n  'angry': 60 \n});       label  - string display   #config.yaml\nwidgets:\n  labelTest:\n    display: label\n    type: uv\n    key: risk\n    label: UV Risk  //send data through app.js\nmatrix.type('uv').send({\n  'value': 0.56773,\n  'risk': 'Low' \n});       gauge  - gauge    #config.yaml\nwidgets:\n  gaugeTest:\n    display: gauge\n    type: detection\n    keys: views\n    min: 0\n    max: 100\n    label: 'Views'  //send data through app.js\nmatrix.type('detection').send({\n  'views': 60,\n  'impressions': 100 \n});       indicator  -  light indicator on/off   #config.yaml\nwidgets:\n  indicatorTest:\n    display: indicator\n    type: system\n    keys: isOn\n    label: 'Indicator Test'  //send data through app.js\nmatrix.type('system').send({\n  'isOn': true\n});       map  - google maps   widgets:\n  mapTest:\n    display: map\n    type: location\n    label: 'Map Test'  //send data through app.js\nmatrix.type('location').send({\n  'latitude': 25.791632,\n  'longitude': -80.1414447,\n  'label': 'Admobilize'\n});       link  - link to a destination (URL)   widgets:\n  link:\n    display: link\n    label:  Link display \n    title:  Google \n    url:  https://www.google.com", 
            "title": "Display widgets"
        }, 
        {
            "location": "/matrix-os/reference/widgets/#control-widgets", 
            "text": "Indicated via a  control  option.  Each example will show how to configure their respective widget.  screens  and  dataTypes  will be left up to you to configure.    input  - input field, single or multiple  Single Inputs   #config.yaml\nwidgets:\n  inputTest:\n    control: input\n    event: testInput\n    value: 'type text'\n    label: 'Test Input'  //Cross-Talk event from dashboard\nmatrix.on('testInput', function(p){\n var text = p.value;\n})  Multiple Inputs   #config.yaml\n  inputMapTest:\n    control: input\n    map:\n      - event: testInput1\n        value: first type text\n      - event: testInput2\n        value: second type text\n    label: Test Input Map  //Cross-Talk event from dashboard\nmatrix.on('testInput1', function(p){\n var text = p.value;\n})\n\nmatrix.on('testInput2', function(p){\n var text = p.value;\n})     button  - button, single or multiple  Single Buttons   #config.yaml\nwidgets:\n  buttonTest:\n    control: button\n    event: buttonInfo\n    value: Get Secret Information\n    label: Hacking Buttons  //Cross-Talk event from dashboard\nmatrix.on('buttonInfo', function(){\n  // ...\n});  Multiple Buttons   #config.yaml\nwidgets:\n  buttonMapTest:\n    control: button\n    map:\n      - event: buttonUp\n        value: amps+\n      - event: buttonDown\n        value: amps-\n      - event: buttonStart\n        value: begin\n      - event: buttonStop\n        value: end\n      - event: buttonCapture\n        value: capture\n      - event: buttonSlow\n        value: refresh+\n      - event: buttonFast\n        value: refresh-\n    label: Matrix Activation Buttons  //Cross-Talk event from dashboard\nmatrix.on('buttonUp', function(){\n  // ...\n})\n\nmatrix.on('buttonDown', function(){\n  // ...\n})\n\nmatrix.on('buttonStart', function(){\n  // ...\n})\n\nmatrix.on('buttonStop', function(){\n  // ...\n})\n\nmatrix.on('buttonCapture', function(){\n  // ...\n})\n\nmatrix.on('buttonSlow', function(){\n  // ...\n})\n\nmatrix.on('buttonFast', function(){\n  // ...\n})     switch  - switch, single or multiple  Single Switch   #config.yaml\nwidgets:\n  switchTest:\n    control: switch\n    event: ledEnabledChanged\n    value: Leds enabled\n    label: Switch Test  //Cross-Talk event from dashboard\nmatrix.on('ledEnabledChanged', function(p){\n var isOn = p.value;\n})  Multiple Switches   #config.yaml\nwidgets:\n  switchMapTest:\n    control: switch\n    map:\n      - event: ledEnabledChanged\n        value: Leds enabled\n      - event: detectionEnabledChanged\n        value: Detection Enabled\n    label: Switch Map Test  //Cross-Talk event from dashboard\nmatrix.on('ledEnabledChanged', function(p){\n var isOn = p.value;\n});\n\nmatrix.on('detectionEnabledChanged', function(p){\n var isOn = p.value;\n});     radio  - radio, single or multiple   #config.yaml\nwidgets:\n  radioTest:\n    control: radio\n    map:\n      - event: optionOneSelected\n        value: Option One\n      - event: optionTwoSelected\n        value: Option Two\n    label: Radio Test  //Cross-Talk event from dashboard\nmatrix.on('optionOneSelected', function(p){\n  // ...\n})\n\nmatrix.on('optionTwoSelected', function(p){\n  // ...\n})     dropdown  - dropdown menu   #config.yaml\nwidgets:\n  dropDownTest:\n    control: dropdown\n    map:\n      - event: optionOneSelected\n        value: Option One\n      - event: optionTwoSelected\n        value: Option Two\n    label: Dropdown Test  //Cross-Talk event from dashboard\nmatrix.on('optionOneSelected', function(){\n //...\n})\n\nmatrix.on('optionTwoSelected', function(){\n //...\n})     range  - range slider   #config.yaml\nwidgets:\n  rangeTest:\n    control: range\n    event: rangeChanged\n    min: 0\n    max: 35\n    label: Range Test  //Cross-Talk event from dashboard\nmatrix.on('rangeChanged', function(p){\n var value = p.value;\n});     xy  - track pad   #config.yaml\nwidgets:\n  xyTest:\n    control: xy\n    event: xyChanging\n    value: 'xy'\n    xMax: 100\n    yMax: 50\n    label: Test XY  //Cross-Talk event from dashboard\nmatrix.on('xyChanging', function(p){\n var x = p.value.x;\n var y = p.value.y;\n});     radial  - joystick, single or multiple  Single Radial   #config.yaml\nwidgets:\n  radial:\n    control: radial\n    event: radialChanging\n    label: Radial Test  //Cross-Talk event from dashboard\nmatrix.on('radialChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n})  Multiple Radials   #config.yam\nwidgets:\n  radialMap:\n    control: radial\n    map:\n    - event: radialRChanging\n      value: right\n    - event: radialLChanging\n      value: left\n    label: Radial Map Test  //Cross-Talk event from dashboard\nmatrix.on('radialRChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n});\n\nmatrix.on('radialLChanging', function(p){\n var x = p.value.x; //from -1 to 1\n var y = p.value.y; //from -1 to 1\n});     color  - color picker       #config.yaml\nwidgets:\n  color:\n    control: color\n    event: colorChange\n    value: 'color'\n    label: 'Change MATRIX color'  //Cross-Talk event from dashboard\nmatrix.on('colorChange', function(color){\n  color = color.value;\n  matrix.led(color).render();\n});", 
            "title": "Control Widgets"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/", 
            "text": "Cross-Talk\n\n\n\nCross-Talk events allow MATRIX applications to exchange information between different devices, or on the same device. For example, a temperature monitor app can output an event to an alarm app to notify you when the current temperature is too high or low. Cross-Talk events will only be sent to MATRIX devices tied to the same MATRIX Labs account.\n\n\nConfig Setup\n\n\n\n\nYou should have familiarity with \nConfiguration Files\n before exploring further.\n\n\n\n\nCrossTalk requires each event, that will be emitted, in your app's configuration file to execute successfully. This information is also used in the app store to determine which applications can communicate via events.\n\n\nDefining An Event\n\n\n\nAdd the \nevents:\n configuration to your app's config.yaml and give each event your app will emit. Do not add this to an app's configuration if they are only going to listen for events.\n\n\nevents:\n  - flashGreen\n  - highTemperature\n\n\n\n\n\n\nEvent Emitters \n Listeners\n\n\nOnce your app has its events properly defined, you can use \nmatrix.emit\n to broadcast the event to other MATRIX apps and \nmatrix.on\n to receive them.\n\n\n.emit(app, event, payload)\n\n\n\nUse this function in the application that has the events defined in the config.yaml file.\n\n\n\n\nEvents can also be emitted through the MATRIX CLI \nmatrix trigger\n command \nhere\n.\n\n\n\n\n\n\napp\n MATRIX app you're sending the event to.\n\n\nevent\n Event being sent to MATRIX app.\n\n\npayload\n Optional object or string to attach to event being sent.\n\n\n\n\n// Trigger an event in a specific application\nmatrix.emit('app', 'event', payload);\n\n// Example 1\nmatrix.emit('ledControl', 'flashGreen');\n\n// Example 2\nmatrix.emit('alarm', 'highTemperature', {temperature: 80.95899963378906}');\n\n\n\n\n\n.on(event, callback)\n\n\n\nUse this function in the application that will receive the events. Applications that receive events do not need to specify the events in its config.yaml.\n\n\n\n\nevent\n Event to listen on.\n\n\ncallback\n Callback method with payload returned.\n\n\n\n\n// Listen for CrossTalk events sent to this application\nmatrix.on('event', function(payload) {\n  //...\n});\n\n// Example 1\nmatrix.on('flashGreen', function(){\n  //...\n});\n\n// Example 2\nmatrix.on('highTemperature', function(payload){\n  //...\n});\n\n\n\n\n\n\n\nDashboard\n\n\nReceive events from the MATRIX Dashboard by binding them to widget controls.\n\n\n// Interface elements from Dashboards can also trigger CrossTalk events.\nmatrix.on('buttonClick', function(payload) { ... });\n\n\n\n\nSee \nConfiguration \n Widgets\n for the entire list.", 
            "title": "Cross Talk"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#config-setup", 
            "text": "You should have familiarity with  Configuration Files  before exploring further.   CrossTalk requires each event, that will be emitted, in your app's configuration file to execute successfully. This information is also used in the app store to determine which applications can communicate via events.", 
            "title": "Config Setup"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#event-emitters-listeners", 
            "text": "Once your app has its events properly defined, you can use  matrix.emit  to broadcast the event to other MATRIX apps and  matrix.on  to receive them.", 
            "title": "Event Emitters &amp; Listeners"
        }, 
        {
            "location": "/matrix-os/reference/crosstalk/#dashboard", 
            "text": "Receive events from the MATRIX Dashboard by binding them to widget controls.  // Interface elements from Dashboards can also trigger CrossTalk events.\nmatrix.on('buttonClick', function(payload) { ... });  See  Configuration   Widgets  for the entire list.", 
            "title": "Dashboard"
        }, 
        {
            "location": "/matrix-os/reference/data-types/", 
            "text": "Sending Data From MATRIX Devices\n\n\n\n\n\n\n\n\nYou should have familiarity with \nConfiguration Files\n and \nWidgets\n before exploring further.\n\n\n\n\nThe MATRIX Dashboard's \ndisplay widgets\n all require you to define \ndataTypes\n in your \nconfig.yaml\n file. \nwidgets\n can only ready values from defined \ndataTypes\n. Your MATRIX app can push to these values with the \nmatrix.send\n method.\n\n\nData Types\n\n\ndataTypes\n can be thought of as javascript objects. Each data type can contain multiple values known as \nkeys\n. These \nkeys\n can hold the following values.\n\n\n\n\nstring\n - can be defined as: \nstring\n or \nstr\n or \ns\n\n\ninteger\n - can be defined as: \ninteger\n or \nint\n or \ni\n\n\nfloat\n - can be defined as: \nfloat\n or \nfl\n or \nf\n\n\nboolean\n - can be defined as: \nb\n or \nbool\n or \nboolean\n;\n\n\n\n\nCreating Datatypes\n\n\n\nIn order to create your \ndataTypes\n, a \ntype\n needs to be specified. Once created, your \ntype\n needs at least one \nkey\n to be able to hold data.\n\n\n# How to structure\ndataTypes:\n  type1:\n    key1: string or integer or float or boolean\n    key2: string or integer or float or boolean\n  type2:\n    key1: string or integer or float or boolean\n\n\n\n\n# Example\ndataTypes:\n  location:\n    latitude: float\n    longitude: float\n  statusAlert:\n    currentStatus: string\n\n\n\n\n\n\nWe do not currently support changing dataTypes for newer versions of an application. If you need to change \ndataTypes\n after an application is published on the MATRIX App Store, please release a new application until we can address this issue.\n\n\n\n\n\n\nSending Data\n\n\nOnce your \ndataTypes\n are defined, you can begin to send data to the MATRIX Dashboard in real-time. The code below shows an example of how to have your \napp.js\n and \nconfig.yaml\n configured for updating \ndataTypes\n by using \nmatrix.send()\n.\n\n\n# config.yaml\ndataTypes:\n  location:\n    latitude: float\n    longitude: float\n\n\n\n\n// app.js\nmatrix.type('location').send({\n  'latitude': 40.285519,\n  'longitude': -76.650589\n})\n\n\n\n\n\n\nWidgets\n\n\nLearn how to use \nwidgets\n to see how you can use \ndataTypes\n to display real-time information on your MATRIX Dashboard.", 
            "title": "Data Types"
        }, 
        {
            "location": "/matrix-os/reference/data-types/#data-types", 
            "text": "dataTypes  can be thought of as javascript objects. Each data type can contain multiple values known as  keys . These  keys  can hold the following values.   string  - can be defined as:  string  or  str  or  s  integer  - can be defined as:  integer  or  int  or  i  float  - can be defined as:  float  or  fl  or  f  boolean  - can be defined as:  b  or  bool  or  boolean ;", 
            "title": "Data Types"
        }, 
        {
            "location": "/matrix-os/reference/data-types/#sending-data", 
            "text": "Once your  dataTypes  are defined, you can begin to send data to the MATRIX Dashboard in real-time. The code below shows an example of how to have your  app.js  and  config.yaml  configured for updating  dataTypes  by using  matrix.send() .  # config.yaml\ndataTypes:\n  location:\n    latitude: float\n    longitude: float  // app.js\nmatrix.type('location').send({\n  'latitude': 40.285519,\n  'longitude': -76.650589\n})", 
            "title": "Sending Data"
        }, 
        {
            "location": "/matrix-os/reference/data-types/#widgets", 
            "text": "Learn how to use  widgets  to see how you can use  dataTypes  to display real-time information on your MATRIX Dashboard.", 
            "title": "Widgets"
        }, 
        {
            "location": "/matrix-os/reference/system/", 
            "text": "System Methods\n\n\n\nSeveral methods are available for common computing use cases, like saving application variables, storing files or local database. These will be localized to the device and are not available across all instances of the application.\n\n\n\n\nSettings\n\n\nWhen an application requires a variable which should be user provided or will change between different instances, settings is a way to approach this problem.\n\n\nConfig Setup\n\n\n\n\n\nYou should have familiarity with \nConfiguration Files\n before exploring further.\n\n\n\n\nAdd the \nsettings:\n configuration to your app's config.yaml and specify each setting your app will save.\n\n\nsettings:\n  apiKey: 'dfe972dc'\n  secretKey: 'ea9e2dab'\n\n\n\n\nEvery key in settings is exposed on the root \nmatrix\n object. For example, \nsettings.apiKey\n is accessible in your MATRIX app as \nmatrix.apiKey\n.\n\n\nconsole.log(matrix.apiKey);// prints your apiKey setting\n\n\n\n\nDynamically Changing Settings from an application\n\n\n\n\n\nCurrently, the setting will only be overwritten after the MATRIX app restarts.\n\n\n\n\nmatrix.set({ apiKey: '3c3cce95' });// Overrides matrix.apiKey\nmatrix.set({ secretKey: '08937cef' });// Overrides matrix.apiKey\n\n\n\n\n\n\n\n\n\nLocal Database\n\n\nMATRIX OS provides a local, file-based key-value store for app usage. This storage is globally accessible to any application installed on the same device. \n\n\n\n\nIt is not recommended to set end user specific configurations here. use \nsettings\n instead.\n\n\n\n\nSet\n\n\n\nDefines the name of the a \nkey\n and the \nvalue\n it'll hold in the local database.\n\n\nmatrix.store.set(key, value, function(){\n  //...\n});\n\n\n\n\nGet\n\n\n\nObtains the \nvalue\n of a stored \nkey\n in the local database. The value is passed to the \ncallback\n.\n\n\nmatrix.store.get(key, function(error, value){\n  console.log(value);// prints key value\n});\n\n\n\n\nDelete\n\n\n\nRemove a stored \nkey\n from the local database.\n\n\nmatrix.store.delete(key, function(){\n  //...\n});\n\n\n\n\n\n\nFile Storage\n\n\nMATRIX applications utilize a local file storage for storing files. This enables MATRIX applications to dynamically download content that was not initially packaged with the app.\n\n\nSave\n\n\n\nDownloads and stores a file specified through a URL.\n\n\n\n\nurl\n publicly accessible url.\n\n\nfilename\n name of the file being saved.\n\n\ncallback\n function to call when save is complete.\n\n\n\n\nmatrix.file.save(url, filename, function(){\n  //..\n});\n\n\n\n\nLoad\n\n\n\nLoad the buffer of a file you saved.\n\n\n\n\nfilename\n file to load.\n\n\ncallback\n function to call after file is read\n\n\n\n\nmatrix.file.load(filename, function(error, data){\n  console.log(data);// prints buffer of loaded file\n});\n\n\n\n\nList\n\n\n\nSee all currently stored files in application.\n\n\n\n\ncallback\n function to call after files are counted\n\n\n\n\nmatrix.file.list(function(error, files){\n  console.log(files);// prints array of downloaded files\n})\n\n\n\n\nRemove\n\n\n\n\n\nfilename\n file to remove from application storage\n\n\ncallback\n function to call when remove is complete\n\n\n\n\nmatrix.file.remove(filename, function(){\n  //..\n});", 
            "title": "System Methods"
        }, 
        {
            "location": "/matrix-os/reference/system/#settings", 
            "text": "When an application requires a variable which should be user provided or will change between different instances, settings is a way to approach this problem.", 
            "title": "Settings"
        }, 
        {
            "location": "/matrix-os/reference/system/#local-database", 
            "text": "MATRIX OS provides a local, file-based key-value store for app usage. This storage is globally accessible to any application installed on the same device.    It is not recommended to set end user specific configurations here. use  settings  instead.", 
            "title": "Local Database"
        }, 
        {
            "location": "/matrix-os/reference/system/#file-storage", 
            "text": "MATRIX applications utilize a local file storage for storing files. This enables MATRIX applications to dynamically download content that was not initially packaged with the app.", 
            "title": "File Storage"
        }, 
        {
            "location": "/matrix-os/examples/", 
            "text": "Examples\n\n\n\n\n\nDashboard\n\n\n\nCreate a Dashboard for exploring data.", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-os/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/", 
            "text": "Creating a Dashboard\n\n\n\n\n\nIn this example we will demonstrate how to make a MATRIX Dashboard that can read and send data from your MATRIX device. The final result will your MATRIX device flickering its LEDs green and sending a random number to the dashboard, once the user presses a button.\n\n\n\n\nYou should have familiarity with \nData Types\n, \nCross Talk\n, \nDashboard\n, and the \nGetting Started\n section before exploring further. \n\n\n\n\nSetting Up Your Application\n\n\nCreate Your App\n\nWith the, MATRIX CLI tool installed, go to the terminal on your personal computer and insert the following command.\n\n\nmatrix create exampleDashboard\n\n\n\n\nConfig.yaml\n\n\n\nWe will be setting up the app's \nconfig.yaml\n page in order to define the layout of our dashboard, dataTypes, and events.\n\n\n\n\n\n\ndatatypes\n - Will define the variable that will save the random number we create.\n\n\n\n\n\n\nscreens\n - Determines the placement of widgets.\n\n\n\n\n\n\nwidgets\n - Our two dashboard components to visualize the random number we generate and command our MATRIX device to make that number.\n\n\n\n\n\n\nEvents\n - Events doesn't have to be specified here because we are not sending one from our app, but receiving it from the \nstartButton\n widget we made. View \nCross Talk\n to learn more.\n\n\n\n\n\n\nconfigVersion: 2\n\ndescription: 'Example dashboard to learn from.'\nkeywords: dashboard example\nname: exampleDashboard\nshortName: exampleDashboard\ndisplayName: Example Dashboard\n\ndataTypes:\n  #Holds the value shown on the dashboard\n  randomNumber:\n    number: integer\n\nscreens:\n#This will show both widgets in the same Row\n- - numberGenerator\n  - startButton\n\nwidgets:\n  #Displays a randomly generated number\n  numberGenerator:\n    display: digit\n    type: randomNumber\n    key: number\n    label: Random Number\n  #Calls number generator\n  startButton:\n    control: button\n    event: generateNumber\n    value: Get Random Number\n    label: Start Number Generator\n\n\n\n\n\n\nWriting Your Application\n\n\nThe following code below goes into your application's \napp.js\n file. The code can be split into two parts. The first is a simple function to turn on and off your MATRIX device's LEDs. The second part waits for the dashboard \ngenerateNumber\n event from the \nstartButton\n widget. Once the event goes off, the previous function is called and a random number is created and sent to the dashboard's \nnumberGenerator\n widget.\n\n\n// - Turn LEDs on and then off\nfunction flickerLights(color){\n    matrix.led(color).render();// Turn LEDs green\n    // Wait 1 second\n    setTimeout(function(){\n        matrix.led('black').render();// Turn LEDs off\n    },500);\n}\n\n// - On Dashboard Button Press\nmatrix.on('generateNumber', function(){\n    flickerLights('green');// Flicker MATRIX Device LEDs\n\n    var randomNumber = Math.floor(Math.random()*100);// Generate a random number between 0 and 99\n    // Send Number To Dashboard\n    matrix.type('randomNumber').send({\n        'number': randomNumber\n    });\n});\n\n\n\n\n\n\nDeploying Your Application\n\n\nYou application should now be ready to deploy. Use the following command, with the location of your app folder, to send the app to your MATRIX device.\n\n\nmatrix deploy PATH_TO_YOUR_APP_HERE\n\n\n\n\nAfter it's deployed, you can start the app with the final command below.\n\n\nmatrix start exampleDashboard\n\n\n\n\nFinal Result\n\n\n\nVisit the \nMATRIX Dashboard\n to see the example you've deployed. Use the \"Get Random Number Button\" to test the number generator and LEDs flashing. \n\n\n\nAlternatively, you can use the following command if you want to test sending a Cross Talk command through the MATRIX CLI tool.\n\n\nmatrix trigger generateNumber", 
            "title": "Dashboard"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#setting-up-your-application", 
            "text": "", 
            "title": "Setting Up Your Application"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#writing-your-application", 
            "text": "The following code below goes into your application's  app.js  file. The code can be split into two parts. The first is a simple function to turn on and off your MATRIX device's LEDs. The second part waits for the dashboard  generateNumber  event from the  startButton  widget. Once the event goes off, the previous function is called and a random number is created and sent to the dashboard's  numberGenerator  widget.  // - Turn LEDs on and then off\nfunction flickerLights(color){\n    matrix.led(color).render();// Turn LEDs green\n    // Wait 1 second\n    setTimeout(function(){\n        matrix.led('black').render();// Turn LEDs off\n    },500);\n}\n\n// - On Dashboard Button Press\nmatrix.on('generateNumber', function(){\n    flickerLights('green');// Flicker MATRIX Device LEDs\n\n    var randomNumber = Math.floor(Math.random()*100);// Generate a random number between 0 and 99\n    // Send Number To Dashboard\n    matrix.type('randomNumber').send({\n        'number': randomNumber\n    });\n});", 
            "title": "Writing Your Application"
        }, 
        {
            "location": "/matrix-os/examples/dash-create/#deploying-your-application", 
            "text": "You application should now be ready to deploy. Use the following command, with the location of your app folder, to send the app to your MATRIX device.  matrix deploy PATH_TO_YOUR_APP_HERE  After it's deployed, you can start the app with the final command below.  matrix start exampleDashboard", 
            "title": "Deploying Your Application"
        }, 
        {
            "location": "/matrix-os/troubleshooting/", 
            "text": "Troubleshooting\n\n\n\n\n\nCommunity\n\n\nPlease visit our community support forums at:\n\ncommunity.matrix.one\n\n\n\n\nMOS DEBUG Mode\n\n\nRun MOS, with the following command, in order to enable debug mode.\n\n\nDEBUG=*,-engine*,-Component* node index", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-os/troubleshooting/#community", 
            "text": "Please visit our community support forums at: community.matrix.one", 
            "title": "Community"
        }, 
        {
            "location": "/matrix-os/troubleshooting/#mos-debug-mode", 
            "text": "Run MOS, with the following command, in order to enable debug mode.  DEBUG=*,-engine*,-Component* node index", 
            "title": "MOS DEBUG Mode"
        }, 
        {
            "location": "/matrix-core/", 
            "text": "MATRIX CORE\n\n\nMATRIX CORE provides \nProtobufs\n over \nZeroMQ\n. An intended target for this layer is \nMATRIX Open System\n. You can also use CORE to query sensors and control any MATRIX Device from any language that supports protocol buffers (version 3.X) and 0MQ. \n\n\nConnections to CORE can be made both from localhost (127.0.0.1) and from remote computers that are in the same network.\n\n\nSpecification\n\n\nOur \nProtocol Buffer Specifications\n are currently defined in \nproto\n files. Please use these files to inform your ZMQ payloads. More information can be found in the examples below.\n\n\nInstallation\n\n\nSee \nInstallation\n\n\nExamples\n\n\n\n\nSee \nJavascript Test Example\n\n\nSee \nPython Test Example\n\n\n\n\nProtocol\n\n\nAll the CORE drivers use the same protocol to interact with other programs. Drivers allow read-only,\nwrite-only or read-write modes.\n\n\nCORE uses 0MQ to transfer information from and to the client interfacing with it. Each CORE driver has a base 0MQ port.\nThis is the current list of base ports (This is printed by CORE when it is started from the console):\n\n\nRegistered driver IMU with port 20013.\nRegistered driver Humidity with port 20017.\nRegistered driver Everloop with port 20021.\nRegistered driver Pressure with port 20025.\nRegistered driver UV with port 20029.\nRegistered driver ZigbeeBulb with port 20033.\nRegistered driver MicArray_Alsa with port 20037.\nRegistered driver Lirc with port 20041.\n\n\n\n\nEach port reserves a range of 4 ports that are used for a driver. They are described in the following sections.\n\n\nBase port\n\n\nThis is the first port of the driver and the one used to denote the \ndriver port\n.\nIt is used to configure the device and it makes sense for the devices that support configuration.\nIt is a 0MQ PULL port.\nTo send a configuration you need to send a valid message (serialized to a string) for the given driver. For instance, the\nEverloop driver (LED array) uses a configuration message to set the LEDs.\n\n\nThe message is named EverloopImage and it is in the file \ndriver.proto\n.\nThe message follows:\n\n\nmessage LedValue {\n  uint32 red = 1;\n  uint32 green = 2;\n  uint32 blue = 3;\n  uint32 white = 4;\n}\n\n// The led array.\nmessage EverloopImage {\n  repeated LedValue led = 1;\n}\n\n\n\n\nIn order to turn all the LEDs RED you need to add 35 messages of type LedValue to the EverloopImage message.\nEach of the LedValue messages would need to have the following values:\n\n\n\n\nred: 10\n\n\ngreen: 0\n\n\nblue: 0\n\n\nwhite: 0\n\n\n\n\nThe valid values for led intensities range from 0 to 255, but we set red to 10 because this value is bright enough.\n\n\nOnce the message of type Everloop Image is filled out it needs to be serialized as a string and sent to the 0MQ configuration port.\n\n\nIf invalid values are used for the LED values of the number of LED values inside of EverloopImage is not 35 the configuration will be discarded and an error message will be generated and sent to the error channel described below.\n\n\nError port\n\n\nPrograms can subscribe to the 0MQ error port. It is a PUSH port. The port number is obtained by adding 2 to the base port (Also known as driver port).\nThe errors are returned as strings but there's a pending task to change the error messages to a protocol buffer \n(track issue)\n.\nPlease do not depend on errors reported as strings as we will change the errors to protocol buffers soon.\n\n\nKeep-alive port\n\n\nThe port number is obtained by adding 1 to the base port (Also known as driver port). It is a PUSH port.\n\n\nIn order to save CPU power and other resources some drivers require applications to send pings to it in order to keep them alive.\nFor most driveres it means that the driver keeps sending updates as fast as they have been configured to do so.\nThe Everloop driver doesn't require keep-alive messages. The IMU driver does.\n\n\nDrivers that need keep-alive messages can be configured using the message that is used for all the configurations.\nThe way to do it is set relevant field while doing other driver specific configuration (if this is required).\n\n\nmessage DriverConfig {\n  // Delay between updates. In seconds.\n  float delay_between_updates = 1;\n  // Timeout after last ping.\n  float timeout_after_last_ping = 2;\n\n  // More fields here -- Omitted.\n}\n\n\n\n\nThe field timeout_after_last_ping defaults to 5 seconds and it can be set during driver configuration.\nIf a driver doesn't receive Clive messages after \ntimeout_after_last_ping\n seconds  it will stop sending updates.\nThis field is ignored by drivers that do not require keep alive messages. For instance, the Everloop driver ignores this setting.\n\n\nAfter the setting is done (or not if the default value of 5 seconds is OK) you can start sending keepalive messages to the\ndriver by sending messages to the respective 0MQ port. Any message that is sent to this port will be discarded, so the\nempty string \"\" makes for a good keep-alive message.\n\n\nData update port\n\n\nThe port number is obtained by adding 3 to the base port (Also known as driver port). This port is used by drivers that\nsend data (for instance Humidity and UV). Each driver uses a different message to report data to programs that subscribe\nexpecting updates.\n\n\nLet's use the UV driver as an example. The relevant message:\n\n\n// Basic UV radiation lecture.\nmessage UV{\n  // UV index.\n  float uv_index = 1;\n\n  // Risk of harm from unprotected sun exposure, for the average adult.\n  // According to the OMS table. https://www.epa.gov/sunsafety/uv-index-scale-0\n  string oms_risk = 2;\n}\n\n\n\n\nDrivers that subscribe to updates via 0MQ will receive a string with serialized messages of type UV (within the matrix_malos namespace).\nThen this message needs to be deserialized and the values can be used.\n\n\nWorkflow\n\n\nWrapping up the protocol section, a program that talks to CORE can:\n\n\n\n\nConfigure a driver if needed. Or configure it many times if the drivers needs it.\n\n\nSubscribe to error messages if it is interested in them.\n\n\nSends keep-alive messages if those are needed by the driver to remain active.\n\n\nSubscribe to updates from the driver if the drivers produces them.\n\n\n\n\nInterfaces\n\n\n\n\nEverloop\n\n\nHumidity\n\n\nIMU\n\n\n\n\nPressure\n\n\nUV\n\n\nGPIO\n\n\n\n\nExamples\n\n\nNote:\n pre-requisite is NodeJS. Don't use the one shipped with Raspbian because it's a bit old. If you don't have it, please check a recipe included below.\n\n\ngit clone https://github.com/matrix-io/matrix-creator-malos.git \n cd matrix-creator-malos\ngit submodule init \n git submodule update\ncd src/js_test\n\n// humidity, temperature\nnode test_humidity.js \n\n// inertial measurement unit\nnode test_imu.js \n\n// pressure, altitude\nnode test_pressure.js \n\n// uv index, uv range\nnode test_uv.js\n\n\n\n\n\n\nHistory\n\n\nMATRIX CORE was previously packaged as MALOS and MALOS EYE.", 
            "title": "MATRIX CORE"
        }, 
        {
            "location": "/matrix-core/#matrix-core", 
            "text": "MATRIX CORE provides  Protobufs  over  ZeroMQ . An intended target for this layer is  MATRIX Open System . You can also use CORE to query sensors and control any MATRIX Device from any language that supports protocol buffers (version 3.X) and 0MQ.   Connections to CORE can be made both from localhost (127.0.0.1) and from remote computers that are in the same network.", 
            "title": "MATRIX CORE"
        }, 
        {
            "location": "/matrix-core/#specification", 
            "text": "Our  Protocol Buffer Specifications  are currently defined in  proto  files. Please use these files to inform your ZMQ payloads. More information can be found in the examples below.", 
            "title": "Specification"
        }, 
        {
            "location": "/matrix-core/#installation", 
            "text": "See  Installation", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-core/#examples", 
            "text": "See  Javascript Test Example  See  Python Test Example", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-core/#protocol", 
            "text": "All the CORE drivers use the same protocol to interact with other programs. Drivers allow read-only,\nwrite-only or read-write modes.  CORE uses 0MQ to transfer information from and to the client interfacing with it. Each CORE driver has a base 0MQ port.\nThis is the current list of base ports (This is printed by CORE when it is started from the console):  Registered driver IMU with port 20013.\nRegistered driver Humidity with port 20017.\nRegistered driver Everloop with port 20021.\nRegistered driver Pressure with port 20025.\nRegistered driver UV with port 20029.\nRegistered driver ZigbeeBulb with port 20033.\nRegistered driver MicArray_Alsa with port 20037.\nRegistered driver Lirc with port 20041.  Each port reserves a range of 4 ports that are used for a driver. They are described in the following sections.", 
            "title": "Protocol"
        }, 
        {
            "location": "/matrix-core/#base-port", 
            "text": "This is the first port of the driver and the one used to denote the  driver port .\nIt is used to configure the device and it makes sense for the devices that support configuration.\nIt is a 0MQ PULL port.\nTo send a configuration you need to send a valid message (serialized to a string) for the given driver. For instance, the\nEverloop driver (LED array) uses a configuration message to set the LEDs.  The message is named EverloopImage and it is in the file  driver.proto .\nThe message follows:  message LedValue {\n  uint32 red = 1;\n  uint32 green = 2;\n  uint32 blue = 3;\n  uint32 white = 4;\n}\n\n// The led array.\nmessage EverloopImage {\n  repeated LedValue led = 1;\n}  In order to turn all the LEDs RED you need to add 35 messages of type LedValue to the EverloopImage message.\nEach of the LedValue messages would need to have the following values:   red: 10  green: 0  blue: 0  white: 0   The valid values for led intensities range from 0 to 255, but we set red to 10 because this value is bright enough.  Once the message of type Everloop Image is filled out it needs to be serialized as a string and sent to the 0MQ configuration port.  If invalid values are used for the LED values of the number of LED values inside of EverloopImage is not 35 the configuration will be discarded and an error message will be generated and sent to the error channel described below.", 
            "title": "Base port"
        }, 
        {
            "location": "/matrix-core/#error-port", 
            "text": "Programs can subscribe to the 0MQ error port. It is a PUSH port. The port number is obtained by adding 2 to the base port (Also known as driver port).\nThe errors are returned as strings but there's a pending task to change the error messages to a protocol buffer  (track issue) .\nPlease do not depend on errors reported as strings as we will change the errors to protocol buffers soon.", 
            "title": "Error port"
        }, 
        {
            "location": "/matrix-core/#keep-alive-port", 
            "text": "The port number is obtained by adding 1 to the base port (Also known as driver port). It is a PUSH port.  In order to save CPU power and other resources some drivers require applications to send pings to it in order to keep them alive.\nFor most driveres it means that the driver keeps sending updates as fast as they have been configured to do so.\nThe Everloop driver doesn't require keep-alive messages. The IMU driver does.  Drivers that need keep-alive messages can be configured using the message that is used for all the configurations.\nThe way to do it is set relevant field while doing other driver specific configuration (if this is required).  message DriverConfig {\n  // Delay between updates. In seconds.\n  float delay_between_updates = 1;\n  // Timeout after last ping.\n  float timeout_after_last_ping = 2;\n\n  // More fields here -- Omitted.\n}  The field timeout_after_last_ping defaults to 5 seconds and it can be set during driver configuration.\nIf a driver doesn't receive Clive messages after  timeout_after_last_ping  seconds  it will stop sending updates.\nThis field is ignored by drivers that do not require keep alive messages. For instance, the Everloop driver ignores this setting.  After the setting is done (or not if the default value of 5 seconds is OK) you can start sending keepalive messages to the\ndriver by sending messages to the respective 0MQ port. Any message that is sent to this port will be discarded, so the\nempty string \"\" makes for a good keep-alive message.", 
            "title": "Keep-alive port"
        }, 
        {
            "location": "/matrix-core/#data-update-port", 
            "text": "The port number is obtained by adding 3 to the base port (Also known as driver port). This port is used by drivers that\nsend data (for instance Humidity and UV). Each driver uses a different message to report data to programs that subscribe\nexpecting updates.  Let's use the UV driver as an example. The relevant message:  // Basic UV radiation lecture.\nmessage UV{\n  // UV index.\n  float uv_index = 1;\n\n  // Risk of harm from unprotected sun exposure, for the average adult.\n  // According to the OMS table. https://www.epa.gov/sunsafety/uv-index-scale-0\n  string oms_risk = 2;\n}  Drivers that subscribe to updates via 0MQ will receive a string with serialized messages of type UV (within the matrix_malos namespace).\nThen this message needs to be deserialized and the values can be used.", 
            "title": "Data update port"
        }, 
        {
            "location": "/matrix-core/#workflow", 
            "text": "Wrapping up the protocol section, a program that talks to CORE can:   Configure a driver if needed. Or configure it many times if the drivers needs it.  Subscribe to error messages if it is interested in them.  Sends keep-alive messages if those are needed by the driver to remain active.  Subscribe to updates from the driver if the drivers produces them.", 
            "title": "Workflow"
        }, 
        {
            "location": "/matrix-core/#interfaces", 
            "text": "Everloop  Humidity  IMU   Pressure  UV  GPIO", 
            "title": "Interfaces"
        }, 
        {
            "location": "/matrix-core/#examples_1", 
            "text": "Note:  pre-requisite is NodeJS. Don't use the one shipped with Raspbian because it's a bit old. If you don't have it, please check a recipe included below.  git clone https://github.com/matrix-io/matrix-creator-malos.git   cd matrix-creator-malos\ngit submodule init   git submodule update\ncd src/js_test\n\n// humidity, temperature\nnode test_humidity.js \n\n// inertial measurement unit\nnode test_imu.js \n\n// pressure, altitude\nnode test_pressure.js \n\n// uv index, uv range\nnode test_uv.js", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-core/#history", 
            "text": "MATRIX CORE was previously packaged as MALOS and MALOS EYE.", 
            "title": "History"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/", 
            "text": "Prerequisites\n\n\nHardware\n\n\n\n\nRaspberry Pi with MATRIX Creator\n\n\nSD Card with \nMATRIX CORE installed\n\n\n\n\nDevelopment Prerequisites\n\n\n\n\nLanguage \nsupported by ZeroMQ\n\n\nProtocol Buffers\n\n\n\n\nContinue\n\n\n\n\nGet your Pi ready at \ninstallation\n.\n\n\nDo \nHello World\n\n\nTry \nJavaScript\n or \nPython\n tests.\n\n\nWrite and run your own CORE-enabled software by using our \nReference\n documentation.", 
            "title": "Prerequisities"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/#prerequisites", 
            "text": "", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/#hardware", 
            "text": "Raspberry Pi with MATRIX Creator  SD Card with  MATRIX CORE installed", 
            "title": "Hardware"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/#development-prerequisites", 
            "text": "Language  supported by ZeroMQ  Protocol Buffers", 
            "title": "Development Prerequisites"
        }, 
        {
            "location": "/matrix-core/getting-started/prerequisites/#continue", 
            "text": "Get your Pi ready at  installation .  Do  Hello World  Try  JavaScript  or  Python  tests.  Write and run your own CORE-enabled software by using our  Reference  documentation.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/", 
            "text": "Installation\n\n\n# Add rep and key\ncurl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add -\necho \ndeb https://apt.matrix.one/raspbian $(lsb_release -sc) main\n | sudo tee /etc/apt/sources.list.d/matrixlabs.list\n# update \n upgrade\nsudo apt-get update;\nsudo apt-get upgrade;\n# install malos package\nsudo apt-get install matrixio-malos\n# reboot\nsudo reboot\n\n\n\n\nCORE should be running on next boot.\n\n\nUpgrades\n\n\nIf you need to upgrade your MATRIX CORE package at any time, please run the following commands and restart.\n\n\nsudo apt-get update;\nsudo apt-get upgrade;\nsudo shutdown -r now;\n\n\n\n\nStart / Stop manually\n\n\nCORE runs as a service after boot. If you need to stop it use:\n\n\nsudo pkill -9 malos\n\n\n\n\nTo manually run it back again use:\n\n\nmalos \n\n\n\n\n\nThe output will be similar to:\n\n\npi@raspberrypi:~ $ malos \n\n[1] 24343\npi@raspberrypi:~ $ **************\nMALOS starting\n**************\n\nYou can query specific driver info using port 20012.\nRegistered driver IMU with port 20013.\nRegistered driver Humidity with port 20017.\nRegistered driver Everloop with port 20021.\nRegistered driver Pressure with port 20025.\nRegistered driver UV with port 20029.\nRegistered driver MicArray_Alsa with port 20037.\nRegistered driver Servo with port 20045.\nRegistered driver Gpio with port 20049.\n\npi@raspberrypi:~ $\n\n\n\n\nContinue\n\n\n\n\nDo \nHello World\n\n\nTry \nJavaScript\n or \nPython\n tests.\n\n\nWrite and run your own CORE-enabled software by using our \nReference\n documentation.", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/#installation", 
            "text": "# Add rep and key\ncurl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add -\necho  deb https://apt.matrix.one/raspbian $(lsb_release -sc) main  | sudo tee /etc/apt/sources.list.d/matrixlabs.list\n# update   upgrade\nsudo apt-get update;\nsudo apt-get upgrade;\n# install malos package\nsudo apt-get install matrixio-malos\n# reboot\nsudo reboot  CORE should be running on next boot.", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/#upgrades", 
            "text": "If you need to upgrade your MATRIX CORE package at any time, please run the following commands and restart.  sudo apt-get update;\nsudo apt-get upgrade;\nsudo shutdown -r now;", 
            "title": "Upgrades"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/#start-stop-manually", 
            "text": "CORE runs as a service after boot. If you need to stop it use:  sudo pkill -9 malos  To manually run it back again use:  malos    The output will be similar to:  pi@raspberrypi:~ $ malos  \n[1] 24343\npi@raspberrypi:~ $ **************\nMALOS starting\n**************\n\nYou can query specific driver info using port 20012.\nRegistered driver IMU with port 20013.\nRegistered driver Humidity with port 20017.\nRegistered driver Everloop with port 20021.\nRegistered driver Pressure with port 20025.\nRegistered driver UV with port 20029.\nRegistered driver MicArray_Alsa with port 20037.\nRegistered driver Servo with port 20045.\nRegistered driver Gpio with port 20049.\n\npi@raspberrypi:~ $", 
            "title": "Start / Stop manually"
        }, 
        {
            "location": "/matrix-core/getting-started/installation/#continue", 
            "text": "Do  Hello World  Try  JavaScript  or  Python  tests.  Write and run your own CORE-enabled software by using our  Reference  documentation.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/", 
            "text": "Download and Prepare\n\n\n\n\nYou need \nNodeJS, and the Node Package Manager (npm)\n installed on the Raspberry Pi.\n\n\n\n\ngit clone https://github.com/matrix-io/matrix-creator-malos\ncd matrix-creator-malos\ncd src/js_test\nnpm install\n\n\n\n\nExamples\n\n\nMATRIX CORE is the program that sits between the low level hardware layer and MATRIX OS. This program allows MATRIX OS to access the board hardware via ZeroMQ sockets. You can also use it directly, as it is done with the examples below. The The IPs used in the examples are 127.0.0.1. Remember to edit them if you're accessing the Creator from another host and not from the Raspberry itself.\n\n\nDrivers\n\n\nnode test_driver_info.js\n\n\n\n\nContinue\n\n\n\n\nTry the rest of the \nJavaScript\n or \nPython\n tests.\n\n\nWrite and run your own CORE-enabled software by using our \nReference\n documentation.", 
            "title": "Hello World"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/#download-and-prepare", 
            "text": "You need  NodeJS, and the Node Package Manager (npm)  installed on the Raspberry Pi.   git clone https://github.com/matrix-io/matrix-creator-malos\ncd matrix-creator-malos\ncd src/js_test\nnpm install", 
            "title": "Download and Prepare"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/#examples", 
            "text": "MATRIX CORE is the program that sits between the low level hardware layer and MATRIX OS. This program allows MATRIX OS to access the board hardware via ZeroMQ sockets. You can also use it directly, as it is done with the examples below. The The IPs used in the examples are 127.0.0.1. Remember to edit them if you're accessing the Creator from another host and not from the Raspberry itself.", 
            "title": "Examples"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/#drivers", 
            "text": "node test_driver_info.js", 
            "title": "Drivers"
        }, 
        {
            "location": "/matrix-core/getting-started/hello-world/#continue", 
            "text": "Try the rest of the  JavaScript  or  Python  tests.  Write and run your own CORE-enabled software by using our  Reference  documentation.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-core/getting-started/next-steps/", 
            "text": "Next Steps\n\n\nShare your creation\n\n\nShow us know what you've made and we'll share it to our channels! \n\n\n\n\nMATRIX Community\n\n\nTutorials/Projects Pages\n\n\nVideos\n\n\nMATRIX Twitter", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-core/getting-started/next-steps/#next-steps", 
            "text": "", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-core/getting-started/next-steps/#share-your-creation", 
            "text": "Show us know what you've made and we'll share it to our channels!    MATRIX Community  Tutorials/Projects Pages  Videos  MATRIX Twitter", 
            "title": "Share your creation"
        }, 
        {
            "location": "/matrix-core/examples/pytests/", 
            "text": "Python Examples\n\n\nPrerequisites\n\n\nAfter sucessfully installing \nMATRIX Core\n in your Rapsberry Pi, clone matrix-creator-malos repository that contains Python examples:\n\n\ncd ~/\ngit clone https://github.com/matrix-io/matrix-creator-malos.git\n\n\n\n\nInstall Python packages\n\n\nInstall the following python packages dependencies:\n\n\nsudo apt-get install build-essential python-dev\npip install -r requirements.txt\n\n\n\n\nIf you're using \npipenv\n, then also install:\n\n\npipenv install\n\n\n\n\nTest GPIO\n\n\nIn this example the PIN 15 (in the MATRIX board external GPIOs) is set up in output mode and is then toggled with \n0\n and \n1\n.\n\n\ncd ~/matrix-creator-malos/src/python_test\npython test_gpio.py\n\n\n\n\nthe output should be:\n\n\n$ python test_gpio.py\nGPIO15=0\nGPIO15=1\nGPIO15=0\n\n\n\n\n\nWhen using \npipenv\n use this instead:\n\n\n$ pipenv run python test_gpio.py\n\n\n\n\nPython Test Files\n\n\nDriver_info\n\n\npython test_driver_info.py\n\n\n\n\nEverloop\n\n\npython test_everloop.py\n\n\n\n\nEverloop color\n\n\npython test_set_everloop_color.py\n\n\n\n\nGPIO\n\n\npython test_gpio.py\n\n\n\n\nGPIO Read \n Write\n\n\npython test_gpio_read_write.py\n\n\n\n\nHumidity\n\n\npython test_humidity.py\n\n\n\n\nImu\n\n\npython test_imu.py\n\n\n\n\nIR\n\n\npython test_ir_remote.py\n\n\n\n\nPressure\n\n\npython test_pressure.py\n\n\n\n\nServo\n\n\npython test_servo.py\n\n\n\n\nUV\n\n\npython test_uv.py\n\n\n\n\nGPIO python example\n\n\nOn this example, we will connect to CORE GPIO driver for controlling a single pin. GPIO driver on MATRIX creator supports:\n\n\n\n\nGPIO pin input\n\n\nGPIO pin output\n\n\nGPIO updates (state from all pins)\n\n\n\n\nThe CORE driver follows the \nCORE protocol\n.\n\n\n\n\nGPIO Example details\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n because we are connecting from the local host. It will be your creator's IP address if you wish to run the python samples from a different computer, in such case you can \nexport CREATOR_IP=\nip\n variable, and the samples will connect to the specified host.\n\n\nWe also set the base port for the CORE Pressure driver (20013).\n\n\nimport zmq\nimport time\nimport driver_pb2 as driver_proto # proto buffer precompiled\n\n# Either local host or the value you set in env var\ncreator_ip = os.environ.get('CREATOR_IP', '127.0.0.1')\ncreator_gpio_base_port = 20013 + 36\n\n# connection to device\ncontext = zmq.Context()\nsocket = context.socket(zmq.PUSH)\nsocket.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port))\n\n# instance for config driver message\nconfig = driver_proto.DriverConfig()\nconfig.gpio.pin = 15  # pin on board\nconfig.gpio.mode = driver_proto.GpioParams.OUTPUT # pin mode OUTPUT/INPUT\n\nwhile True:\n    config.gpio.value ^= 1 # toggle value\n    print ('GPIO'+str(config.gpio.pin)+'='+str(config.gpio.value))\n    socket.send(config.SerializeToString()) # send proto message\n    time.sleep(1)\n\n\n\n\nAdvanced sample\n\n\nMATRIX CORE layer uses ZMQ push/subscriptions to send driver configurations and to get driver updates. For more info see \nCORE protocol\n driver details.\n\n\nEnhanced description of the \nsample source code\n.\n\n\nimport zmq\nimport time\nimport driver_pb2 as driver_proto\nfrom  multiprocessing import Process\nfrom zmq.eventloop import ioloop, zmqstream\nioloop.install()\n\n# Either local host or the value you set in env var\ncreator_ip = os.environ.get('CREATOR_IP', '127.0.0.1')\ncreator_gpio_base_port = 20013 + 36\n\n# setup GPIO pin to output mode and set gpio value\ndef config_gpio_write(pin,value):\n    config = driver_proto.DriverConfig()\n    config.gpio.pin = pin\n    config.gpio.mode = driver_proto.GpioParams.OUTPUT\n    config.gpio.value = value\n    sconfig.send(config.SerializeToString())\n\n# setup GPIO pin to input mode\ndef config_gpio_read(pin):\n    config = driver_proto.DriverConfig()\n    # 250 miliseconds between updates.\n    config.delay_between_updates = 0.5\n    # Stop sending updates 2 seconds after pings.\n    config.timeout_after_last_ping = 3.5\n    config.gpio.pin = pin\n    config.gpio.mode = driver_proto.GpioParams.INPUT\n    sconfig.send(config.SerializeToString())\n\n# get complete GPIO register status. (all pines)\ndef gpio_callback(msg):\n    print \nReceived gpio register: %s\n % msg\n\n# ZMQ subscription for driver notifications via gpio_callback\ndef register_gpio_callback():\n    ssub = context.socket(zmq.SUB)\n    ssub_port = str(creator_gpio_base_port+3)\n    ssub.connect('tcp://' + creator_ip + ':' + ssub_port)\n    ssub.setsockopt(zmq.SUBSCRIBE,\n)\n    stream = zmqstream.ZMQStream(ssub)\n    stream.on_recv(gpio_callback)\n    print \nConnected to publisher with port %s\n % ssub_port\n    ioloop.IOLoop.instance().start()\n    print \nWorker has stopped processing messages.\n\n\n# toggle 0/1 on GPIO pin output\ndef task_gpio_write(pin):\n    pin_value = 0\n    while True:\n        pin_value ^= 1\n        config_gpio_write(pin,pin_value)\n        print ('GPIO:'+str(pin)+' =\n '+str(pin_value))\n        time.sleep(1)\n\n# request notifications to driver\ndef task_driver_ping():\n    context = zmq.Context()\n    sping = context.socket(zmq.PUSH)\n    sping.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port + 1))\n    while True:\n        sping.send('')\n        time.sleep(1)\n\nif __name__ == \n__main__\n:\n    # ZMQ initialization and build socket config\n    context = zmq.Context()\n    sconfig = context.socket(zmq.PUSH)\n    sconfig.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port))\n\n    config_gpio_write(0,0) # pin 0 in output mode, value 0\n    config_gpio_read(1)    # pin 1 in input mode\n\n    # register async tasks\n    Process(target = task_gpio_write, args = (0, )).start()\n    Process(target = task_driver_ping).start()\n\n    register_gpio_callback()\n\n\n\n\n\n\nCORE Driver details\n\n\n0MQ Port\n\n\n20049\n\n\n\n\nProtocol buffers\n\n\n// GPIO handler params\nmessage GpioParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // GPIO mode input/output\n  enum EnumMode {\n    INPUT = 0;\n    OUTPUT = 1;\n  }\n  EnumMode mode = 2;\n\n  // GPIO value\n  uint32 value = 3;\n\n  // GPIO all values\n  uint32 values = 4;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver reports errors when an invalid configuration is sent.\n\n\nWrite\n\n\nAll pins on matrix creator start as inputs. For change to outputs the driver need message for each pin on OUTPUT mode.\n\n\nRead\n\n\nThe driver will send a serialized message of integer \nvalues\n which reprensets of state from all GPIO pins \nsee figure 1\n. For example: \nvalues=5\n represents \n101\n (pin 0 on 1, pin 1 on 0 and pin 2 on 1).", 
            "title": "Python"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#python-examples", 
            "text": "", 
            "title": "Python Examples"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#prerequisites", 
            "text": "After sucessfully installing  MATRIX Core  in your Rapsberry Pi, clone matrix-creator-malos repository that contains Python examples:  cd ~/\ngit clone https://github.com/matrix-io/matrix-creator-malos.git", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#install-python-packages", 
            "text": "Install the following python packages dependencies:  sudo apt-get install build-essential python-dev\npip install -r requirements.txt  If you're using  pipenv , then also install:  pipenv install", 
            "title": "Install Python packages"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#test-gpio", 
            "text": "In this example the PIN 15 (in the MATRIX board external GPIOs) is set up in output mode and is then toggled with  0  and  1 .  cd ~/matrix-creator-malos/src/python_test\npython test_gpio.py  the output should be:  $ python test_gpio.py\nGPIO15=0\nGPIO15=1\nGPIO15=0  When using  pipenv  use this instead:  $ pipenv run python test_gpio.py", 
            "title": "Test GPIO"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#python-test-files", 
            "text": "", 
            "title": "Python Test Files"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#driver_info", 
            "text": "python test_driver_info.py", 
            "title": "Driver_info"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#everloop", 
            "text": "python test_everloop.py", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#everloop-color", 
            "text": "python test_set_everloop_color.py", 
            "title": "Everloop color"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#gpio", 
            "text": "python test_gpio.py", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#gpio-read-write", 
            "text": "python test_gpio_read_write.py", 
            "title": "GPIO Read &amp; Write"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#humidity", 
            "text": "python test_humidity.py", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#imu", 
            "text": "python test_imu.py", 
            "title": "Imu"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#ir", 
            "text": "python test_ir_remote.py", 
            "title": "IR"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#pressure", 
            "text": "python test_pressure.py", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#servo", 
            "text": "python test_servo.py", 
            "title": "Servo"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#uv", 
            "text": "python test_uv.py", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#gpio-python-example", 
            "text": "On this example, we will connect to CORE GPIO driver for controlling a single pin. GPIO driver on MATRIX creator supports:   GPIO pin input  GPIO pin output  GPIO updates (state from all pins)   The CORE driver follows the  CORE protocol .", 
            "title": "GPIO python example"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#gpio-example-details", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1  because we are connecting from the local host. It will be your creator's IP address if you wish to run the python samples from a different computer, in such case you can  export CREATOR_IP= ip  variable, and the samples will connect to the specified host.  We also set the base port for the CORE Pressure driver (20013).  import zmq\nimport time\nimport driver_pb2 as driver_proto # proto buffer precompiled\n\n# Either local host or the value you set in env var\ncreator_ip = os.environ.get('CREATOR_IP', '127.0.0.1')\ncreator_gpio_base_port = 20013 + 36\n\n# connection to device\ncontext = zmq.Context()\nsocket = context.socket(zmq.PUSH)\nsocket.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port))\n\n# instance for config driver message\nconfig = driver_proto.DriverConfig()\nconfig.gpio.pin = 15  # pin on board\nconfig.gpio.mode = driver_proto.GpioParams.OUTPUT # pin mode OUTPUT/INPUT\n\nwhile True:\n    config.gpio.value ^= 1 # toggle value\n    print ('GPIO'+str(config.gpio.pin)+'='+str(config.gpio.value))\n    socket.send(config.SerializeToString()) # send proto message\n    time.sleep(1)", 
            "title": "GPIO Example details"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#advanced-sample", 
            "text": "MATRIX CORE layer uses ZMQ push/subscriptions to send driver configurations and to get driver updates. For more info see  CORE protocol  driver details.  Enhanced description of the  sample source code .  import zmq\nimport time\nimport driver_pb2 as driver_proto\nfrom  multiprocessing import Process\nfrom zmq.eventloop import ioloop, zmqstream\nioloop.install()\n\n# Either local host or the value you set in env var\ncreator_ip = os.environ.get('CREATOR_IP', '127.0.0.1')\ncreator_gpio_base_port = 20013 + 36\n\n# setup GPIO pin to output mode and set gpio value\ndef config_gpio_write(pin,value):\n    config = driver_proto.DriverConfig()\n    config.gpio.pin = pin\n    config.gpio.mode = driver_proto.GpioParams.OUTPUT\n    config.gpio.value = value\n    sconfig.send(config.SerializeToString())\n\n# setup GPIO pin to input mode\ndef config_gpio_read(pin):\n    config = driver_proto.DriverConfig()\n    # 250 miliseconds between updates.\n    config.delay_between_updates = 0.5\n    # Stop sending updates 2 seconds after pings.\n    config.timeout_after_last_ping = 3.5\n    config.gpio.pin = pin\n    config.gpio.mode = driver_proto.GpioParams.INPUT\n    sconfig.send(config.SerializeToString())\n\n# get complete GPIO register status. (all pines)\ndef gpio_callback(msg):\n    print  Received gpio register: %s  % msg\n\n# ZMQ subscription for driver notifications via gpio_callback\ndef register_gpio_callback():\n    ssub = context.socket(zmq.SUB)\n    ssub_port = str(creator_gpio_base_port+3)\n    ssub.connect('tcp://' + creator_ip + ':' + ssub_port)\n    ssub.setsockopt(zmq.SUBSCRIBE, )\n    stream = zmqstream.ZMQStream(ssub)\n    stream.on_recv(gpio_callback)\n    print  Connected to publisher with port %s  % ssub_port\n    ioloop.IOLoop.instance().start()\n    print  Worker has stopped processing messages. \n\n# toggle 0/1 on GPIO pin output\ndef task_gpio_write(pin):\n    pin_value = 0\n    while True:\n        pin_value ^= 1\n        config_gpio_write(pin,pin_value)\n        print ('GPIO:'+str(pin)+' =  '+str(pin_value))\n        time.sleep(1)\n\n# request notifications to driver\ndef task_driver_ping():\n    context = zmq.Context()\n    sping = context.socket(zmq.PUSH)\n    sping.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port + 1))\n    while True:\n        sping.send('')\n        time.sleep(1)\n\nif __name__ ==  __main__ :\n    # ZMQ initialization and build socket config\n    context = zmq.Context()\n    sconfig = context.socket(zmq.PUSH)\n    sconfig.connect('tcp://' + creator_ip + ':' + str(creator_gpio_base_port))\n\n    config_gpio_write(0,0) # pin 0 in output mode, value 0\n    config_gpio_read(1)    # pin 1 in input mode\n\n    # register async tasks\n    Process(target = task_gpio_write, args = (0, )).start()\n    Process(target = task_driver_ping).start()\n\n    register_gpio_callback()", 
            "title": "Advanced sample"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#core-driver-details", 
            "text": "", 
            "title": "CORE Driver details"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#0mq-port", 
            "text": "20049", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#protocol-buffers", 
            "text": "// GPIO handler params\nmessage GpioParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // GPIO mode input/output\n  enum EnumMode {\n    INPUT = 0;\n    OUTPUT = 1;\n  }\n  EnumMode mode = 2;\n\n  // GPIO value\n  uint32 value = 3;\n\n  // GPIO all values\n  uint32 values = 4;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#errors", 
            "text": "This driver reports errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#write", 
            "text": "All pins on matrix creator start as inputs. For change to outputs the driver need message for each pin on OUTPUT mode.", 
            "title": "Write"
        }, 
        {
            "location": "/matrix-core/examples/pytests/#read", 
            "text": "The driver will send a serialized message of integer  values  which reprensets of state from all GPIO pins  see figure 1 . For example:  values=5  represents  101  (pin 0 on 1, pin 1 on 0 and pin 2 on 1).", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/examples/jstests/", 
            "text": "Javascript Example\n\n\n\n\nYou need \nNodeJS, and the Node Package Manager (npm)\n installed on the Raspberry Pi.\n\n\n\n\nCORE is the program that sits between the low level hardware layer and MATRIX OS. This program allows MATRIX OS to access the board hardware via ZeroMQ sockets. You can also use it directly, as it is done with the examples below. The IPs are hardcoded in the examples to 127.0.0.1. Remember to edit them if you're accessing the Creator from another host and not from the Raspberry itself.\n\n\nFor an in-depth discussion of these tests, please examine the \nReference\n sections for JavaScript details.\n\n\nOn the Raspberry Pi\n\n\n# Install npm (doesn't really matter what version, apt-get node is v0.10...)\nsudo apt-get install npm\n\n# n is a node version manager\nsudo npm install -g n\n\n# node 6.5 is the latest target node version, also installs new npm\nn 6.5\n\n# check version\nnode -v\n\n\n\n\nDownload and Prepare CORE\n\n\ngit clone https://github.com/matrix-io/matrix-creator-malos\ncd matrix-creator-malos\ncd src/js_test\nnpm install\n\n\n\n\nUsing CORE\n\n\nCORE Examples\n\n\nConnecting to CORE with NodeJS\n\n\nNote:\n You'll need \nprotobufjs\n and \nzmq\n npm packages, and protobuf as a submodule. See the \nEverloop Example\n for the full implementation of the code below.\n\n\n// This is how we connect to the creator. IP and port.\n// The IP is the IP I'm using and you need to edit it.\n// By default, CORE has its 0MQ ports open to the world.\n\n// Every device is identified by a base port. Then the mapping works\n// as follows:\n// BasePort     =\n Configuration port. Used to config the device.\n// BasePort + 1 =\n Keepalive port. Send pings to this port.\n// BasePort + 2 =\n Error port. Receive errros from device.\n// BasePort + 3 =\n Data port. Receive data from device.\n\nvar protoBuf = require(\nprotobufjs\n);\nvar zmq = require('zmq');\nvar configSocket = zmq.socket('push')\n\nvar creator_ip = '127.0.0.1'\nvar creator_everloop_base_port = 20013 + 8 // port for Everloop driver.\n\n// relative to where you have the protobufs\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n\n// malos interface\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_everloop_base_port /* config */)\n\n...\n\n\n\n\nPassing Commands to CORE\n\n\nBelow is an example of Node interfacing with the Everloop via CORE. See the \nEverloop Example\n for the full implementation of the code below.\n\n\n...\n\nvar max_intensity = 50\nvar intensity_value = max_intensity\n\nfunction setEverloop() {\n    var config = new matrixMalosBuilder.DriverConfig\n    config.image = new matrixMalosBuilder.EverloopImage\n\n    // Iteration over all 35 Everloop LEDs to turn them green.\n    for (var j = 0; j \n 35; ++j) {\n      var ledValue = new matrixMalosBuilder.LedValue;\n\n      // set brightness/intensity of the color for each rgb LED.\n      ledValue.setRed(0);\n      ledValue.setGreen(intensity_value);\n      ledValue.setBlue(0);\n      ledValue.setWhite(0);\n      config.image.led.push(ledValue);\n    }\n    configSocket.send(config.encode().toBuffer());\n}\n\nsetEverloop(intensity_value)\nsetInterval(function() {\n  intensity_value -= 1\n  if (intensity_value \n 0)\n    intensity_value = max_intensity\n  setEverloop()\n}, 10);\n\n\n\n\nReading from CORE\n\n\nBelow is a simple implementation via NodeJS to read a \nhumidity\n from CORE via 0MQ. See \nHumidity Example\n for the full example.\n\n\n// Start configuration for refresh rate, and heartbeat timeouts\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_humidity_base_port)\n// Send driver configuration.\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n// 2 seconds between updates.\ndriverConfigProto.delay_between_updates = 2.0\n// Stop sending updates 6 seconds after pings.\ndriverConfigProto.timeout_after_last_ping = 6.0\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n// ********** End configuration.\n\n// ********** Start updates - Here is where they are received.\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  // read Humidity (or Pressure, Imu, UV, etc...) \n  var data = new matrixMalosBuilder.Humidity.decode(buffer)\n  console.log(data)\n});\n// ********** End updates\n\n\n\n\nDrivers\n\n\nnode test_driver_info.js\n\n\n\n\nEverloop\n\n\nnode test_everloop.js\n\n\n\n\nHumidity\n\n\nnode test_humidity.js\n\n\n\n\nIMU\n\n\nnode test_imu.js\n\n\n\n\nIR Remote\n\n\nnode test_ir_remote.js\n\n\n\n\nPressure\n\n\nnode test_pressure.js\n\n\n\n\nUV\n\n\nnode test_uv.js\n\n\n\n\nZigbee Bulb On/Off\n\n\nnode test_zigbee_bulb.js\n\n\n\n\nZigbee Bulb Color\n\n\nnode test_zigbee_color.js\n\n\n\n\nZigbee Bulb Brightness\n\n\nnode test_zigbee_level.js", 
            "title": "JavaScript"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#javascript-example", 
            "text": "You need  NodeJS, and the Node Package Manager (npm)  installed on the Raspberry Pi.   CORE is the program that sits between the low level hardware layer and MATRIX OS. This program allows MATRIX OS to access the board hardware via ZeroMQ sockets. You can also use it directly, as it is done with the examples below. The IPs are hardcoded in the examples to 127.0.0.1. Remember to edit them if you're accessing the Creator from another host and not from the Raspberry itself.  For an in-depth discussion of these tests, please examine the  Reference  sections for JavaScript details.", 
            "title": "Javascript Example"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#on-the-raspberry-pi", 
            "text": "# Install npm (doesn't really matter what version, apt-get node is v0.10...)\nsudo apt-get install npm\n\n# n is a node version manager\nsudo npm install -g n\n\n# node 6.5 is the latest target node version, also installs new npm\nn 6.5\n\n# check version\nnode -v", 
            "title": "On the Raspberry Pi"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#download-and-prepare-core", 
            "text": "git clone https://github.com/matrix-io/matrix-creator-malos\ncd matrix-creator-malos\ncd src/js_test\nnpm install", 
            "title": "Download and Prepare CORE"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#using-core", 
            "text": "", 
            "title": "Using CORE"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#core-examples", 
            "text": "", 
            "title": "CORE Examples"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#connecting-to-core-with-nodejs", 
            "text": "Note:  You'll need  protobufjs  and  zmq  npm packages, and protobuf as a submodule. See the  Everloop Example  for the full implementation of the code below.  // This is how we connect to the creator. IP and port.\n// The IP is the IP I'm using and you need to edit it.\n// By default, CORE has its 0MQ ports open to the world.\n\n// Every device is identified by a base port. Then the mapping works\n// as follows:\n// BasePort     =  Configuration port. Used to config the device.\n// BasePort + 1 =  Keepalive port. Send pings to this port.\n// BasePort + 2 =  Error port. Receive errros from device.\n// BasePort + 3 =  Data port. Receive data from device.\n\nvar protoBuf = require( protobufjs );\nvar zmq = require('zmq');\nvar configSocket = zmq.socket('push')\n\nvar creator_ip = '127.0.0.1'\nvar creator_everloop_base_port = 20013 + 8 // port for Everloop driver.\n\n// relative to where you have the protobufs\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n\n// malos interface\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_everloop_base_port /* config */)\n\n...", 
            "title": "Connecting to CORE with NodeJS"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#passing-commands-to-core", 
            "text": "Below is an example of Node interfacing with the Everloop via CORE. See the  Everloop Example  for the full implementation of the code below.  ...\n\nvar max_intensity = 50\nvar intensity_value = max_intensity\n\nfunction setEverloop() {\n    var config = new matrixMalosBuilder.DriverConfig\n    config.image = new matrixMalosBuilder.EverloopImage\n\n    // Iteration over all 35 Everloop LEDs to turn them green.\n    for (var j = 0; j   35; ++j) {\n      var ledValue = new matrixMalosBuilder.LedValue;\n\n      // set brightness/intensity of the color for each rgb LED.\n      ledValue.setRed(0);\n      ledValue.setGreen(intensity_value);\n      ledValue.setBlue(0);\n      ledValue.setWhite(0);\n      config.image.led.push(ledValue);\n    }\n    configSocket.send(config.encode().toBuffer());\n}\n\nsetEverloop(intensity_value)\nsetInterval(function() {\n  intensity_value -= 1\n  if (intensity_value   0)\n    intensity_value = max_intensity\n  setEverloop()\n}, 10);", 
            "title": "Passing Commands to CORE"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#reading-from-core", 
            "text": "Below is a simple implementation via NodeJS to read a  humidity  from CORE via 0MQ. See  Humidity Example  for the full example.  // Start configuration for refresh rate, and heartbeat timeouts\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_humidity_base_port)\n// Send driver configuration.\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n// 2 seconds between updates.\ndriverConfigProto.delay_between_updates = 2.0\n// Stop sending updates 6 seconds after pings.\ndriverConfigProto.timeout_after_last_ping = 6.0\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n// ********** End configuration.\n\n// ********** Start updates - Here is where they are received.\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  // read Humidity (or Pressure, Imu, UV, etc...) \n  var data = new matrixMalosBuilder.Humidity.decode(buffer)\n  console.log(data)\n});\n// ********** End updates", 
            "title": "Reading from CORE"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#drivers", 
            "text": "node test_driver_info.js", 
            "title": "Drivers"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#everloop", 
            "text": "node test_everloop.js", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#humidity", 
            "text": "node test_humidity.js", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#imu", 
            "text": "node test_imu.js", 
            "title": "IMU"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#ir-remote", 
            "text": "node test_ir_remote.js", 
            "title": "IR Remote"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#pressure", 
            "text": "node test_pressure.js", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#uv", 
            "text": "node test_uv.js", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#zigbee-bulb-onoff", 
            "text": "node test_zigbee_bulb.js", 
            "title": "Zigbee Bulb On/Off"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#zigbee-bulb-color", 
            "text": "node test_zigbee_color.js", 
            "title": "Zigbee Bulb Color"
        }, 
        {
            "location": "/matrix-core/examples/jstests/#zigbee-bulb-brightness", 
            "text": "node test_zigbee_level.js", 
            "title": "Zigbee Bulb Brightness"
        }, 
        {
            "location": "/matrix-core/reference/", 
            "text": "Reference\n\n\n\n\nEverloop\n\n\nHumidity\n\n\nIMU\n\n\n\n\nPressure\n\n\nUV\n\n\nGPIO", 
            "title": "Index"
        }, 
        {
            "location": "/matrix-core/reference/#reference", 
            "text": "Everloop  Humidity  IMU   Pressure  UV  GPIO", 
            "title": "Reference"
        }, 
        {
            "location": "/matrix-core/reference/everloop/", 
            "text": "Everloop\n\n\nThe Everloop driver controls the LED array of the MATRIX Creator.\nIt follows the \nCORE protocol\n.\n\n\n0MQ Port\n\n\n20021\n\n\n\n\nKeep-alives\n\n\nThis driver doesn't need keep-alive messages as it doesn't send data to the subscribed programs.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThis driver doesn't send any data to a subscribed program.\n\n\nExample Usage\n\n\nThis section provides an enhanced description of the relevant parts of the \nsample source code\n.\n\n\nTo run the source code of this example you need to execute the following commands:\n\n\ngit clone https://github.com/matrix-io/matrix-creator-malos.git\ncd matrix-creator-malos\ncd src/js_test/\nnpm install\nnode test_everloop.js\n\n\n\n\nIn order to set the LEDs of the Creator you need to perform the following steps.\n\n\nInitialize Configuration\n\n\nvar config = new matrixMalosBuilder.DriverConfig\n\n\n\nCreate LED configuration object\n\n\nconfig.image = new matrixMalosBuilder.EverloopImage\n\n\n\nSet LED states\n\n\nThe following steps needs to be repeated 35 times, once per LED.\n\n\nThe LEDs are counted starting from the left, clock-wise\nas shown in the picture.\n\n\n\n\nIndividual LED state\n\n\nFirst, create the object.\n\n\nvar ledValue = new matrixMalosBuilder.LedValue\n\n\n\n\nNow fill out the state of a given led by calling the following functions on ledValue.\nEach of the following functions receives an integer in the range [0, 255].\n\n\n\n\n\n\n\n\nFunction\n\n\nObjective\n\n\n\n\n\n\n\n\n\n\nsetRed\n\n\nSet value of red component\n\n\n\n\n\n\nsetGreen\n\n\nSet value of green component\n\n\n\n\n\n\nSetBlue\n\n\nSet value of blue component\n\n\n\n\n\n\nSeWhite\n\n\nSet value of white component\n\n\n\n\n\n\n\n\nThat is, repeat 35 times:\n\n\nledValue.setRed(red_value)\nledValue.setGreen(green_value)\nledValue.setBlue(blue_value)\nledValue.setWhite(white_value)\n\nconfig.image.led.push(ledValue)\n\n\n\n\nSend configuration\n\n\nconfigSocket.send(config.encode().toBuffer())\n\n\n\n\nAll steps combined\n\n\nThe following snippet will make all the greens display the green color.\n\n\nvar config = new matrixMalosBuilder.DriverConfig\nconfig.image = new matrixMalosBuilder.EverloopImage\nfor (var j = 0; j \n 35; ++j) {\n    var ledValue = new matrixMalosBuilder.LedValue\n    ledValue.setRed(0)\n    ledValue.setGreen(30)\n    ledValue.setBlue(0)\n    ledValue.setWhite(0)\n    config.image.led.push(ledValue)\n}\nconfigSocket.send(config.encode().toBuffer())\n\n\n\n\nGlossary\n\n\nProtocol buffers\n\n\nIn this section we get into the details of the \nprotocol buffers\n used by the\nJavaScript example to communicate with the Everloop driver.\nThe messages used by this driver are defined in \ndriver.proto\n.\n\n\nmessage EverloopImage {\n  repeated LedValue led = 1;\n}\n\n\n\n\nThe message \nEverloopImage\n needs to have exactly 35 messages of type \nLedValue\n in the repeated field \nled\n,\ncorresponding to each of the LEDs present in the Creator.\n\n\nThe message LedValue holds the color values for each LED and each value is in the range [0, 255].\n\n\nmessage LedValue {\n  uint32 red = 1;\n  uint32 green = 2;\n  uint32 blue = 3;\n  uint32 white = 4;\n}", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#everloop", 
            "text": "The Everloop driver controls the LED array of the MATRIX Creator.\nIt follows the  CORE protocol .", 
            "title": "Everloop"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#0mq-port", 
            "text": "20021", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#keep-alives", 
            "text": "This driver doesn't need keep-alive messages as it doesn't send data to the subscribed programs.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#read", 
            "text": "This driver doesn't send any data to a subscribed program.", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#example-usage", 
            "text": "This section provides an enhanced description of the relevant parts of the  sample source code .  To run the source code of this example you need to execute the following commands:  git clone https://github.com/matrix-io/matrix-creator-malos.git\ncd matrix-creator-malos\ncd src/js_test/\nnpm install\nnode test_everloop.js  In order to set the LEDs of the Creator you need to perform the following steps.", 
            "title": "Example Usage"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#initialize-configuration", 
            "text": "var config = new matrixMalosBuilder.DriverConfig", 
            "title": "Initialize Configuration"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#create-led-configuration-object", 
            "text": "config.image = new matrixMalosBuilder.EverloopImage", 
            "title": "Create LED configuration object"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#set-led-states", 
            "text": "The following steps needs to be repeated 35 times, once per LED.  The LEDs are counted starting from the left, clock-wise\nas shown in the picture.", 
            "title": "Set LED states"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#individual-led-state", 
            "text": "First, create the object.  var ledValue = new matrixMalosBuilder.LedValue  Now fill out the state of a given led by calling the following functions on ledValue.\nEach of the following functions receives an integer in the range [0, 255].     Function  Objective      setRed  Set value of red component    setGreen  Set value of green component    SetBlue  Set value of blue component    SeWhite  Set value of white component     That is, repeat 35 times:  ledValue.setRed(red_value)\nledValue.setGreen(green_value)\nledValue.setBlue(blue_value)\nledValue.setWhite(white_value)\n\nconfig.image.led.push(ledValue)", 
            "title": "Individual LED state"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#send-configuration", 
            "text": "configSocket.send(config.encode().toBuffer())", 
            "title": "Send configuration"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#all-steps-combined", 
            "text": "The following snippet will make all the greens display the green color.  var config = new matrixMalosBuilder.DriverConfig\nconfig.image = new matrixMalosBuilder.EverloopImage\nfor (var j = 0; j   35; ++j) {\n    var ledValue = new matrixMalosBuilder.LedValue\n    ledValue.setRed(0)\n    ledValue.setGreen(30)\n    ledValue.setBlue(0)\n    ledValue.setWhite(0)\n    config.image.led.push(ledValue)\n}\nconfigSocket.send(config.encode().toBuffer())", 
            "title": "All steps combined"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#glossary", 
            "text": "", 
            "title": "Glossary"
        }, 
        {
            "location": "/matrix-core/reference/everloop/#protocol-buffers", 
            "text": "In this section we get into the details of the  protocol buffers  used by the\nJavaScript example to communicate with the Everloop driver.\nThe messages used by this driver are defined in  driver.proto .  message EverloopImage {\n  repeated LedValue led = 1;\n}  The message  EverloopImage  needs to have exactly 35 messages of type  LedValue  in the repeated field  led ,\ncorresponding to each of the LEDs present in the Creator.  The message LedValue holds the color values for each LED and each value is in the range [0, 255].  message LedValue {\n  uint32 red = 1;\n  uint32 green = 2;\n  uint32 blue = 3;\n  uint32 white = 4;\n}", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/gpio/", 
            "text": "GPIO\n\n\nThe GPIO driver on current version supports:\n\n\n\n\nGPIO pin input\n\n\nGPIO pin output\n\n\nGPIO updates (state from all pins)\n\n\n\n\nThe driver follows the \nCORE protocol\n.\n\n\nGPIO electrical characteristics\n\n\n\n\nGPIO voltage: 0.60-4.10 VDC (\ndetails\n)\n\n\ncurrent 10mA max\n\n\nall GPIO pins need pullups\n\n\n\n\n0MQ Port\n\n\n20049\n\n\n\n\nProtocol buffers\n\n\n// GPIO handler params\nmessage GpioParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // GPIO mode input/output\n  enum EnumMode {\n    INPUT = 0;\n    OUTPUT = 1;\n  }\n  EnumMode mode = 2;\n\n  // GPIO value\n  uint32 value = 3;\n\n  // GPIO all values\n  uint32 values = 4;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver reports errors when an invalid configuration is sent.\n\n\nWrite\n\n\nAll pins on matrix creator start as inputs. For change to outputs the driver need message for each pin on OUTPUT mode. (see Javascript example below)\n\n\nRead\n\n\nThe driver will send a serialized message of integer \nvalues\n which represents of state from all GPIO pins \nsee figure 1\n. For example: \nvalues=5\n represents \n101\n (pin 0 on 1, pin 1 on 0 and pin 2 on 1).\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_gpio.js \nSending pings every 5 seconds\n==\n pin 0 set to: true\n\n== GPIO pins register:  1\n\n\n\n\n(pin0 set on true and GPIO register return values field on 1, only pin 0 set 1)\n\n\n$ node test_gpio.js \nSending pings every 5 seconds\n==\n pin 0 set to: true\n\n== GPIO pins register:  101\n\n\n\n\n(pin0 set on true and GPIO register return values field on 3 (binary 101) pin 0 on 1, pin 2 on 1 all then on 0)\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_gpio_base_port = 20013 + 36\n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n);\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver (optional)\n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nConfigure GPIO pins modes and set values for GPIO outputs:\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\n\n\nOutput mode:\n\n\ninstance driver config object \n\n\n  var config = new matrixMalosBuilder.DriverConfig\n\n\n\n\nwith GpioParams proto message set GPIO 0 to output mode \n\n\n  var gpio_cfg_cmd = new matrixMalosBuilder.GpioParams\n  gpio_cfg_cmd.set_pin(0)\n  gpio_cfg_cmd.set_mode(matrixMalosBuilder.GpioParams.EnumMode.OUTPUT)\n\n\n\n\nset GPIO pin value (0 or 1)\n\n\n  gpio_cfg_cmd.set_value(1);\n\n\n\n\nset on config driver params, encode and send\n\n\n  config.set_gpio(gpio_cfg_cmd)\n  configSocket.send(config.encode().toBuffer())\n\n\n\n\nInput mode:\n\n\ninstance driver config object \n\n\n  var config = new matrixMalosBuilder.DriverConfig\n\n\n\n\nset 250 ms between updates for example: (optional, default 1 second)\n\n\n  config.delay_between_updates = .250\n\n\n\n\nconfigure sending updates 2 seconds after pings (optional)\n\n\n  config.timeout_after_last_ping = 2.0\n\n\n\n\nwith \nGpioParams\n for example set GPIO 1 to input mode:\n\n\n  var gpio_cfg_cmd = new matrixMalosBuilder.GpioParams\n  gpio_cfg_cmd.set_pin(1)\n  gpio_cfg_cmd.set_mode(matrixMalosBuilder.GpioParams.EnumMode.INPUT)\n\n\n\n\nset on config driver params, encode and send\n\n\n  config.set_gpio(gpio_cfg_cmd)\n  configSocket.send(config.encode().toBuffer())\n\n\n\n\nSubscribe to GPIO updates\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 3))\nupdateSocket.subscribe('')\n\n\n\n\nRegister update callback:\n\n\nupdateSocket.on('message', function(gpio_buffer) {\n  var gpioData = new matrixMalosBuilder.GpioParams.decode(gpio_buffer)\n  // output in binary format all 15 pins of GPIO\n  console.log('\n== GPIO pins register: ',dec2bin(gpioData.values))\n});\n\n\n\n\nThe driver will send on callback a serialized message of integer \nvalues\n which represents of state from all GPIO pins\n\n\nKeep-alive messages\n\n\nAn empty keep-alive message is sent to the driver every 2 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 1))\n// Ping the first time.\npingSocket.send(''); \n// Ping every 2 seconds (same to delay between updates)\nsetInterval(function() {\n  pingSocket.send(''); // ping for new updates\n}, 2000);", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#gpio", 
            "text": "The GPIO driver on current version supports:   GPIO pin input  GPIO pin output  GPIO updates (state from all pins)   The driver follows the  CORE protocol .", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#gpio-electrical-characteristics", 
            "text": "GPIO voltage: 0.60-4.10 VDC ( details )  current 10mA max  all GPIO pins need pullups", 
            "title": "GPIO electrical characteristics"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#0mq-port", 
            "text": "20049", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#protocol-buffers", 
            "text": "// GPIO handler params\nmessage GpioParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // GPIO mode input/output\n  enum EnumMode {\n    INPUT = 0;\n    OUTPUT = 1;\n  }\n  EnumMode mode = 2;\n\n  // GPIO value\n  uint32 value = 3;\n\n  // GPIO all values\n  uint32 values = 4;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#keep-alives", 
            "text": "If you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#errors", 
            "text": "This driver reports errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#write", 
            "text": "All pins on matrix creator start as inputs. For change to outputs the driver need message for each pin on OUTPUT mode. (see Javascript example below)", 
            "title": "Write"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#read", 
            "text": "The driver will send a serialized message of integer  values  which represents of state from all GPIO pins  see figure 1 . For example:  values=5  represents  101  (pin 0 on 1, pin 1 on 0 and pin 2 on 1).  This is a sample output given by the example described below.  $ node test_gpio.js \nSending pings every 5 seconds\n==  pin 0 set to: true == GPIO pins register:  1  (pin0 set on true and GPIO register return values field on 1, only pin 0 set 1)  $ node test_gpio.js \nSending pings every 5 seconds\n==  pin 0 set to: true == GPIO pins register:  101  (pin0 set on true and GPIO register return values field on 3 (binary 101) pin 0 on 1, pin 2 on 1 all then on 0)", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.  var creator_ip = '127.0.0.1'\nvar creator_gpio_base_port = 20013 + 36", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#load-the-protocol-buffers-used-in-the-example", 
            "text": "var protoBuf = require( protobufjs );\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )", 
            "title": "Load the protocol buffers used in the example."
        }, 
        {
            "location": "/matrix-core/reference/gpio/#subscribe-to-the-errors-reported-by-the-driver-optional", 
            "text": "var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') +  \\n )\n});", 
            "title": "Subscribe to the errors reported by the driver (optional)"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#configure-gpio-pins-modes-and-set-values-for-gpio-outputs", 
            "text": "All the drivers are configured using the message  DriverConfig  (see  driver.proto ).", 
            "title": "Configure GPIO pins modes and set values for GPIO outputs:"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#output-mode", 
            "text": "instance driver config object     var config = new matrixMalosBuilder.DriverConfig  with GpioParams proto message set GPIO 0 to output mode     var gpio_cfg_cmd = new matrixMalosBuilder.GpioParams\n  gpio_cfg_cmd.set_pin(0)\n  gpio_cfg_cmd.set_mode(matrixMalosBuilder.GpioParams.EnumMode.OUTPUT)  set GPIO pin value (0 or 1)    gpio_cfg_cmd.set_value(1);  set on config driver params, encode and send    config.set_gpio(gpio_cfg_cmd)\n  configSocket.send(config.encode().toBuffer())", 
            "title": "Output mode:"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#input-mode", 
            "text": "instance driver config object     var config = new matrixMalosBuilder.DriverConfig  set 250 ms between updates for example: (optional, default 1 second)    config.delay_between_updates = .250  configure sending updates 2 seconds after pings (optional)    config.timeout_after_last_ping = 2.0  with  GpioParams  for example set GPIO 1 to input mode:    var gpio_cfg_cmd = new matrixMalosBuilder.GpioParams\n  gpio_cfg_cmd.set_pin(1)\n  gpio_cfg_cmd.set_mode(matrixMalosBuilder.GpioParams.EnumMode.INPUT)  set on config driver params, encode and send    config.set_gpio(gpio_cfg_cmd)\n  configSocket.send(config.encode().toBuffer())", 
            "title": "Input mode:"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#subscribe-to-gpio-updates", 
            "text": "Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 3))\nupdateSocket.subscribe('')  Register update callback:  updateSocket.on('message', function(gpio_buffer) {\n  var gpioData = new matrixMalosBuilder.GpioParams.decode(gpio_buffer)\n  // output in binary format all 15 pins of GPIO\n  console.log(' == GPIO pins register: ',dec2bin(gpioData.values))\n});  The driver will send on callback a serialized message of integer  values  which represents of state from all GPIO pins", 
            "title": "Subscribe to GPIO updates"
        }, 
        {
            "location": "/matrix-core/reference/gpio/#keep-alive-messages", 
            "text": "An empty keep-alive message is sent to the driver every 2 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_gpio_base_port + 1))\n// Ping the first time.\npingSocket.send(''); \n// Ping every 2 seconds (same to delay between updates)\nsetInterval(function() {\n  pingSocket.send(''); // ping for new updates\n}, 2000);", 
            "title": "Keep-alive messages"
        }, 
        {
            "location": "/matrix-core/reference/humidity/", 
            "text": "Humidity\n\n\nThe Humidity driver reports values for:\n\n\n\n\nRelative Humidity on the Board \n\n\nTemperature in Celsius\n\n\nRAW Values of temperature\n\n\n\n\nThe Humidity can be configured with:\n\n Current temperature in Celsius\n\n Flag to set software calibration.\n\n\nThe driver follows the \nCORE protocol\n.\n\n\n0MQ Port\n\n\n20029\n\n\n\n\nProtocol buffers\n\n\nmessage Humidity {\n  float humidity = 1;\n  float temperature = 2;\n  float temperature_raw = 3;\n  bool temperature_is_calibrated = 4 ;\n}\n\nmessage HumidityParams{\n  float current_temperature = 1; \n  bool do_calibration = 2;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThe driver will send a serialized message of type \nHumidity\n.\n\n\nmessage Humidity {\n  float humidity = 1;\n  float temperature = 2;\n  float temperature_raw = 3;\n  bool temperature_is_calibrated = 4 ;\n}\n\nmessage HumidityParams{\n  float current_temperature = 1;\n  bool do_calibration = 2;\n}\n\n\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_humidity.js \nSending pings every 5 secondsMessage received: Humidity error: 0, Invalid specific configuration for Humidity driver.\n{ humidity: 30.716121673583984,\n  temperature: 20.246780395507812,\n  temperature_raw: 35.456275939941406,\n  temperature_is_calibrated: true }\n{ humidity: 30.716121673583984,\n  temperature: 20.246780395507812,\n  temperature_raw: 35.456275939941406,\n  temperature_is_calibrated: true }\n\n\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Humidity driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_humidity_base_port = 20013 + 4 \n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n)\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver. \n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Humidity error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\nThis is what the message looks like if we omit the fields that are not used in this example.\n\n\nmessage DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n  HumidityParams humidity = 9;\n}\n\n\n\n\nThe following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.\n\n\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_uv_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\nvar hum_params_msg = new matrixMalosBuilder.HumidityParams\nhum_params_msg.current_temperature = 23\nhum_params_msg.do_calibration = false\ndriverConfigProto.set_humidity(hum_params_msg)\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n\n\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.Humidity.decode(buffer)\n  console.log(data)\n});\n\n\n\n\nAn empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 1))\nprocess.stdout.write(\nSending pings every 5 seconds\n);\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#humidity", 
            "text": "The Humidity driver reports values for:   Relative Humidity on the Board   Temperature in Celsius  RAW Values of temperature   The Humidity can be configured with:  Current temperature in Celsius  Flag to set software calibration.  The driver follows the  CORE protocol .", 
            "title": "Humidity"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#0mq-port", 
            "text": "20029", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#protocol-buffers", 
            "text": "message Humidity {\n  float humidity = 1;\n  float temperature = 2;\n  float temperature_raw = 3;\n  bool temperature_is_calibrated = 4 ;\n}\n\nmessage HumidityParams{\n  float current_temperature = 1; \n  bool do_calibration = 2;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#read", 
            "text": "The driver will send a serialized message of type  Humidity .  message Humidity {\n  float humidity = 1;\n  float temperature = 2;\n  float temperature_raw = 3;\n  bool temperature_is_calibrated = 4 ;\n}\n\nmessage HumidityParams{\n  float current_temperature = 1;\n  bool do_calibration = 2;\n}  This is a sample output given by the example described below.  $ node test_humidity.js \nSending pings every 5 secondsMessage received: Humidity error: 0, Invalid specific configuration for Humidity driver.\n{ humidity: 30.716121673583984,\n  temperature: 20.246780395507812,\n  temperature_raw: 35.456275939941406,\n  temperature_is_calibrated: true }\n{ humidity: 30.716121673583984,\n  temperature: 20.246780395507812,\n  temperature_raw: 35.456275939941406,\n  temperature_is_calibrated: true }", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/humidity/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Humidity driver.  var creator_ip = '127.0.0.1'\nvar creator_humidity_base_port = 20013 + 4   Load the protocol buffers used in the example.  var protoBuf = require( protobufjs )\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )  Subscribe to the errors reported by the driver.   var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Humidity error: ' + error_message.toString('utf8') +  \\n )\n});  All the drivers are configured using the message  DriverConfig  (see  driver.proto ).\nThis is what the message looks like if we omit the fields that are not used in this example.  message DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n  HumidityParams humidity = 9;\n}  The following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.  var configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_uv_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\nvar hum_params_msg = new matrixMalosBuilder.HumidityParams\nhum_params_msg.current_temperature = 23\nhum_params_msg.do_calibration = false\ndriverConfigProto.set_humidity(hum_params_msg)\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())  Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.Humidity.decode(buffer)\n  console.log(data)\n});  An empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_humidity_base_port + 1))\nprocess.stdout.write( Sending pings every 5 seconds );\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/imu/", 
            "text": "Inertial Measurement Unit - IMU\n\n\nThe IMU driver reports values for:\n\n\n\n\nYaw Axis or normal axis\n\n\nPitch Axis or lateral axis\n\n\nRoll Axis or longitudinal axis\n\n\n\n\nThe driver follows the \nCORE protocol\n.\n\n\n0MQ Port\n\n\n20013\n\n\n\n\nProtocol buffers\n\n\nmessage Imu {\n  float yaw = 1;\n  float pitch = 2;\n  float roll = 3;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThe driver will send a serialized message of type\nIMU\n.\n\n\nmessage Imu {\n  float yaw = 1;\n  float pitch = 2;\n  float roll = 3;\n}\n\n\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_imu.js \nSending pings every 5 seconds\n{ yaw: 164.5285186767578,\n  pitch: -6.635251045227051,\n  roll: 3.231848955154419 }\n{ yaw: 163.763427734375,\n  pitch: -6.659839153289795,\n  roll: 2.655540943145752 }\n{ yaw: 164.1026153564453,\n  pitch: -6.485481262207031,\n  roll: 2.9403600692749023 }\n\n\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe IMU driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_imu_base_port = 20013\n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n)\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver. \n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: IMU error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\nThis is what the message looks like if we omit the fields that are not used in this example.\n\n\nmessage DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}\n\n\n\n\nThe following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.\n\n\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_imu_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n\n\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.IMU.decode(buffer)\n  console.log(data)\n});\n\n\n\n\nAn empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 1))\nprocess.stdout.write(\nSending pings every 5 seconds\n);\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "IMU"
        }, 
        {
            "location": "/matrix-core/reference/imu/#inertial-measurement-unit-imu", 
            "text": "The IMU driver reports values for:   Yaw Axis or normal axis  Pitch Axis or lateral axis  Roll Axis or longitudinal axis   The driver follows the  CORE protocol .", 
            "title": "Inertial Measurement Unit - IMU"
        }, 
        {
            "location": "/matrix-core/reference/imu/#0mq-port", 
            "text": "20013", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/imu/#protocol-buffers", 
            "text": "message Imu {\n  float yaw = 1;\n  float pitch = 2;\n  float roll = 3;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/imu/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/imu/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/imu/#read", 
            "text": "The driver will send a serialized message of type IMU .  message Imu {\n  float yaw = 1;\n  float pitch = 2;\n  float roll = 3;\n}  This is a sample output given by the example described below.  $ node test_imu.js \nSending pings every 5 seconds\n{ yaw: 164.5285186767578,\n  pitch: -6.635251045227051,\n  roll: 3.231848955154419 }\n{ yaw: 163.763427734375,\n  pitch: -6.659839153289795,\n  roll: 2.655540943145752 }\n{ yaw: 164.1026153564453,\n  pitch: -6.485481262207031,\n  roll: 2.9403600692749023 }", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/imu/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe IMU driver.  var creator_ip = '127.0.0.1'\nvar creator_imu_base_port = 20013  Load the protocol buffers used in the example.  var protoBuf = require( protobufjs )\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )  Subscribe to the errors reported by the driver.   var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: IMU error: ' + error_message.toString('utf8') +  \\n )\n});  All the drivers are configured using the message  DriverConfig  (see  driver.proto ).\nThis is what the message looks like if we omit the fields that are not used in this example.  message DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}  The following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.  var configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_imu_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())  Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.IMU.decode(buffer)\n  console.log(data)\n});  An empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_imu_base_port + 1))\nprocess.stdout.write( Sending pings every 5 seconds );\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/pressure/", 
            "text": "Pressure\n\n\nThe Pressure driver reports values for:\n\n\n\n\nPressure\n\n\nAltitude\n\n\nTemperature\n\n\n\n\nThe driver follows the \nMATRIX CORE protocol\n.\n\n\n0MQ Port\n\n\n20025\n\n\n\n\nProtocol buffers\n\n\nmessage Pressure {\n  float pressure = 1;\n  float altitude = 2;\n  float temperature = 3;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the MATRIX CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThe driver will send a serialized message of type \nPressure\n.\n\n\nmessage Pressure {\n  float pressure = 1;\n  float altitude = 2;\n  float temperature = 3;\n}\n\n\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_pressure.js \nSending pings every 5 seconds\n{ pressure: 74773.5, altitude: 2490.375, temperature: 35.9375 }\n{ pressure: 74776, altitude: 2490.3125, temperature: 35.9375 }\n\n\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by MATRIX CORE for\nthe Pressure driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_pressure_base_port = 20013 + (4 * 3)\n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n)\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse MATRIX matrix_CORE package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver. \n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\nThis is what the message looks like if we omit the fields that are not used in this example.\n\n\nmessage DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}\n\n\n\n\nThe following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.\n\n\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_pressure_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n\n\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.Pressure.decode(buffer)\n  console.log(data)\n});\n\n\n\n\nAn empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 1))\nprocess.stdout.write(\nSending pings every 5 seconds\n);\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#pressure", 
            "text": "The Pressure driver reports values for:   Pressure  Altitude  Temperature   The driver follows the  MATRIX CORE protocol .", 
            "title": "Pressure"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#0mq-port", 
            "text": "20025", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#protocol-buffers", 
            "text": "message Pressure {\n  float pressure = 1;\n  float altitude = 2;\n  float temperature = 3;\n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the MATRIX CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#read", 
            "text": "The driver will send a serialized message of type  Pressure .  message Pressure {\n  float pressure = 1;\n  float altitude = 2;\n  float temperature = 3;\n}  This is a sample output given by the example described below.  $ node test_pressure.js \nSending pings every 5 seconds\n{ pressure: 74773.5, altitude: 2490.375, temperature: 35.9375 }\n{ pressure: 74776, altitude: 2490.3125, temperature: 35.9375 }", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/pressure/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by MATRIX CORE for\nthe Pressure driver.  var creator_ip = '127.0.0.1'\nvar creator_pressure_base_port = 20013 + (4 * 3)  Load the protocol buffers used in the example.  var protoBuf = require( protobufjs )\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse MATRIX matrix_CORE package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )  Subscribe to the errors reported by the driver.   var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: Pressure error: ' + error_message.toString('utf8') +  \\n )\n});  All the drivers are configured using the message  DriverConfig  (see  driver.proto ).\nThis is what the message looks like if we omit the fields that are not used in this example.  message DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}  The following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.  var configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_pressure_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())  Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.Pressure.decode(buffer)\n  console.log(data)\n});  An empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_pressure_base_port + 1))\nprocess.stdout.write( Sending pings every 5 seconds );\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/servo/", 
            "text": "GPIO\n\n\nThe Servo driver on current version supports:\n\n\n\n\n\nHandle Servo via GPIO pin output\n\n\nSet Servo angle (180\u00f8 servo for the moment)\n\n\n\n\nThe driver follows the \nCORE protocol\n.\n\n\nGPIO electrical characteristics\n\n\n\n\nGPIO voltage: 0.60-4.10 VDC (\ndetails\n)\n\n\ncurrent 10mA max\n\n\nall GPIO pins need pullups\n\n\nrequiere external source for servo\n\n\n\n\n\n\n0MQ Port\n\n\n20045\n\n\n\n\nProtocol buffers\n\n\n// Servo handler params\nmessage ServoParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // Servo mode\n  uint32 angle = 2; \n}\n\n\n\n\nThe message is defined in \ndriver.proto\n.\n\n\nErrors\n\n\nThis driver reports errors when an invalid configuration is sent.\n\n\nWrite\n\n\nAll pins on matrix creator start as inputs. You need to change the default settings. (see Javascript example below)\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_servo.js \nangle: 0\nangle: 10\nangle: 20\nangle: 30\nangle: 40\n\n\n\n\n(The servo motor will change by the different angles)\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_servo_base_port = 20013 + 32\n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n);\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nConnection to servo driver\n\n\nvar zmq = require('zmq')\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_servo_base_port /* config */)\n\n\n\n\nConfigure Servo GPIO pin and send angle:\n\n\nAll the drivers are configured using the message \ndriverconfig\n (see \ndriver.proto\n).\n\n\nfunction sendServoCommand() {\n  // build servo params message\n  var servo_cfg_cmd = new matrixMalosBuilder.ServoParams;\n  // Servo attached on GPIO13 (for example)\n  servo_cfg_cmd.set_pin(13);\n\n  // change angle on each tick\n  process.nextTick(function() {count=count+10});\n  var angle=count%180;\n  console.log('angle:',angle);\n\n  // set servo angle\n  servo_cfg_cmd.set_angle(angle);\n\n  // build DriverConfig message\n  var config = new matrixMalosBuilder.DriverConfig;\n  config.set_servo(servo_cfg_cmd);\n  configSocket.send(config.encode().toBuffer());\n}\n\n\n\n\nSend continuous configuration:\n\n\nsendServoCommand()\nsetInterval(function() {\n  sendServoCommand()\n}, 3000);", 
            "title": "Servo"
        }, 
        {
            "location": "/matrix-core/reference/servo/#gpio", 
            "text": "The Servo driver on current version supports:   Handle Servo via GPIO pin output  Set Servo angle (180\u00f8 servo for the moment)   The driver follows the  CORE protocol .", 
            "title": "GPIO"
        }, 
        {
            "location": "/matrix-core/reference/servo/#gpio-electrical-characteristics", 
            "text": "GPIO voltage: 0.60-4.10 VDC ( details )  current 10mA max  all GPIO pins need pullups  requiere external source for servo", 
            "title": "GPIO electrical characteristics"
        }, 
        {
            "location": "/matrix-core/reference/servo/#0mq-port", 
            "text": "20045", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/servo/#protocol-buffers", 
            "text": "// Servo handler params\nmessage ServoParams {\n  // GPIO to config\n  uint32 pin = 1;\n\n  // Servo mode\n  uint32 angle = 2; \n}  The message is defined in  driver.proto .", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/servo/#errors", 
            "text": "This driver reports errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/servo/#write", 
            "text": "All pins on matrix creator start as inputs. You need to change the default settings. (see Javascript example below)  This is a sample output given by the example described below.  $ node test_servo.js \nangle: 0\nangle: 10\nangle: 20\nangle: 30\nangle: 40  (The servo motor will change by the different angles)", 
            "title": "Write"
        }, 
        {
            "location": "/matrix-core/reference/servo/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe Pressure driver.  var creator_ip = '127.0.0.1'\nvar creator_servo_base_port = 20013 + 32", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/reference/servo/#load-the-protocol-buffers-used-in-the-example", 
            "text": "var protoBuf = require( protobufjs );\n// parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )", 
            "title": "Load the protocol buffers used in the example."
        }, 
        {
            "location": "/matrix-core/reference/servo/#connection-to-servo-driver", 
            "text": "var zmq = require('zmq')\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_servo_base_port /* config */)", 
            "title": "Connection to servo driver"
        }, 
        {
            "location": "/matrix-core/reference/servo/#configure-servo-gpio-pin-and-send-angle", 
            "text": "All the drivers are configured using the message  driverconfig  (see  driver.proto ).  function sendServoCommand() {\n  // build servo params message\n  var servo_cfg_cmd = new matrixMalosBuilder.ServoParams;\n  // Servo attached on GPIO13 (for example)\n  servo_cfg_cmd.set_pin(13);\n\n  // change angle on each tick\n  process.nextTick(function() {count=count+10});\n  var angle=count%180;\n  console.log('angle:',angle);\n\n  // set servo angle\n  servo_cfg_cmd.set_angle(angle);\n\n  // build DriverConfig message\n  var config = new matrixMalosBuilder.DriverConfig;\n  config.set_servo(servo_cfg_cmd);\n  configSocket.send(config.encode().toBuffer());\n}", 
            "title": "Configure Servo GPIO pin and send angle:"
        }, 
        {
            "location": "/matrix-core/reference/servo/#send-continuous-configuration", 
            "text": "sendServoCommand()\nsetInterval(function() {\n  sendServoCommand()\n}, 3000);", 
            "title": "Send continuous configuration:"
        }, 
        {
            "location": "/matrix-core/reference/uv/", 
            "text": "UV\n\n\nThe UV driver reports values for:\n\n\n\n\nUV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From \nUV Index Scale\n\n\nUV Risk scale established by World Health Organization. From \nUV Index Scale\n\n\n\n\nThe driver follows the \nCORE protocol\n.\n\n\n0MQ Port\n\n\n20029\n\n\n\n\nProtocol buffers\n\n\nmessage UV{\n  float uv_index = 1;\n  string oms_risk = 2;\n}\n\n\n\n\nThe message is defined in \ndriver.proto\n\n\nKeep-alives\n\n\nThis driver needs keep-alive messages \nas specified in the CORE protocol\n.\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.\n\n\nErrors\n\n\nThis driver report errors when an invalid configuration is sent.\n\n\nRead\n\n\nThe driver will send a serialized message of type\nUV\n.\n\n\nmessage UV{\n  float uv_index = 1;\n  string oms_risk = 2;\n}\n\n\n\n\nThis is a sample output given by the example described below.\n\n\n$ node test_uv.js \nSending pings every 5 seconds\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n\n\n\n\nJavaScript example\n\n\nEnhanced description of the \nsample source code\n.\n\n\nFirst, define the address of the MATRIX Creator. In this case we make it be \n127.0.0.1\n\nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe UV driver.\n\n\nvar creator_ip = '127.0.0.1'\nvar creator_uv_base_port = 20013 + (4 * 4) \n\n\n\n\nLoad the protocol buffers used in the example.\n\n\nvar protoBuf = require(\nprotobufjs\n)\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build(\nmatrix_malos\n)\n\n\n\n\nSubscribe to the errors reported by the driver. \n\n\nvar zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: UV error: ' + error_message.toString('utf8') + \n\\n\n)\n});\n\n\n\n\nAll the drivers are configured using the message \nDriverConfig\n (see \ndriver.proto\n).\nThis is what the message looks like if we omit the fields that are not used in this example.\n\n\nmessage DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}\n\n\n\n\nThe following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.\n\n\nvar configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_uv_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())\n\n\n\n\nWhere is where the updates are received by subscribing to the \ndata update port\n of the driver.\nThe subscription is initiated by the line \nupdateSocket.subscribe('')\n.\n\n\nvar updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.UV.decode(buffer)\n  console.log(data)\n});\n\n\n\n\nAn empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.\n\n\nvar pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 1))\nprocess.stdout.write(\nSending pings every 5 seconds\n);\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/reference/uv/#uv", 
            "text": "The UV driver reports values for:   UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization.  From  UV Index Scale  UV Risk scale established by World Health Organization. From  UV Index Scale   The driver follows the  CORE protocol .", 
            "title": "UV"
        }, 
        {
            "location": "/matrix-core/reference/uv/#0mq-port", 
            "text": "20029", 
            "title": "0MQ Port"
        }, 
        {
            "location": "/matrix-core/reference/uv/#protocol-buffers", 
            "text": "message UV{\n  float uv_index = 1;\n  string oms_risk = 2;\n}  The message is defined in  driver.proto", 
            "title": "Protocol buffers"
        }, 
        {
            "location": "/matrix-core/reference/uv/#keep-alives", 
            "text": "This driver needs keep-alive messages  as specified in the CORE protocol .\nIf you start sending keep-alive messages it will start returning data every second so you can omit the configuration for this device.", 
            "title": "Keep-alives"
        }, 
        {
            "location": "/matrix-core/reference/uv/#errors", 
            "text": "This driver report errors when an invalid configuration is sent.", 
            "title": "Errors"
        }, 
        {
            "location": "/matrix-core/reference/uv/#read", 
            "text": "The driver will send a serialized message of type UV .  message UV{\n  float uv_index = 1;\n  string oms_risk = 2;\n}  This is a sample output given by the example described below.  $ node test_uv.js \nSending pings every 5 seconds\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }\n{ uv_index: 0, oms_risk: 'Low' }", 
            "title": "Read"
        }, 
        {
            "location": "/matrix-core/reference/uv/#javascript-example", 
            "text": "Enhanced description of the  sample source code .  First, define the address of the MATRIX Creator. In this case we make it be  127.0.0.1 \nbecause we are connecting from the local host but it needs to be different if we\nconnect from another computer. There is also the base port reserved by CORE for\nthe UV driver.  var creator_ip = '127.0.0.1'\nvar creator_uv_base_port = 20013 + (4 * 4)   Load the protocol buffers used in the example.  var protoBuf = require( protobufjs )\n\n// Parse proto file\nvar protoBuilder = protoBuf.loadProtoFile('../../protocol-buffers/malos/driver.proto')\n// Parse matrix_malos package (namespace).\nvar matrixMalosBuilder = protoBuilder.build( matrix_malos )  Subscribe to the errors reported by the driver.   var zmq = require('zmq')\n\nvar errorSocket = zmq.socket('sub')\nerrorSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 2))\nerrorSocket.subscribe('')\nerrorSocket.on('message', function(error_message) {\n  process.stdout.write('Message received: UV error: ' + error_message.toString('utf8') +  \\n )\n});  All the drivers are configured using the message  DriverConfig  (see  driver.proto ).\nThis is what the message looks like if we omit the fields that are not used in this example.  message DriverConfig {\n  float delay_between_updates = 1;\n  float timeout_after_last_ping = 2;\n}  The following snippet is telling the driver to send an update each 2 seconds\nand stop sending updates if it doesn't receive a keep-alive message for 6 seconds.  var configSocket = zmq.socket('push')\nconfigSocket.connect('tcp://' + creator_ip + ':' + creator_uv_base_port)\n\nvar driverConfigProto = new matrixMalosBuilder.DriverConfig\n\ndriverConfigProto.delay_between_updates = 2.0\ndriverConfigProto.timeout_after_last_ping = 6.0\n\nconfigSocket.send(driverConfigProto.encode().toBuffer())  Where is where the updates are received by subscribing to the  data update port  of the driver.\nThe subscription is initiated by the line  updateSocket.subscribe('') .  var updateSocket = zmq.socket('sub')\nupdateSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 3))\nupdateSocket.subscribe('')\nupdateSocket.on('message', function(buffer) {\n  var data = new matrixMalosBuilder.UV.decode(buffer)\n  console.log(data)\n});  An empty keep-alive message is sent to the driver every 5 seconds to make sure it keeps\nsending data updates.  var pingSocket = zmq.socket('push')\npingSocket.connect('tcp://' + creator_ip + ':' + (creator_uv_base_port + 1))\nprocess.stdout.write( Sending pings every 5 seconds );\npingSocket.send(''); // Ping the first time.\nsetInterval(function(){\n  pingSocket.send('');\n}, 5000);", 
            "title": "JavaScript example"
        }, 
        {
            "location": "/matrix-core/troubleshooting/", 
            "text": "Check MATRIX CORE Services are Running\n\n\nRun the following command on your Raspberry Pi to confirm your MATRIX Services are running.\n\n\n$ ps aux | grep 'malos'\n\n\n\n\nThis should return something along the lines of:\n\n\nroot       445  0.0  0.6 126240  5964 ?        Ssl  16:51   0:00 /usr/bin/malos_eye\nroot       449  5.3  0.8 853204  8352 ?        Ssl  16:51   4:41 /usr/bin/malos\n\n\n\n\nRunning Services Manually\n\n\nIf your services are not listed as shown above, you can run them manually using the following terminal commands:\n\n\n# Running MATRIX CORE Sensors \n Comm. Services\n$ malos\n\n# Running MATRIX CORE Vision Services\n$ malos_eye\n\n\n\n\nStopping Services\n\n\n# Stopping the services altogether\n\n$ pkill -9 malos\n$ pkill -9 malos_eye\n\n\n\n\nSupport\n\n\n\n\nPost questions or comments on \ncommunity.matrix.one\n\n\nPost package issues on github under \nmatrix-io\n\n\nSubmit documentation issues or improvements at \nmatrix-io/matrix-documentation", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#check-matrix-core-services-are-running", 
            "text": "Run the following command on your Raspberry Pi to confirm your MATRIX Services are running.  $ ps aux | grep 'malos'  This should return something along the lines of:  root       445  0.0  0.6 126240  5964 ?        Ssl  16:51   0:00 /usr/bin/malos_eye\nroot       449  5.3  0.8 853204  8352 ?        Ssl  16:51   4:41 /usr/bin/malos", 
            "title": "Check MATRIX CORE Services are Running"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#running-services-manually", 
            "text": "If your services are not listed as shown above, you can run them manually using the following terminal commands:  # Running MATRIX CORE Sensors   Comm. Services\n$ malos\n\n# Running MATRIX CORE Vision Services\n$ malos_eye", 
            "title": "Running Services Manually"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#stopping-services", 
            "text": "# Stopping the services altogether\n\n$ pkill -9 malos\n$ pkill -9 malos_eye", 
            "title": "Stopping Services"
        }, 
        {
            "location": "/matrix-core/troubleshooting/#support", 
            "text": "Post questions or comments on  community.matrix.one  Post package issues on github under  matrix-io  Submit documentation issues or improvements at  matrix-io/matrix-documentation", 
            "title": "Support"
        }, 
        {
            "location": "/matrix-hal/", 
            "text": "Overview\n\n\nHAL is the lowest-level abstraction for the MATRIX Creator drivers. You can interface directly with HAL, or use the higher level components like \nCORE\n, and \nMATRIX OS\n.\n\n\nTooling\n\n\n\n\nxc3sprog\n - To program the FPGA.\n\n\nOpenOCD\n - To program the microcontroller.\n\n\n\n\nExample Software Integrations\n\n\n\n\nMATRIX CORE\n\n\nMATRIX OS", 
            "title": "MATRIX HAL"
        }, 
        {
            "location": "/matrix-hal/#overview", 
            "text": "HAL is the lowest-level abstraction for the MATRIX Creator drivers. You can interface directly with HAL, or use the higher level components like  CORE , and  MATRIX OS .", 
            "title": "Overview"
        }, 
        {
            "location": "/matrix-hal/#tooling", 
            "text": "xc3sprog  - To program the FPGA.  OpenOCD  - To program the microcontroller.", 
            "title": "Tooling"
        }, 
        {
            "location": "/matrix-hal/#example-software-integrations", 
            "text": "MATRIX CORE  MATRIX OS", 
            "title": "Example Software Integrations"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/", 
            "text": "Installation\n\n\nInstall from package\n\n\nIf you haven't already installed the required MATRIX packages that configure everything after each boot, please install:\n\n\n# Add repo and key\ncurl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add -\necho \ndeb https://apt.matrix.one/raspbian $(lsb_release -sc) main\n | sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n# Update packages and install\nsudo apt-get update\nsudo apt-get upgrade\n\n# Installation\nsudo apt-get install matrixio-creator-init libmatrixio-creator-hal libmatrixio-creator-hal-dev\n\n# Reboot after installation\nsudo reboot\n\n\n\n\nInstall from source\n\n\nInstall Pre-Requisites\n\n\nsudo apt-get install cmake g++ git libfftw3-dev wiringpi libgflags-dev\n\n\n\n\nClone and Build\n\n\nTo start working with HAL directly, you'll need to clone it and then build it. \n\n\ngit clone https://github.com/matrix-io/matrix-creator-hal.git\ncd matrix-creator-hal\nmkdir build\ncd build\ncmake ..\nmake \n sudo make install\n\n\n\n\nContinue\n\n\n\n\nDo \nHello World\n\n\nTry out the \nhardware demos\n available inside the \ndemos\n directory.\n\n\nWrite and run your own HAL abstraction layer by using our \nComponent\n documentation.", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/#install-from-package", 
            "text": "If you haven't already installed the required MATRIX packages that configure everything after each boot, please install:  # Add repo and key\ncurl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add -\necho  deb https://apt.matrix.one/raspbian $(lsb_release -sc) main  | sudo tee /etc/apt/sources.list.d/matrixlabs.list\n\n# Update packages and install\nsudo apt-get update\nsudo apt-get upgrade\n\n# Installation\nsudo apt-get install matrixio-creator-init libmatrixio-creator-hal libmatrixio-creator-hal-dev\n\n# Reboot after installation\nsudo reboot", 
            "title": "Install from package"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/#install-from-source", 
            "text": "", 
            "title": "Install from source"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/#install-pre-requisites", 
            "text": "sudo apt-get install cmake g++ git libfftw3-dev wiringpi libgflags-dev", 
            "title": "Install Pre-Requisites"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/#clone-and-build", 
            "text": "To start working with HAL directly, you'll need to clone it and then build it.   git clone https://github.com/matrix-io/matrix-creator-hal.git\ncd matrix-creator-hal\nmkdir build\ncd build\ncmake ..\nmake   sudo make install", 
            "title": "Clone and Build"
        }, 
        {
            "location": "/matrix-hal/getting-started/installation/#continue", 
            "text": "Do  Hello World  Try out the  hardware demos  available inside the  demos  directory.  Write and run your own HAL abstraction layer by using our  Component  documentation.", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-hal/getting-started/hello-world/", 
            "text": "Basic Examples\n\n\nBasic examples can be found inside the \ndemo\n directory inside of the repository that you cloned during \ninstallation\n. Below we'll get you started with the Everloop demo which should turn the LEDs a \nblue\n color.\n\n\n# should already be in ~/matrix-creator-hal/build directory.\ncd demos\n\n# run the everloop demo\n./everloop_demo\n\n# see the rest of the examples\nls -l\n\n\n\n\nContinue\n\n\nMove onto the rest of the \nC++ examples\n.", 
            "title": "Hello World"
        }, 
        {
            "location": "/matrix-hal/getting-started/hello-world/#basic-examples", 
            "text": "Basic examples can be found inside the  demo  directory inside of the repository that you cloned during  installation . Below we'll get you started with the Everloop demo which should turn the LEDs a  blue  color.  # should already be in ~/matrix-creator-hal/build directory.\ncd demos\n\n# run the everloop demo\n./everloop_demo\n\n# see the rest of the examples\nls -l", 
            "title": "Basic Examples"
        }, 
        {
            "location": "/matrix-hal/getting-started/hello-world/#continue", 
            "text": "Move onto the rest of the  C++ examples .", 
            "title": "Continue"
        }, 
        {
            "location": "/matrix-hal/getting-started/next-steps/", 
            "text": "Next Steps\n\n\nShare your creation\n\n\nShow us know what you've made and we'll share it to our channels! \n\n\n\n\nMATRIX Community\n\n\nTutorials/Projects Pages\n\n\nVideos\n\n\nMATRIX Twitter", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-hal/getting-started/next-steps/#next-steps", 
            "text": "", 
            "title": "Next Steps"
        }, 
        {
            "location": "/matrix-hal/getting-started/next-steps/#share-your-creation", 
            "text": "Show us know what you've made and we'll share it to our channels!    MATRIX Community  Tutorials/Projects Pages  Videos  MATRIX Twitter", 
            "title": "Share your creation"
        }, 
        {
            "location": "/matrix-hal/examples/hardware-demos/", 
            "text": "Sensor Tests\n\n\nWith the following instructions you will be able to run demos for the Everloop LED Array and for the IMU. These demos make use of the \nhardware abstraction layer\n. Make sure you followed the \ngetting started\n steps.\n\n\nThus you can get the required source code and build it:\n\n\n    git clone https://github.com/matrix-io/matrix-creator-hal.git\n    cd matrix-creator-hal\n    mkdir build \n cd build\n    cmake .. \n make\n\n\n\n\nIf the project built with no issues you can run the demos. The demos run for ever, you can terminate them with Control+C.\n\n\nSpinning leds ( \nvideo\n ):\n\n\ndemos/everloop_demo\n\n\n\nArc demo ( \nvideo\n ) :\n\n\ndemos/arc_demo\n\n\n\nCompass demo:\n\n\ndemos/compass_demo\n\nyaw = -116.006  roll = 3.19588  pitch = 0.370596\nyaw = -116.577  roll = 3.61794  pitch = 0.210613\nyaw = -115.649  roll = 3.64227  pitch = 0.334733\nyaw = -115.468  roll = 3.34762  pitch = 0.42658\nyaw = -116.423  roll = 3.49536  pitch = 0.566351\n\n\n\nMicrophones:\n\n\ndemos/mic_demo\n\n52  29  54  74  74  49  39  60\n60  31  52  46  41  55  68  70\n60  44  55  43  53  68  62  62\n45  17  69  54  18  38  74  67\n\n(You get one value for each microphone)\n\n\n\nQuestions? Post them on \nraspberrypi.stackexchange.com\n! Use the tag #matrix-creator", 
            "title": "Sensor Tests"
        }, 
        {
            "location": "/matrix-hal/examples/hardware-demos/#sensor-tests", 
            "text": "With the following instructions you will be able to run demos for the Everloop LED Array and for the IMU. These demos make use of the  hardware abstraction layer . Make sure you followed the  getting started  steps.  Thus you can get the required source code and build it:      git clone https://github.com/matrix-io/matrix-creator-hal.git\n    cd matrix-creator-hal\n    mkdir build   cd build\n    cmake ..   make  If the project built with no issues you can run the demos. The demos run for ever, you can terminate them with Control+C.  Spinning leds (  video  ):  demos/everloop_demo  Arc demo (  video  ) :  demos/arc_demo  Compass demo:  demos/compass_demo\n\nyaw = -116.006  roll = 3.19588  pitch = 0.370596\nyaw = -116.577  roll = 3.61794  pitch = 0.210613\nyaw = -115.649  roll = 3.64227  pitch = 0.334733\nyaw = -115.468  roll = 3.34762  pitch = 0.42658\nyaw = -116.423  roll = 3.49536  pitch = 0.566351  Microphones:  demos/mic_demo\n\n52  29  54  74  74  49  39  60\n60  31  52  46  41  55  68  70\n60  44  55  43  53  68  62  62\n45  17  69  54  18  38  74  67\n\n(You get one value for each microphone)  Questions? Post them on  raspberrypi.stackexchange.com ! Use the tag #matrix-creator", 
            "title": "Sensor Tests"
        }, 
        {
            "location": "/help/", 
            "text": "Support\n\n\n\n\nPost questions or comments on \ncommunity.matrix.one\n\n\nAlert issues on our \nGitHub\n under the corresponding repository\n\n\nSubmit documentation issues or improvements to the \nMATRIX Documentation Repository", 
            "title": "Support"
        }, 
        {
            "location": "/help/#support", 
            "text": "Post questions or comments on  community.matrix.one  Alert issues on our  GitHub  under the corresponding repository  Submit documentation issues or improvements to the  MATRIX Documentation Repository", 
            "title": "Support"
        }
    ]
}